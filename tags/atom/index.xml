<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>http://tbd.kaitoy.xyz/tags/atom/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2015</rights>
    <updated>2015-12-21 00:07:28 -0700 MST</updated>

    
      
        <item>
          <title>ReactをAtomパッケージ開発で無理やり使ってみた</title>
          <link>http://tbd.kaitoy.xyz/2015/12/21/hello-react/</link>
          <pubDate>Mon, 21 Dec 2015 00:07:28 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/12/21/hello-react/</guid>
          <description>

&lt;p&gt;私は今&lt;a href=&#34;https://www.hpe.com/us/en/home.html&#34;&gt;HPE&lt;/a&gt;の&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A9%E3%83%BC%E3%83%88%E3%83%BB%E3%82%B3%E3%83%AA%E3%83%B3%E3%82%BA_%28%E3%82%B3%E3%83%AD%E3%83%A9%E3%83%89%E5%B7%9E%29&#34;&gt;Fort Collins&lt;/a&gt;オフィスに居候している。
HPEは最近、&lt;a href=&#34;https://facebook.github.io/react/&#34;&gt;React&lt;/a&gt;を使ったUXフレームワークである&lt;a href=&#34;http://www.grommet.io/docs/&#34;&gt;Grommet&lt;/a&gt;を開発していて、私が扱っている製品もそれを使う兆しが見えてきた。
Grommetはいずれ仕事で触ることになりそうなので、まずはReactの勉強をと思い、&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/19/atom-impress/&#34;&gt;とあるAtomパッケージ&lt;/a&gt;の開発に無理やり使ってみた。
このエントリでは、その作業の中で得た知識などについて書く。&lt;/p&gt;

&lt;p&gt;(因みにGrommetは&lt;a href=&#34;https://github.com/grommet/grommet&#34;&gt;GitHub&lt;/a&gt;で公開されているが、ほとんど話題になっておらずスターも現時点で245しかついていない。。。)&lt;/p&gt;

&lt;h2 id=&#34;reactとは&#34;&gt;Reactとは&lt;/h2&gt;

&lt;p&gt;ReactはFacebookが開発しているWeb UIのフレームワークで、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_Controller&#34;&gt;MVC&lt;/a&gt;のVだけを実装したもの。
2013年に最初のバージョンが公開され、世界中で流行ってきているらしい。&lt;/p&gt;

&lt;p&gt;その特徴(というかほぼ全容)は仮想DOM(&lt;a href=&#34;https://facebook.github.io/react/docs/glossary.html&#34;&gt;Virtual DOM&lt;/a&gt;)。
ReactのAPIを使うと、リアルDOMと一対一で対応する仮想DOMのツリーを作ることができ、UIを組み立てられる。
リアルDOMの構築や更新はReactが最適化された方法でやってくれるので、性能がいいUIができるらしい。
因みに、仮想DOM自体はReact特有の技術ではなく、別の実装もある。&lt;/p&gt;

&lt;p&gt;もう一つの特徴は&lt;a href=&#34;https://facebook.github.io/jsx/&#34;&gt;JSX&lt;/a&gt;。
これは、JavaScriptのコードの中で、XMLみたいな構文で仮想DOMを記述するための拡張構文。
これを使うとReactコードが見やすく簡単に書けるけど、当然普通のJavaScript実行環境では動かないので、プリコンパイルなどが必要になる。&lt;/p&gt;

&lt;p&gt;FacebookはReactを使った開発に&lt;a href=&#34;http://facebook.github.io/flux/docs/overview.html#content&#34;&gt;Flux&lt;/a&gt;というアーキテクチャの採用を推奨している。
FluxはMVCアーキテクチャに置き換わるもので、従来の複雑なデータフローに反発し、一方向のシンプルなデータフローを提供する。
Fluxは単なるアーキテクチャで、その全体の実装を支援するフレームワークは現時点では無い。
(多分。&lt;a href=&#34;https://facebook.github.io/relay/&#34;&gt;Relay&lt;/a&gt;が一部支援してくれるっぽい。)&lt;/p&gt;

&lt;h2 id=&#34;reactを触った感想&#34;&gt;Reactを触った感想&lt;/h2&gt;

&lt;p&gt;Reactは本当にちょっとしか触っていないので、あまりよく分かっていないんだろうけど、なんだか使いにくかった。&lt;/p&gt;

&lt;p&gt;Reactは仮想DOMを作るところしか助けてくれないので、他のことは全部自分でやらないといけない。
FacebookはReact用のウィジェットすら提供していない。
昔仕事で全部入りの&lt;a href=&#34;https://ja.wikipedia.org/wiki/Dojo_Toolkit&#34;&gt;Dojo&lt;/a&gt;を使っていたので、それとのギャップをすごい感じた。&lt;/p&gt;

&lt;p&gt;そのうえ、他のフレームワークやライブラリと組み合わせて使おうとすると仮想DOMが壁になってくる。普通のフレームワークはリアルDOMを扱うからだ。
例えば、JavaScriptを書いているとすぐ&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;を使いたくなるが、これでリアルDOMを直接いじってしまってはReactを使う意味がない気がする。&lt;/p&gt;

&lt;h2 id=&#34;atomパッケージでreactを使う&#34;&gt;AtomパッケージでReactを使う&lt;/h2&gt;

&lt;p&gt;Reactは&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;でも提供されていて、Atomパッケージの開発に簡単に使える。
パッケージの&lt;code&gt;package.json&lt;/code&gt;の&lt;code&gt;dependencies&lt;/code&gt;に&lt;a href=&#34;https://www.npmjs.com/package/react&#34;&gt;react&lt;/a&gt;と&lt;a href=&#34;https://www.npmjs.com/package/react-dom&#34;&gt;react-dom&lt;/a&gt;を入れておけば、パッケージコード中で以下の様に仮想DOMを作れるようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var React = require(&#39;react&#39;);
var ReactDOM = require(&#39;react-dom&#39;);

class MyComponent extends React.Component {
  render() {
    return &amp;lt;div&amp;gt;Hello World&amp;lt;/div&amp;gt;;
  }
}

ReactDOM.render(&amp;lt;MyComponent /&amp;gt;, node);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;babelによるjsxの手動コンパイル&#34;&gt;BabelによるJSXの手動コンパイル&lt;/h2&gt;

&lt;p&gt;JSXのコンパイルには&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;を使うのがいい。
手動コンパイルにはBabelのコマンドラインツールが必要で、これはnpmで提供されている。
npmコマンドはAtomに同梱されているので別途インストールは不要。&lt;/p&gt;

&lt;p&gt;以下が手順の詳細。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Babelのコマンドラインツールのインストール&lt;/p&gt;

&lt;p&gt;任意の場所で、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm install -g babel-cli
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行すると、Babelのコマンドラインツールがグローバルにインストールされ、任意の場所で&lt;code&gt;babel&lt;/code&gt;コマンドが使えるようになる。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Babelの定義ファイル作成&lt;/p&gt;

&lt;p&gt;適当なフォルダ(プロジェクトのルートなど)に&lt;code&gt;.babelrc&lt;/code&gt;というBabelの定義ファイルを作り、以下を書いておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;presets&amp;quot;: [&amp;quot;react&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reactプラグインのインストール&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;に書いた&lt;code&gt;presets&lt;/code&gt;の値は、コンパイルにReactプラグインを使うという意味。
なので、以下のコマンドでReactプラグインを(ローカルに)インストールする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd &amp;lt;.babelrcを置いたフォルダ&amp;gt;
npm install babel-preset-react
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;コンパイル&lt;/p&gt;

&lt;p&gt;&lt;code&gt;babel&lt;/code&gt;コマンドでコンパイルを実行する。例えば以下を実行すると、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd &amp;lt;.babelrcを置いたフォルダ&amp;gt;
babel src -d lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/*.jsx&lt;/code&gt;がコンパイルされて、&lt;code&gt;lib/*.js&lt;/code&gt;に出力される。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;language-babelパッケージによるjsxの自動コンパイル&#34;&gt;language-babelパッケージによるJSXの自動コンパイル&lt;/h2&gt;

&lt;p&gt;上記Babelによるコンパイルは、Atomなら&lt;a href=&#34;https://atom.io/packages/language-babel&#34;&gt;language-babelパッケージ&lt;/a&gt;で自動化できる。&lt;/p&gt;

&lt;p&gt;以下、Atomパッケージの開発でlanguage-babelを利用する手順を書く。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;language-babelのインストール&lt;/p&gt;

&lt;p&gt;language-babelをAtomのSettingsなどからインストールして、language-babelのSettingsで、&lt;code&gt;Allow Local Override&lt;/code&gt;にチェックを付ける。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Babelの定義ファイル作成&lt;/p&gt;

&lt;p&gt;手動のと同じ内容の&lt;code&gt;.babelrc&lt;/code&gt;をパッケージプロジェクトのルートに置く。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;package.json編集&lt;/p&gt;

&lt;p&gt;パッケージプロジェクトの&lt;code&gt;package.json&lt;/code&gt;の&lt;code&gt;dependencies&lt;/code&gt;の下あたりに以下の定義を追加して、BabelとReactプラグインへの依存を張る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;devDependencies&amp;quot;: {
    &amp;quot;babel-core&amp;quot;: &amp;quot;^6.1.2&amp;quot;,
    &amp;quot;babel-preset-react&amp;quot;: &amp;quot;^6.1.2&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記定義を追加したら、&lt;code&gt;apm install&lt;/code&gt;を実行して追加した依存をダウンロードする。&lt;/p&gt;

&lt;p&gt;因みに、&lt;code&gt;devDependencies&lt;/code&gt;は&lt;code&gt;dependencies&lt;/code&gt;と似てるけど、開発時だけに必要なモジュールを定義するプロパティ。
&lt;code&gt;devDependencies&lt;/code&gt;に書いたものは&lt;code&gt;apm install&lt;/code&gt;したときはダウンロードされるけど、パブリッシュされたものをインストールするときにはダウンロードされない。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;language-babelの設定ファイル作成&lt;/p&gt;

&lt;p&gt;language-babelの設定は&lt;code&gt;.languagebabel&lt;/code&gt;というファイルにかく。
これに以下の様な内容を書いてパッケージプロジェクトのルートに置く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;babelMapsPath&amp;quot;:                   &amp;quot;lib&amp;quot;,
  &amp;quot;babelMapsAddUrl&amp;quot;:                 false,
  &amp;quot;babelSourcePath&amp;quot;:                 &amp;quot;src&amp;quot;,
  &amp;quot;babelTranspilePath&amp;quot;:              &amp;quot;lib&amp;quot;,
  &amp;quot;createMap&amp;quot;:                       false,
  &amp;quot;createTargetDirectories&amp;quot;:         true,
  &amp;quot;createTranspiledCode&amp;quot;:            true,
  &amp;quot;disableWhenNoBabelrcFileInPath&amp;quot;:  false,
  &amp;quot;suppressSourcePathMessages&amp;quot;:      true,
  &amp;quot;suppressTranspileOnSaveMessages&amp;quot;: false,
  &amp;quot;transpileOnSave&amp;quot;:                 true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;&amp;lt;パッケージプロジェクトのルート&amp;gt;/src/*.jsx&lt;/code&gt;が、Atomで編集して保存したときにコンパイルされ、&lt;code&gt;&amp;lt;パッケージプロジェクトのルート&amp;gt;/lib/*.js&lt;/code&gt;に出力されるようになった。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;babelでjsxをコンパイルする場合の制限&#34;&gt;BabelでJSXをコンパイルする場合の制限&lt;/h2&gt;

&lt;p&gt;手動にしろ自動にしろ、JSXのコンパイルにBabelを使う場合、BabelがCoffeeScriptに対応していないので、CoffeeScript + JSXでは書けない。
JavaScript + JSXで書かないといけない。&lt;/p&gt;

&lt;h2 id=&#34;minified-exception&#34;&gt;Minified exception&lt;/h2&gt;

&lt;p&gt;React周りでバグを作りこんでエラーが発生した場合、コンソールに以下のようなエラーメッセージが出ることがある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Uncaught Error: Minified exception occured; use the non-minified dev environment for the full error message and additional helpful warnings.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これではエラーの詳細はわからない。詳細を見たい場合は、AtomをDev Modeで開いておく必要がある。
(e.g. Atomのメニューバーの[View]&amp;gt;[Developer]&amp;gt;[Open In Dev Mode]から開く。)&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>impress.jsでのプレゼン資料作成をサポートするAtomパッケージ - impress</title>
          <link>http://tbd.kaitoy.xyz/2015/12/19/atom-impress/</link>
          <pubDate>Sat, 19 Dec 2015 23:37:08 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/12/19/atom-impress/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://atom.io/&#34;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;/a&gt;のパッケージを作った話。&lt;/p&gt;

&lt;p&gt;ついでに、パッケージプロジェクト内で別のプロジェクトを取り込んで使いたい場合に、&lt;a href=&#34;https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E3%82%B5%E3%83%96%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB&#34;&gt;Gitのサブモジュール&lt;/a&gt;を使ってはダメという話。&lt;/p&gt;

&lt;h2 id=&#34;impress-js&#34;&gt;impress.js&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/impress/impress.js&#34;&gt;&lt;strong&gt;impress.js&lt;/strong&gt;&lt;/a&gt;というJavaScriptライブラリがある。
HTML5とCSS3とJavaScriptでプレゼン資料を作るためのライブラリで、これを使うと、&lt;a href=&#34;https://products.office.com/ja-jp/powerpoint&#34;&gt;PowerPoint&lt;/a&gt;や&lt;a href=&#34;http://www.apple.com/jp/mac/keynote/&#34;&gt;Keynote&lt;/a&gt;といった従来のツールによるものからは一線を画す斬新な資料を作ることができる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://impress.github.io/impress.js/#/bored&#34;&gt;公式のデモ&lt;/a&gt;を見ればその魅力を堪能できる。&lt;/p&gt;

&lt;p&gt;デモを見ると分かるが、&lt;a href=&#34;https://prezi.com/&#34;&gt;&lt;strong&gt;Prezi&lt;/strong&gt;&lt;/a&gt;に触発されたライブラリだ。
Preziでも非常に新鮮な資料を作れるが、ほぼ有料で、また作成した資料をPreziのサーバに置かなければいけないので、仕事で使う資料作りには使いにくい。
その点impress.jsは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/MIT_License&#34;&gt;MIT&lt;/a&gt;(と&lt;a href=&#34;https://ja.wikipedia.org/wiki/GNU_General_Public_License&#34;&gt;GPLv2&lt;/a&gt;)で公開されていて自由に無料で使えるのがよい。&lt;/p&gt;

&lt;p&gt;ただし、Preziがスライドという概念から大きく脱却しているのに対して、実のところimpress.jsで作れる資料はあくまでスライドベースだ。
従来のものに比べてスライドの並びに制約がなく、スライド間の遷移がダイナミックというだけだ。
impress.jsでもまあ工夫すればPreziのような資料は作れるが。
独自のオーサリングツール/ビューワに依存するPreziに対し、impress.jsは標準的なHTML/CSS/JavaScriptにだけ依存しているので、&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;などのWeb技術を活用してスライドを作れるという副次的なメリットはある。&lt;/p&gt;

&lt;p&gt;impress.jsは、2012年に最初のバージョンが公開されてからもう4年近く経つが、未だにそれほど広く使われている様子はない。
PowerPointが幅を利かせているせいもあるだろうが、その使い辛さから利用をためらう人が多いのではないだろうか。
impress.jsはあまりドキュメントが充実しているとは言えない。
&lt;a href=&#34;https://github.com/impress/impress.js#how-to-use-it&#34;&gt;GitHubに公開されているREADME&lt;/a&gt;には、使い方はソースを見よ、それで分からないなら使うなとある。
さらにソース中には、impress.jsを使うには、HTMLとCSSのスキルに加えてデザイナーのセンスも必要とある。
かなりハードルを上げている。&lt;/p&gt;

&lt;p&gt;このハードルをクリアしていたとしても、実際、impress.jsで資料を作るのはPowerPointに比べて10倍は大変だ。
impress.jsはスライド(impress.js用語ではステップ)間の遷移を制御してくれるだけで、各スライドのコンテンツを作るという部分に関してはなんのサポートも提供しない。
テンプレートもなければ、表やグラフを書く機能もなく、アニメーションも作れない。
そういうことをしたければ、自分で別途ライブラリを探して使うなりしないといけない。&lt;/p&gt;

&lt;p&gt;ちょっとした図を書くにも、テキストエディタでちまちまHTMLとCSSを書いて、ブラウザで表示して確認して、思った通りになっていなければディベロッパツールでデバッグして、Web UIでも書いていたんだっけという気になってくる。&lt;/p&gt;

&lt;h2 id=&#34;impressパッケージ&#34;&gt;impressパッケージ&lt;/h2&gt;

&lt;p&gt;そんな負担を少しでも軽くしたいと思って作ったのが&lt;a href=&#34;https://atom.io/packages/impress&#34;&gt;impressパッケージ&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;同じ目的のツール(i.e. オーサリングツール)は実は既に&lt;a href=&#34;https://github.com/impress/impress.js/wiki/Examples-and-demos#authoring-tools&#34;&gt;いくつかあった&lt;/a&gt;。
なかでも、&lt;a href=&#34;https://github.com/regebro/hovercraft&#34;&gt;Hovercraft!&lt;/a&gt;というのが高機能で便利そう。
ただ、これらはPowerPointほど自在にスライドを作れるまでには至っておらず、結局は仕上げにHTML/CSSを手でいじる作業が必要になる。(と思う。)
また、jQueryのプラグイン使ってかっこいいことしたいとか言う場合にも、手でコードを書かなければいけない。&lt;/p&gt;

&lt;p&gt;つまりテキストエディタを開かなければいけない。よってAtomを起動することになる。(私は。)&lt;/p&gt;

&lt;p&gt;であれば、オーサリングツールもAtomに統合されていた方が便利なんじゃないの?
というのがimpressパッケージを作った動機。&lt;/p&gt;

&lt;p&gt;まだ機能は少なくて、新規資料プロジェクトの雛形生成、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/atom-impress/new_project.gif&#34; alt=&#34;new_project&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ステップをリスト表示するビュー表示、&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/atom-impress/step_list_view.gif&#34; alt=&#34;step_list_view&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;プレビューができるだけ。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/atom-impress/preview.gif&#34; alt=&#34;preview&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ゆくゆくは、GUIでステップの配置や角度を編集する機能、GUIでステップ内の図を作成する機能を作りたい。
あとできればアニメーションを付ける機能とかも。
Hovercraft!みたいにHTML書かなくてもいいよ、というのを目指すつもりはなくて、あくまでもコーダーのための、コーディングを補助するツールを目指す。&lt;/p&gt;

&lt;h2 id=&#34;パッケージのサブモジュール&#34;&gt;パッケージのサブモジュール&lt;/h2&gt;

&lt;p&gt;impressパッケージは、新規資料プロジェクトの雛形生成機能などのため、impress.jsプロジェクト(の&lt;a href=&#34;https://github.com/kaitoy/impress.js&#34;&gt;フォーク&lt;/a&gt;)をサブモジュールとしてとりこんでいる。&lt;/p&gt;

&lt;p&gt;最初はGitのサブモジュールコマンド(&lt;code&gt;git submodule&lt;/code&gt;)を使って取り込んでいて、上手くいっているように見えたが、パブリッシュ後に次のような問題が発生した。
即ち、試しにimpressパッケージをインストールしてみたら、サブモジュールのフォルダの中身がからっぽだった。&lt;/p&gt;

&lt;p&gt;これは、Atomのパッケージマネージャがパッケージを&lt;a href=&#34;https://help.github.com/articles/about-releases/&#34;&gt;GitHub Releases&lt;/a&gt;から&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/02/unpublish-atom-package/#%E6%B3%A8%E6%84%8F%E3%81%99%E3%81%B9%E3%81%8D%E7%82%B9-3-%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5&#34;&gt;ダウンロードしてインストールする&lt;/a&gt;からだ。サブモジュールの中身はGitHub Releasesに登録されるアーカイブに含まれない。このGitHub Releasesの挙動は、サブモジュールを含むGitプロジェクトをクローンした場合、&lt;a href=&#34;https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E3%81%95%E3%81%BE%E3%81%96%E3%81%BE%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB-%E3%82%B5%E3%83%96%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB#%E3%82%B5%E3%83%96%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%82%92%E5%90%AB%E3%82%80%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E3%82%AF%E3%83%AD%E3%83%BC%E3%83%B3&#34;&gt;デフォルトではサブモジュールはクローンされない&lt;/a&gt;というGitサブモジュールの仕様に関係しているのかもしれない。&lt;/p&gt;

&lt;p&gt;この問題をきっかけにGitサブモジュールについてちょっと調べてみた。
&lt;a href=&#34;https://www.oreilly.co.jp/books/9784873114408/&#34;&gt;蝙蝠本&lt;/a&gt;によると、Git開発チームはあまりサブモジュールコマンドの開発に熱心ではなく真面目に作らなかったらしい。
また、&lt;a href=&#34;http://japan.blogs.atlassian.com/2014/03/alternatives-to-git-submodule-git-subtree/&#34;&gt;あるブログ&lt;/a&gt;によればサブモジュールコマンドは大分まえからオワコンらしい。このブログによれば、今は多くの場合&lt;code&gt;git subtree&lt;/code&gt;を使うのがいいとのこと。&lt;code&gt;git subtree&lt;/code&gt;は蝙蝠本にも&lt;a href=&#34;https://git-scm.com/book/en/v2&#34;&gt;Pro Git&lt;/a&gt;にも載ってないのだが。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git subtree&lt;/code&gt;でプロジェクトを取り込んだ場合、親プロジェクトのクローン時にサブプロジェクトもデフォルトでクローンされる仕様だ。
(というか正しくは、サブモジュールと違って、子プロジェクトが親プロジェクトにマージされているから、一緒にクローンされるというだけ。)
これを使ってimpressパッケージを構成しなおしてみたら件の問題が解決した。
因みにやりかたは、impressパッケージプロジェクトのルートに&lt;code&gt;impress.js&lt;/code&gt;というフォルダを作った後、以下のコマンドを実行しただけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git subtree add --prefix impress.js git@github.com:kaitoy/impress.js.git master --squash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ということで、Atomのパッケージに別のプロジェクトを取り込んで使いたい場合は、&lt;code&gt;git submodule&lt;/code&gt;ではなく、&lt;code&gt;git subtree&lt;/code&gt;を使わないといけないという教訓を得た。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Atomパッケージをアンパブリッシュする</title>
          <link>http://tbd.kaitoy.xyz/2015/12/02/unpublish-atom-package/</link>
          <pubDate>Wed, 02 Dec 2015 11:23:02 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/12/02/unpublish-atom-package/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://atom.io/&#34;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;/a&gt;のパッケージをリリースすることをパブシッシュというが、リリースを取り消すことをアンパブリッシュという。
この記事はそのアンパブリッシュのやり方などについて。&lt;/p&gt;

&lt;p&gt;筆者の環境は以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Windows 7 x64&lt;/li&gt;
&lt;li&gt;Atom 1.2.4&lt;/li&gt;
&lt;li&gt;Git for Windows 2.6.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;アンパブリッシュのやり方&#34;&gt;アンパブリッシュのやり方&lt;/h2&gt;

&lt;p&gt;リリースしたパッケージのプロジェクトのルートフォルダ(package.jsonがあるところ)に&lt;code&gt;cd&lt;/code&gt;して、&lt;code&gt;apm unpublish&lt;/code&gt;を実行するだけ。&lt;/p&gt;

&lt;p&gt;または、任意のフォルダで&lt;code&gt;apm unpublish &amp;lt;パッケージ名&amp;gt;&lt;/code&gt;を実行する。&lt;/p&gt;

&lt;p&gt;特定のバージョンだけアンパブリッシュしたい場合は、&lt;code&gt;apm unpublish &amp;lt;パッケージ名&amp;gt;@&amp;lt;バージョン&amp;gt;&lt;/code&gt;。例えば&lt;code&gt;apm unpublish disturb-me@0.1.0&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;注意すべき点-1-git-bashでアンパブリッシュするとエラー&#34;&gt;注意すべき点 1: Git Bashでアンパブリッシュするとエラー&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://git-for-windows.github.io/&#34;&gt;Git for Windows&lt;/a&gt;のGit Bash上で、Windows版Atomに付属するapmで&lt;code&gt;apm unpublish&lt;/code&gt;を実行すると以下のエラーが出る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;Error: EINVAL, invalid argument
    at new Socket (net.js:157:18)
    at process.stdin (node.js:693:19)
    at Unpublish.module.exports.Unpublish.promptForConfirmation (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib

\unpublish.js:87:48)
    at Unpublish.module.exports.Unpublish.run (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\unpublish.js:126:21)
    at Object.module.exports.run (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\apm-cli.js:226:32)
    at Object.&amp;lt;anonymous&amp;gt; (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\cli.js:6:7)
    at Object.&amp;lt;anonymous&amp;gt; (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\cli.js:17:4)
    at Module._compile (module.js:456:26)
    at Object.Module._extensions..js (module.js:474:10)
    at Module.load (module.js:356:32)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;コマンドプロンプトでやるべし。&lt;/p&gt;

&lt;h2 id=&#34;注意すべき点-2-アンパブリッシュはパブリッシュの真逆じゃない&#34;&gt;注意すべき点 2: アンパブリッシュはパブリッシュの真逆じゃない&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/#10-%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%B7%E3%83%A5&#34;&gt;以前の記事&lt;/a&gt;で
&lt;code&gt;apm publish&lt;/code&gt;は以下の処理をすると書いた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;(初回のみ)パッケージ名をatom.ioに登録する。&lt;/li&gt;
&lt;li&gt;package.jsonのversionをインクリメントしてコミットする。&lt;code&gt;apm publish&lt;/code&gt;にminorを指定するので、0.1.0になる。代わりにmajorかpatchを指定すると、1.0.0か0.0.1になる。&lt;/li&gt;
&lt;li&gt;Gitのタグを作る。&lt;/li&gt;
&lt;li&gt;GitHubに変更とタグをpushする。&lt;/li&gt;
&lt;li&gt;atom.ioにパッケージを登録する。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;この内、&lt;code&gt;apm unpublish&lt;/code&gt;が取り消してくれるのは 5 だけ。&lt;/p&gt;

&lt;p&gt;3, 4 のタグ作成も取り消したいのであれば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git tag -d v0.1.0
git push origin :v0.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;のようにして、ローカルレポジトリとリモートレポジトリ両方のタグを削除する。&lt;/p&gt;

&lt;p&gt;また、2 のpackage.jsonのversion変更を取り消したいのであれば、&lt;code&gt;git log&lt;/code&gt;で&lt;code&gt;Prepare 0.1.0 release&lt;/code&gt;みたいなログのコミットをさがしてそのハッシュをメモり、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git revert &amp;lt;ハッシュ&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;を実行して&lt;code&gt;git push&lt;/code&gt;。(上記&amp;lt;ハッシュ&amp;gt;の部分は、&lt;code&gt;apm publish&lt;/code&gt;後何もcommitしてないなら&lt;code&gt;HEAD&lt;/code&gt;でもよし。)&lt;/p&gt;

&lt;h2 id=&#34;注意すべき点-3-パッケージのキャッシュ&#34;&gt;注意すべき点 3: パッケージのキャッシュ&lt;/h2&gt;

&lt;p&gt;とあるパッケージ、仮に&lt;code&gt;hoge&lt;/code&gt;を開発していたとき、以下のような操作をした後に変な現象が起こった。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;バージョン&lt;code&gt;0.1.0&lt;/code&gt;をパブリッシュ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hoge&lt;/code&gt;をちゃんとインストールできるかを確認するために、

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;apm unlink hoge&lt;/code&gt;で&lt;code&gt;.atom\packages&lt;/code&gt;からリンクを削除。(&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/#11-%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E3%82%A2%E3%83%83%E3%83%97%E3%83%87%E3%83%BC%E3%83%88%E3%81%AE%E9%96%8B%E7%99%BA&#34;&gt;以前&lt;/a&gt;、パブリッシュすると&lt;code&gt;.atom\packages&lt;/code&gt;にはパッケージの実ファイルが入ると書いたが、リンクのままだった。勘違い?)&lt;/li&gt;
&lt;li&gt;AtomのSettingsから&lt;code&gt;hoge&lt;/code&gt;をインストール。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;ちゃんとインストールできなかったので&lt;code&gt;apm unpublish hoge&lt;/code&gt;して、バージョンも戻す。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hoge&lt;/code&gt;を修正して、再度&lt;code&gt;0.1.0&lt;/code&gt;としてパブリッシュ。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hoge&lt;/code&gt;をちゃんとインストールできるかを再度確認するために、

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;apm unlink hoge&lt;/code&gt;して、&lt;/li&gt;
&lt;li&gt;AtomのSettingsから&lt;code&gt;hoge&lt;/code&gt;をインストール。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;これをしたら最終的になぜか修正前の&lt;code&gt;hoge&lt;/code&gt;がインストールされた。
どうやらキャッシュがある模様ということで、&lt;a href=&#34;https://github.com/atom/apm/blob/master/src/install.coffee&#34;&gt;apmのソース&lt;/a&gt;をみたら、パッケージのインストール中に以下のようなことをしていることがわかった。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;AtomのサイトのREST API (&lt;a href=&#34;https://www.atom.io/api/packages/hoge/&#34;&gt;https://www.atom.io/api/packages/hoge/&lt;/a&gt;) からパッケージ情報を取得。&lt;/li&gt;
&lt;li&gt;また別のREST API (&lt;a href=&#34;https://www.atom.io/api/packages/hoge/versions/0.1.0/tarball&#34;&gt;https://www.atom.io/api/packages/hoge/versions/0.1.0/tarball&lt;/a&gt;) を実行して、パッケージのアーカイブ(tar.gz)をテンポラリフォルダにダウンロード。
どうもこれは実際にはGitHubの&lt;a href=&#34;https://help.github.com/articles/about-releases/&#34;&gt;Releases&lt;/a&gt;からダウンロードしている模様。
因みにGitHub Releasesのアーカイブは、レポジトリにタグが追加されると自動で作られる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install&lt;/code&gt;でそのアーカイブを指定してインストール。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;この手順の 2 をやる前に、&lt;code&gt;.atom\.apm\hoge\0.1.0\package.tgz&lt;/code&gt;を探して、見つかるとダウンロードせずにこっちをインストールする。
ソースの雰囲気から、&lt;code&gt;.atom\.apm\&lt;/code&gt;に入っているのはキャッシュのようで、いつ作られるかはよくわからないが、これが上記変な現象の原因ぽい。&lt;/p&gt;

&lt;p&gt;ということで、&lt;code&gt;.atom\.apm\hoge\0.1.0\package.tgz&lt;/code&gt;を消して再度インストールしたら無事修正後の&lt;code&gt;hoge&lt;/code&gt;が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;このキャッシュの件や、&lt;code&gt;apm unpublish&lt;/code&gt;がパッケージのバージョンを戻さないところをみると、同じバージョンを再度パブリッシュするのはダメな操作なのかもしれない。
修正したかったらバージョンを上げろということなのかも。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ありがとうさようならjapanese-wrap</title>
          <link>http://tbd.kaitoy.xyz/2015/11/16/thanks-bye-bye-japanese-wrap/</link>
          <pubDate>Mon, 16 Nov 2015 22:38:11 MST</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/11/16/thanks-bye-bye-japanese-wrap/</guid>
          <description>&lt;p&gt;テキストエディタ&lt;a href=&#34;https://atom.io/&#34;&gt;Atom&lt;/a&gt;のとある有名なパッケージの話。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/&#34;&gt;以前の記事&lt;/a&gt;でも触れた&lt;a href=&#34;https://github.com/raccy/japanese-wrap&#34;&gt;japanese-wrap&lt;/a&gt;。
日本語が画面の端でうまく改行(softwrap)してくれない問題を解決してくれるパッケージ。
Atomで日本語を書く殆どの人がインストールしているであろうパッケージだが、先日11/12にリリースされた&lt;a href=&#34;http://blog.atom.io/2015/11/12/atom-1-2.html&#34;&gt;Atom 1.2&lt;/a&gt;で&lt;a href=&#34;https://ja.wikipedia.org/wiki/CJK%E7%B5%B1%E5%90%88%E6%BC%A2%E5%AD%97&#34;&gt;CJK文字&lt;/a&gt; (中国語・日本語・朝鮮語・ベトナム語の文字)のsoftwrapへの対応が実装されたので、もはや不要になった。&lt;/p&gt;

&lt;p&gt;むしろ、Atom 1.2でjapanese-wrapを有効にすると、以下のように残念なことになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/thanks-bye-bye-japanese-wrap/w-japanese-wrap.jpg&#34; alt=&#34;project tree&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;japanese-wrapにはずっとお世話になってきたので申し訳なく名残惜しくもあるが、AtomのSettingsからDisableまたはUninstallさせてもらうしかあるまい。すると以下の様に直る。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/thanks-bye-bye-japanese-wrap/wo-japanese-wrap.jpg&#34; alt=&#34;project tree&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ありがとうさようならjapanese-wrap。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>AtomにおけるGIF画像のキャッシュ</title>
          <link>http://tbd.kaitoy.xyz/2015/09/07/caching-gifs-on-atom/</link>
          <pubDate>Mon, 07 Sep 2015 20:10:31 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/09/07/caching-gifs-on-atom/</guid>
          <description>

&lt;p&gt;以前、&lt;a href=&#34;https://atom.io/packages/disturb-me&#34;&gt;&lt;strong&gt;disturb-me&lt;/strong&gt;&lt;/a&gt;という&lt;a href=&#34;https://atom.io/&#34;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;/a&gt;パッケージを作ったという&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/09/06/disturb-me/&#34;&gt;エントリ&lt;/a&gt;を書いた。
このエントリでは、disturb-meに見つけたバグの修正のなかで、AtomがGIF画像をキャッシュする問題に対応したという話を書く。&lt;/p&gt;

&lt;h2 id=&#34;disturb-meのバグ&#34;&gt;disturb-meのバグ&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/09/06/disturb-me/#6-%E3%83%AA%E3%83%AA%E3%83%BC%E3%82%B9%E3%81%AA%E3%81%A9&#34;&gt;以前のエントリの最後&lt;/a&gt;にも書いた通り、disturb-me 1.0.0には、ループしないGIFアニメーション画像を設定で指定した場合、そのアニメーションが画像の初回表示時にしか再生されないというバグがある。&lt;/p&gt;

&lt;p&gt;disturb-meは、&lt;code&gt;Ctrl+Alt+d Ctrl+Alt+m&lt;/code&gt;と入力すると画像を表示し、もう一度それを入力すると画像を消す。
デフォルトで表示する画像はAtomのロゴで、表示を始める時と消す時にGIF画像でループしないアニメーションを再生する。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/kaitoy/disturb-me/raw/master/assets/disturb-me-demo.gif&#34; alt=&#34;screenshot&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;このデフォルトの状態で、一度Atomロゴを表示して消して、再度表示して消すと、消すときのアニメーションが再生されない。(表示を始める時のアニメーションはなぜか再生される。)&lt;/p&gt;

&lt;h2 id=&#34;バグの原因&#34;&gt;バグの原因&lt;/h2&gt;

&lt;p&gt;disturb-meは、&lt;code&gt;img&lt;/code&gt;タグをAtomウィンドウ内に追加した後、その&lt;code&gt;src&lt;/code&gt;属性に画像へのパスをセットして画像を表示させるが、どうもAtom(のChromium)が画像をキャッシュしてくれるせいで、一度表示し終わったGIFアニメーションは二度と再生されない模様。
なぜ表示開始時のアニメーションが再生されるかは不明。&lt;/p&gt;

&lt;h2 id=&#34;バグ修正&#34;&gt;バグ修正&lt;/h2&gt;

&lt;p&gt;外部リソースをロードするときにブラウザによるキャッシュを回避するには、URLにランダムな値をもつクエリストリングを付けるのが常套手段。&lt;/p&gt;

&lt;p&gt;今回のバグも、&lt;code&gt;src&lt;/code&gt;にセットするGIF画像のパス(URL)にそのようなクエリストリングをつければよい。
例えば、&lt;strong&gt;C:\images\hoge.gif&lt;/strong&gt;を表示したいなら、&lt;code&gt;&amp;lt;img src=&amp;quot;C:\images\hoge.gif?time=1441559906660&amp;quot;&amp;gt;&amp;lt;img&amp;gt;&lt;/code&gt;という風にする。
ここでtimeの値には&lt;code&gt;Date.now()&lt;/code&gt;とかで毎回違う値を生成して使う。&lt;/p&gt;

&lt;h2 id=&#34;atomプロトコルの問題&#34;&gt;Atomプロトコルの問題&lt;/h2&gt;

&lt;p&gt;ここで一つ問題が。disturb-meがデフォルトで使うAtomロゴの画像はパッケージに含まれていて、そういうリソースのURLには&lt;a href=&#34;https://atom.io/docs/latest/creating-a-package#bundle-external-resources&#34;&gt;&lt;strong&gt;Atomプロトコル&lt;/strong&gt;&lt;/a&gt;を使うのが普通。
Atomプロトコルを使うと、&lt;code&gt;atom://disturb-me/assets/atom/white/atom_born.gif&lt;/code&gt;みたいに書いて、パッケージ内の相対パスでリソースを指定できる。&lt;/p&gt;

&lt;p&gt;このAtomプロトコルが、今の時点(Atom v1.0.11)でクエリストリングに対応していない。困った。&lt;/p&gt;

&lt;h2 id=&#34;atomプロトコルの問題への対応&#34;&gt;Atomプロトコルの問題への対応&lt;/h2&gt;

&lt;p&gt;いい機会なので、Atomのソースをfork、cloneして、Atomプロトコルを(簡易的に)クエリストリングに対応させ、ビルドして確認し、プルリクエストを送ってみた。これについてはまた別のエントリで書くかもしれない。&lt;/p&gt;

&lt;p&gt;このプルリクエストが取り込まれるまでの暫定対策として、&lt;a href=&#34;https://github.com/atom/atom/blob/master/src/browser/atom-protocol-handler.coffee&#34;&gt;Atomプロトコルハンドラのソース&lt;/a&gt;を見て、AtomプロトコルのURLからリソースのファイルシステム上での絶対パスを導いている部分をdisturb-me内にパクって、&lt;code&gt;src&lt;/code&gt;にセットする値として&lt;code&gt;atom://&lt;/code&gt;を使わないようにした。&lt;/p&gt;

&lt;p&gt;これでちゃんと動いた。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Atomウィンドウ内で画像を動かすパッケージ - disturb-me</title>
          <link>http://tbd.kaitoy.xyz/2015/09/06/disturb-me/</link>
          <pubDate>Sun, 06 Sep 2015 20:18:14 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/09/06/disturb-me/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://atom.io/&#34;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;/a&gt;のパッケージを見ていて、便利なパッケージが沢山あるなぁと思いつつ、真面目なパッケージばかりでもつまらないので、たまには不真面目で役に立たないパッケージがあってもいいかと思って作ったパッケージの話。&lt;/p&gt;

&lt;h2 id=&#34;disturb-me&#34;&gt;disturb-me&lt;/h2&gt;

&lt;p&gt;作ったのは&lt;a href=&#34;https://atom.io/packages/disturb-me&#34;&gt;&lt;strong&gt;disturb-me&lt;/strong&gt;&lt;/a&gt;というパッケージ。
&lt;code&gt;Ctrl+Alt&lt;/code&gt;を押しながら&lt;code&gt;d&lt;/code&gt;と&lt;code&gt;m&lt;/code&gt;を押すとAtomウィンドウ内に画像が表示され、その画像がランダムに動き回り作業の邪魔をするというもの。&lt;/p&gt;

&lt;p&gt;画像はパッケージの設定から指定できる。デフォルトではAtomのロゴ。&lt;/p&gt;

&lt;p&gt;最初は&lt;strong&gt;pac-m●n&lt;/strong&gt;というパッケージ名にして、ゲーム界のミッキーことパ●クマンが動き回るパッケージにしようと思ってたけど、バンダイナムコからダメだと言われてしまった。
この構想はいつか&lt;a href=&#34;https://open.channel.or.jp/user.php&#34;&gt;カタログIPオープン化プロジェクト&lt;/a&gt;を利用して実現しようと思う。&lt;/p&gt;

&lt;h2 id=&#34;disturb-meの作り方&#34;&gt;disturb-meの作り方&lt;/h2&gt;

&lt;p&gt;以前&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/&#34;&gt;別のエントリ&lt;/a&gt;でAtomパッケージの作り方の基本について書いたので、ここではそこで書かなかったことを書く。&lt;/p&gt;

&lt;h4 id=&#34;1-メインスクリプト-コマンド&#34;&gt;1. メインスクリプト - コマンド&lt;/h4&gt;

&lt;p&gt;今回はコマンドを追加するので&lt;a href=&#34;https://atom.io/docs/api/latest/CommandRegistry&#34;&gt;&lt;strong&gt;CommandRegistry&lt;/strong&gt;&lt;/a&gt;を使う。
CommandRegistryのインスタンスには&lt;strong&gt;atom.commands&lt;/strong&gt;でアクセスでき、その&lt;strong&gt;add&lt;/strong&gt;メソッドでコマンドを追加できる。&lt;/p&gt;

&lt;p&gt;addメソッドの引数は、第一引数から順に、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;target: コマンドを有効にするDOM要素か、それを示すCSSセレクタ。&lt;/li&gt;
&lt;li&gt;commandName: コマンドパレットに表示するコマンド名。全部小文字で、単語をハイフンでつないで、パッケージ名を先頭につけるのがルール。&lt;/li&gt;
&lt;li&gt;callback(event): コマンドを実行したときに呼ばれるメソッド。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;disturb-meのコマンドはAtomウィンドウ内のどこでも有効にしたいので、第一引数にはAtomウィンドウを表すカスタムタグである&lt;strong&gt;atom-workspace&lt;/strong&gt;を指定する。
コードは以下の感じ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;  activate: (state) -&amp;gt;
    @subscriptions = new CompositeDisposable
    @subscriptions.add atom.commands.add &#39;atom-workspace&#39;, &#39;disturb-me:toggle&#39;: =&amp;gt; @toggle()

  toggle: -&amp;gt;
    # 画像を挿入したり削除したりするコード。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;toggle&lt;/strong&gt;の中では画像を挿入したり削除したりするわけだけど、この処理は、その画像を表す別のクラスにまかせることにする。
のでtoggleは以下のように書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;  @disturber: null

  toggle: -&amp;gt;
    if @disturber?
      @disturber.stop()
      @disturber = null
    else
      @disturber = new Disturber()
      document.body.appendChild(@disturber.getElement())
      @disturber.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Disturber&lt;/strong&gt;が画像を表すクラス。別のファイル(&lt;strong&gt;lib/disturber.coffee&lt;/strong&gt;)の中で定義して、スクリプトの先頭辺りで&lt;code&gt;Disturber = require &#39;./disturber&#39;&lt;/code&gt;のようにインポートする。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;document.body.appendChild&lt;/strong&gt;しているところは、何かAtomのAPI(&lt;a href=&#34;https://atom.io/docs/api/latest/ViewRegistry&#34;&gt;&lt;strong&gt;ViewRegistry&lt;/strong&gt;&lt;/a&gt;とか)を使うべきなのかも。&lt;/p&gt;

&lt;h4 id=&#34;2-disturber&#34;&gt;2. Disturber&lt;/h4&gt;

&lt;p&gt;Disturberは以下のように書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;module.exports =
class Disturber

  element: null

  constructor: -&amp;gt;
    # &amp;lt;img&amp;gt;を作って@elementに入れる。

  destroy: -&amp;gt;
    # @elementをDOMツリーから削除する。

  getElement: -&amp;gt;
    # @element返す。

  start: -&amp;gt;
    # @elementのsrcを設定して、ランダムに動かし始める。

  stop: -&amp;gt;
    # @elementを止める。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あまり取り立てて書くことないな…。&lt;/p&gt;

&lt;p&gt;因みに画像を動かすのには&lt;a href=&#34;https://www.npmjs.com/package/velocity-animate&#34;&gt;&lt;strong&gt;Velocity&lt;/strong&gt;&lt;/a&gt;を使い、DOMの操作とかにちょっと&lt;a href=&#34;https://www.npmjs.com/package/jquery&#34;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt;を使う。&lt;/p&gt;

&lt;h4 id=&#34;3-パッケージ設定&#34;&gt;3. パッケージ設定&lt;/h4&gt;

&lt;p&gt;動かす画像や動かす速度はユーザが設定できるようにする。
設定はメインスクリプトで定義でき、その値には&lt;a href=&#34;https://atom.io/docs/api/latest/Config&#34;&gt;&lt;strong&gt;Config&lt;/strong&gt;&lt;/a&gt;クラスでアクセスできる。&lt;/p&gt;

&lt;p&gt;メインスクリプトでの定義は以下のように書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;module.exports = DisturbMe =
  disturber: null
  subscriptions: null

  config:
    bornImage:
      title: &#39;Born-Image&#39;
      type: &#39;string&#39;
      default: &#39;atom://disturb-me/assets/atom/white/atom_born.gif&#39;
    bornDuration:
      title: &#39;Born-Duration&#39;
      type: &#39;integer&#39;
      default: 2000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;するとパッケージ設定画面が以下のようになる。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/disturb-me/settings.jpg&#34; alt=&#34;settings&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;各設定の定義に最低限必要な属性は&lt;strong&gt;type&lt;/strong&gt;と&lt;strong&gt;default&lt;/strong&gt;。オプショナルなものに&lt;strong&gt;title&lt;/strong&gt;、&lt;strong&gt;description&lt;/strong&gt;などがある。
typeには、&lt;strong&gt;string&lt;/strong&gt;、&lt;strong&gt;integer&lt;/strong&gt;、&lt;strong&gt;number&lt;/strong&gt;、&lt;strong&gt;boolean&lt;/strong&gt;、&lt;strong&gt;array&lt;/strong&gt;、&lt;strong&gt;object&lt;/strong&gt;、&lt;strong&gt;color&lt;/strong&gt;を指定できる。
詳しくは&lt;a href=&#34;https://atom.io/docs/api/latest/Config&#34;&gt;&lt;strong&gt;Config&lt;/strong&gt;&lt;/a&gt;クラスの説明に載ってる。&lt;/p&gt;

&lt;p&gt;Configクラスのインスタンスには&lt;strong&gt;atom.config&lt;/strong&gt;でアクセスでき、上で定義した設定を以下のように操作できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;imagePath = atom.config.get(&#39;disturb-me.bornImage&#39;)
atom.config.set(&#39;disturb-me.bornDuration&#39;, &#39;1000&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-キーバインディング&#34;&gt;4. キーバインディング&lt;/h4&gt;

&lt;p&gt;メインスクリプト内でコマンドパレットに表示するコマンドを定義したが、これにキーボードショートカット(キーバインディング)を設定する。&lt;/p&gt;

&lt;p&gt;キーバインディングは&lt;strong&gt;keymaps&lt;/strong&gt;フォルダの中の&lt;strong&gt;cson&lt;/strong&gt;ファイルで以下のように定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cson&#34;&gt;&#39;atom-workspace&#39;:
  &#39;ctrl-alt-d ctrl-alt-m&#39;: &#39;disturb-me:toggle&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これ見ればだいたい書き方はわかるはず。(詳細は&lt;a href=&#34;https://atom.io/docs/latest/behind-atom-keymaps-in-depth&#34;&gt;Atom Flight Manual&lt;/a&gt;に。)&lt;/p&gt;

&lt;p&gt;特殊キーは&lt;strong&gt;cmd&lt;/strong&gt;、&lt;strong&gt;ctrl&lt;/strong&gt;、&lt;strong&gt;alt&lt;/strong&gt;、&lt;strong&gt;shift&lt;/strong&gt;、&lt;strong&gt;enter&lt;/strong&gt;、&lt;strong&gt;escape&lt;/strong&gt;、&lt;strong&gt;backspace&lt;/strong&gt;、&lt;strong&gt;delete&lt;/strong&gt;、&lt;strong&gt;tab&lt;/strong&gt;、&lt;strong&gt;home&lt;/strong&gt;、&lt;strong&gt;end&lt;/strong&gt;、&lt;strong&gt;pageup&lt;/strong&gt;、&lt;strong&gt;pagedown&lt;/strong&gt;、&lt;strong&gt;left&lt;/strong&gt;、&lt;strong&gt;right&lt;/strong&gt;、&lt;strong&gt;up&lt;/strong&gt;、&lt;strong&gt;down&lt;/strong&gt;が使える。&lt;/p&gt;

&lt;p&gt;同時に押すキーはハイフンでつなぎ、連続して押すキーはスペースで区切るので、上記&lt;code&gt;ctrl-alt-d ctrl-alt-m&lt;/code&gt;は、&lt;code&gt;Ctrl+Alt&lt;/code&gt;を押しながら&lt;code&gt;d&lt;/code&gt;と&lt;code&gt;m&lt;/code&gt;を連続して押す、という意味。&lt;/p&gt;

&lt;h4 id=&#34;5-package-json&#34;&gt;5. package.json&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/#5-package-json%E7%B7%A8%E9%9B%86&#34;&gt;前回&lt;/a&gt;と同様の編集に加えて、今回は二つのnpmパッケージに依存するので、&lt;strong&gt;dependencies&lt;/strong&gt;を以下のように書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;velocity-animate&amp;quot;: &amp;quot;&amp;gt;=1.2.0&amp;quot;,
    &amp;quot;jquery&amp;quot;: &amp;quot;&amp;gt;=2.0.0&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを書いて、プロジェクトルートフォルダで&lt;code&gt;apm install&lt;/code&gt;すると、ルート直下の&lt;strong&gt;node_modules&lt;/strong&gt;フォルダに依存モジュールがインストールされる。&lt;/p&gt;

&lt;p&gt;node_modulesは&lt;strong&gt;Package Generator&lt;/strong&gt;が生成する&lt;strong&gt;.gitignore&lt;/strong&gt;に入っているので、レポジトリには入らない。&lt;/p&gt;

&lt;h4 id=&#34;6-リリースなど&#34;&gt;6. リリースなど&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/&#34;&gt;前回&lt;/a&gt;と同様にリリースする。
めんどいのでテストは書かない。&lt;/p&gt;

&lt;p&gt;リリース後、ループしないgifアニメーション画像をdisturb-meに使った場合、そのアニメーションが再生されない場合があるバグに気付いた。
これについては&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/09/07/caching-gifs-on-atom/&#34;&gt;別のエントリ&lt;/a&gt;で書いた。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Atomパッケージを作る - ワード境界を日本語対応させるパッケージ: japanese-word-selection</title>
          <link>http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/</link>
          <pubDate>Fri, 21 Aug 2015 15:31:41 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/08/21/japanese-word-selection/</guid>
          <description>

&lt;p&gt;このブログは&lt;a href=&#34;https://atom.io/&#34;&gt;&lt;strong&gt;Atom&lt;/strong&gt;&lt;/a&gt;というGitHubが開発したテキストエディタを使って書いている。
このエントリは、そのAtomのパッケージを作ってみたというお話。&lt;/p&gt;

&lt;h2 id=&#34;atomとは&#34;&gt;Atomとは&lt;/h2&gt;

&lt;p&gt;Atomは、2015/6/25にバージョン1.0がリリースされたばかりの新しいテキストエディタで、そのせいもあってか日本語サポートはあまり充実していない。
例えば、テキストを画面の端で折り返す「Soft Wrap」という機能はマルチバイト文字に対応しておらず、日本語で横に長い文を書いたりすると画面からはみ出てしまって不便。&lt;/p&gt;

&lt;p&gt;しかしAtomは、パッケージなる、機能を拡張できるプラグインみたいな仕組みを持っていて、例えば上記Soft Wrapの問題は&lt;a href=&#34;https://github.com/raccy/japanese-wrap&#34;&gt;&lt;strong&gt;japanese-wrap&lt;/strong&gt;&lt;/a&gt;というパッケージをインストールすることで解決できる。
パッケージは誰でも作って配布することができる。&lt;/p&gt;

&lt;h2 id=&#34;日本語のワード境界&#34;&gt;日本語のワード境界&lt;/h2&gt;

&lt;p&gt;Atomでブログを書いていて不満を感じたのは、日本語のワード境界をちゃんと判定してくれないところ。&lt;/p&gt;

&lt;p&gt;以前は(今もたまに)&lt;a href=&#34;http://sakura-editor.sourceforge.net/&#34;&gt;&lt;strong&gt;サクラエディタ&lt;/strong&gt;&lt;/a&gt;という和製テキストエディタを使っていて、日本語文の中の一語をダブルクリックで選択するという操作をよくやっていた。
例えば、「Atomのパッケージは便利」という文があったら、「パッケージ」の辺りをダブルクリックすると「パッケージ」という単語を選択できる。&lt;/p&gt;

&lt;p&gt;Atomでも癖でこの操作をすると、妙に広い範囲が選択されてしまう。
上記例だと「Atomのパッケージは便利」全体が選択されてしまう。不便。&lt;/p&gt;

&lt;h2 id=&#34;japanese-word-selection&#34;&gt;japanese-word-selection&lt;/h2&gt;

&lt;p&gt;この問題を解決してくれそうなパッケージを探したけど見つからなかったので、いい機会と思い自分で作ったのが&lt;a href=&#34;https://atom.io/packages/japanese-word-selection&#34;&gt;&lt;strong&gt;japanese-word-selection&lt;/strong&gt;&lt;/a&gt;。ソースは&lt;a href=&#34;https://github.com/kaitoy/japanese-word-selection&#34;&gt;GitHub&lt;/a&gt;に。&lt;/p&gt;

&lt;p&gt;インストールして有効にすると、日本語のワード境界を判定するようになる。実のところ、とりあえずは文字種の境目を見ているだけ。ひらがな、カタカナ、半角カタカナ、漢字に対応。
特殊文字の全角版の処理どうするとか、あまり深く考えて作ってないけど、使ってて変な挙動を見つけたらおいおい直すということで。&lt;/p&gt;

&lt;p&gt;とりあえず、&lt;strong&gt;Edit &amp;gt; Text&lt;/strong&gt; の &lt;strong&gt;Delete to Previous Word Boundary&lt;/strong&gt; と &lt;strong&gt;Delete to Next Word Boundary&lt;/strong&gt; がちゃんと動かないのは見つけた。パッケージで上書きした処理を通っていない気がする。けど、デフォルトでキーバインディングもないし、あまり使われなそうな機能なのでほっておく。&lt;/p&gt;

&lt;h2 id=&#34;atomのパッケージの作り方&#34;&gt;Atomのパッケージの作り方&lt;/h2&gt;

&lt;p&gt;パッケージの作り方は、&lt;a href=&#34;https://atom.io/docs/latest/&#34;&gt;&lt;strong&gt;Atom Flight Manual&lt;/strong&gt;&lt;/a&gt;の&lt;a href=&#34;https://atom.io/docs/latest/hacking-atom-package-word-count&#34;&gt;このあたり&lt;/a&gt;を参考に。
Atom Flight ManualにはAtomの使い方からパッケージの作り方まで体系的に纏められているので一度は通して読みたい。&lt;/p&gt;

&lt;p&gt;パッケージ開発にあたって、前提として知っておくべきは、Atomは&lt;a href=&#34;http://electron.atom.io/&#34;&gt;&lt;strong&gt;Electron&lt;/strong&gt;&lt;/a&gt;という実行環境の上で動いているということ。
(Atomが先で、そこからElectronがスピンオフした。)&lt;/p&gt;

&lt;p&gt;Electronはざっくり&lt;a href=&#34;https://nodejs.org/&#34;&gt;&lt;strong&gt;Node&lt;/strong&gt;&lt;/a&gt;と&lt;a href=&#34;https://www.chromium.org/Home&#34;&gt;&lt;strong&gt;Chromium&lt;/strong&gt;&lt;/a&gt;(Google ChromeのOSS版)でできていて、その上で動くアプリケーションは、HTMLとCSSで書いた画面をChromiumで表示して、それをNodeで動かすJavaScriptで制御する、という形で実装される。AtomはJavaScriptの代わりに、より高級な&lt;a href=&#34;http://coffeescript.org/&#34;&gt;&lt;strong&gt;CoffeeScript&lt;/strong&gt;&lt;/a&gt;を使っているので、パッケージを作る際はCoffeeScriptのコードをがりがり書くことになる。&lt;/p&gt;

&lt;p&gt;パッケージは&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;のパッケージっぽく書く。&lt;/p&gt;

&lt;p&gt;Atomは&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVM&lt;/a&gt;な感じの設計になっていて、コアのViewModelとかをパッケージからいじることでいろんな機能を実現できる。&lt;/p&gt;

&lt;p&gt;以下、備忘録として、japanese-word-selectionを作った時にやったことを書いておく。Atomのバージョンは1.0.7。&lt;/p&gt;

&lt;h4 id=&#34;1-パッケージテンプレート生成&#34;&gt;1. パッケージテンプレート生成&lt;/h4&gt;

&lt;p&gt;Atomを起動して、&lt;code&gt;Ctrl+Shift+P&lt;/code&gt;でコマンドパレットを開いて、&lt;code&gt;generate package&lt;/code&gt;と入力してEnter。
&lt;strong&gt;Package Generator&lt;/strong&gt;が起動して、作成するパッケージの名前を聞かれるのでjapanese-word-selectionを入力。(因みに、パッケージ名に&lt;strong&gt;atom-&lt;/strong&gt;というプレフィックスを付けているのをたまに見るが、これは推奨されていない。)
するとパッケージのテンプレートが作成され、それを読み込んだAtomウィンドウが開く(下図)。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/japanese-word-selection/project_tree.jpg&#34; alt=&#34;project tree&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;パッケージ構成については概ね以下の感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;keymaps: キーバインディングを定義する&lt;a href=&#34;https://github.com/bevry/cson&#34;&gt;cson&lt;/a&gt;ファイルをいれる。&lt;/li&gt;
&lt;li&gt;lib: パッケージの機能を実装するCoffeeスクリプトを入れる。

&lt;ul&gt;
&lt;li&gt;デフォルトで「&lt;strong&gt;パッケージ名.coffee&lt;/strong&gt;」がメインスクリプト。&lt;/li&gt;
&lt;li&gt;Package Generatorが作る「&lt;strong&gt;パッケージ名-view.coffee&lt;/strong&gt;」というスクリプトは、Atomの画面に新たなペインを追加したいときとかに書くコードのサンプル。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;menus: ツールバーとかコンテクストメニューに追加するメニューを定義するcsonファイルを入れる。&lt;/li&gt;
&lt;li&gt;spec: パッケージのテストを入れる。テストは&lt;a href=&#34;jasmine.github.io/&#34;&gt;Jasmine&lt;/a&gt;を使って書く。&lt;/li&gt;
&lt;li&gt;styles: パッケージが追加するペインとかに独自のスタイルを指定したいときとかに&lt;a href=&#34;http://less-ja.studiomohawk.com/&#34;&gt;Less&lt;/a&gt;かCSSを入れる。&lt;/li&gt;
&lt;li&gt;package.json: パッケージの名前とか依存関係とかを定義するファイル。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;japanese-word-selectionはメニューもコマンドもペインも追加しないので、keymaps、lib/japanese-word-selection-view.coffee、menus、spec/japanese-word-selection-view-spec.coffee、stylesは消す。&lt;/p&gt;

&lt;p&gt;以下、ここで生成したパッケージフォルダを&lt;strong&gt;&amp;lt;パッケージルート&amp;gt;&lt;/strong&gt;と書く。&lt;/p&gt;

&lt;h4 id=&#34;2-メインスクリプト編集-概要&#34;&gt;2. メインスクリプト編集 - 概要&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&amp;lt;パッケージルート&amp;gt;/lib/japanese-word-selection.coffee&lt;/strong&gt;を編集して機能を実装する。
Package Generatorがサンプルコードを書いてくれているので、それを書き変えて行けばよい。&lt;/p&gt;

&lt;p&gt;機能は特定のAPIをもったオブジェクトに実装して、それを &lt;strong&gt;module.exports&lt;/strong&gt; に代入する。
今回は &lt;strong&gt;JapaneseWordSelection&lt;/strong&gt; がそのオブジェクト。「特定のAPI」というのは以下のメソッド。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;activate(state): パッケージが有効化されるときに呼ばれる。&lt;/li&gt;
&lt;li&gt;deactivate(): パッケージが無効化されるときに呼ばれる。無くてもいい。&lt;/li&gt;
&lt;li&gt;serialize(): Atomウィンドウを閉じるときに、パッケージの状態を保存したいときに実装するメソッド。無くてもいい。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JapaneseWordSelectionには、activateとdeactivateを実装して、前者の中でワード境界判定処理をいじり、後者の中で元に戻すようにする。つまり、japanese-word-selection.coffeeはだいたい以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;module.exports = JapaneseWordSelection =

  activate: -&amp;gt;
    # ワード境界判定処理を日本語対応させる。

  deactivate: -&amp;gt;
    # ワード境界判定処理を元に戻す。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-メインスクリプト編集-activate&#34;&gt;3. メインスクリプト編集 - activate&lt;/h4&gt;

&lt;p&gt;実際の処理を書く際には、&lt;a href=&#34;https://atom.io/docs/api/latest&#34;&gt;Atom APIのドキュメント&lt;/a&gt;を参照する。また、&lt;a href=&#34;https://github.com/atom/atom&#34;&gt;Atomのソース&lt;/a&gt;を見てAtom APIの実装の詳細を見るべきときもある。&lt;/p&gt;

&lt;p&gt;パッケージのスクリプトからは、Atomクラスのインスタンスである &lt;strong&gt;atom&lt;/strong&gt; というグローバル変数が使えて、これを入り口にAtomウィンドウ内の各要素のViewModelオブジェクトをいじることができる。&lt;/p&gt;

&lt;p&gt;イベントを扱うときには、&lt;a href=&#34;https://atom.io/docs/api/v1.0.7/CompositeDisposable&#34;&gt;CompositeDisposable&lt;/a&gt;が便利。これを使うと、以下のようにして、ViewModelオブジェクトとかに登録したイベントハンドラを後で簡単に削除できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;@disposables = new CompositeDisposable
editor = atom.workspace.getActiveTextEditor()
@disposables.add editor.onDidChange -&amp;gt;  # editorにイベントハンドラを登録。
@disposables.add editor.onDidChangePath -&amp;gt;  # editorに別のイベントハンドラを登録。

(snip)

@disposables.dispose()  # 全てのイベントハンドラを削除。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JapaneseWordSelection#activate()では、&lt;a href=&#34;https://atom.io/docs/api/v1.0.7/Workspace#instance-observeTextEditors&#34;&gt;atom.workspace.observeTextEditors(callback)&lt;/a&gt;というAPIを利用して&lt;a href=&#34;https://atom.io/docs/api/v1.0.7/TextEditor&#34;&gt;TextEditor&lt;/a&gt;オブジェクトを取得して、それが持っている&lt;a href=&#34;https://atom.io/docs/api/v1.0.7/Cursor&#34;&gt;Cursor&lt;/a&gt;オブジェクトの振る舞いを変更する。
この、observeXXXXというAPIは他にもいろいろあって、実行すると既存の全てのXXXXのインスタンスをcallbackに渡してくれて、さらに、それ以降XXXXのインスタンスが作られるたびにcallbackを呼び出すイベントハンドラを登録してくれる。&lt;/p&gt;

&lt;p&gt;このobserveXXXXとかに上記CompositeDisposableが使えて、observeXXXXの場合、その戻り値をCompositeDisposableにaddしておくと、後でCompositeDisposable#dispose()でイベントハンドラを削除できる。&lt;/p&gt;

&lt;p&gt;まとめると、JapaneseWordSelection#activate()は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;module.exports = JapaneseWordSelection =

  disposables: null

  activate: -&amp;gt;
    @disposables = new CompositeDisposable
    @disposables.add atom.workspace.observeTextEditors (editor) -&amp;gt;
      JapaneseWordSelection.japanizeWordBoundary(editor, cursor) for cursor in editor.getCursors()

  japanizeWordBoundary: (editor, cursor) -&amp;gt;
    # Cursorオブジェクトの振る舞いを変更する処理
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(今見ると、Cursorの方もobserveした方がいいか。後で直そう。)&lt;/p&gt;

&lt;h4 id=&#34;4-メインスクリプト編集-deactivate&#34;&gt;4. メインスクリプト編集 - deactivate&lt;/h4&gt;

&lt;p&gt;JapaneseWordSelection#deactivate()は、追加したイベントハンドラを削除して、全てのCursorオブジェクトの振る舞いを元に戻すだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-coffeescript&#34;&gt;  deactivate: -&amp;gt;
    @disposables.dispose()
    for i, editor of atom.workspace.getTextEditors()
      for j, cursor of editor.getCursors()
        # Cursorオブジェクトの振る舞いを元に戻す処理
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-package-json編集&#34;&gt;5. package.json編集&lt;/h4&gt;

&lt;p&gt;package.jsonは、Package Generatorが以下のようなひな形を作ってくれている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;japanese-word-selection&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./lib/japanese-word-selection&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;A short description of your package&amp;quot;,
  &amp;quot;keywords&amp;quot;: [
  ],
  &amp;quot;activationCommands&amp;quot;: {
    &amp;quot;atom-workspace&amp;quot;: &amp;quot;japanese-word-selection:toggle&amp;quot;
  },
  &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/atom/japanese-word-selection&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;engines&amp;quot;: {
    &amp;quot;atom&amp;quot;: &amp;quot;&amp;gt;=1.0.0 &amp;lt;2.0.0&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これに以下の編集を加える。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;description&lt;/strong&gt; にパッケージの説明を書く。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;keywords&lt;/strong&gt; にパッケージレポジトリ内での検索のためのタグを書く。&lt;/li&gt;
&lt;li&gt;japanese-word-selectionはとりあえずコマンドを作らないので、&lt;strong&gt;activationCommands&lt;/strong&gt; は消す。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;repository&lt;/strong&gt; にjapanese-word-selectionのソースを置く(予定の)GitHubレポジトリのアドレスを書く。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これだけ。以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;japanese-word-selection&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;./lib/japanese-word-selection&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Japanize word boundary.&amp;quot;,
  &amp;quot;keywords&amp;quot;: [
    &amp;quot;japanese&amp;quot;,
    &amp;quot;selection&amp;quot;,
    &amp;quot;word&amp;quot;
  ],
  &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/kaitoy/japanese-word-selection&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  &amp;quot;engines&amp;quot;: {
    &amp;quot;atom&amp;quot;: &amp;quot;&amp;gt;=1.0.0 &amp;lt;2.0.0&amp;quot;
  },
  &amp;quot;dependencies&amp;quot;: {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;version&lt;/strong&gt; はパッケージリリース(パブリッシュ)時に自動でインクリメントされるので、0.0.0のままほっておく。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dependencies&lt;/strong&gt; には依存するnpmパッケージを定義できるが、japanese-word-selectionは一人で動くので何も書かない。
因みに、dependenciesに何か追加したら、package.jsonがあるフォルダで&lt;code&gt;apm install&lt;/code&gt;というコマンドを実行すると、そのフォルダの下に&lt;strong&gt;node_modules&lt;/strong&gt;というフォルダができて、そこに依存がインストールされる。&lt;/p&gt;

&lt;p&gt;このpackage.jsonは&lt;a href=&#34;https://docs.npmjs.com/files/package.json&#34;&gt;npmのpackage.json&lt;/a&gt;を拡張したもので、npmのpackage.jsonのプロパティは全部使える。&lt;/p&gt;

&lt;h4 id=&#34;6-動作確認&#34;&gt;6. 動作確認&lt;/h4&gt;

&lt;p&gt;作成したパッケージは、Package Generatorに生成された時点でAtomから使えるようになっている。
ソースを変更したら、&lt;code&gt;Ctrl+Alt+r&lt;/code&gt;でウィンドウをリロードして反映して動作確認できる。&lt;/p&gt;

&lt;p&gt;ログを見たい時など、&lt;code&gt;Ctrl+Atl+i&lt;/code&gt;でディベロッパツールを開いておくと便利。&lt;/p&gt;

&lt;h4 id=&#34;7-テスト&#34;&gt;7. テスト&lt;/h4&gt;

&lt;p&gt;上記の通り、パッケージのテストはJasmineを使って書いて、&lt;strong&gt;&amp;lt;パッケージルート&amp;gt;/spec/&lt;/strong&gt;に入れる。テストファイル名の拡張子を除いた部分は&lt;strong&gt;-spec&lt;/strong&gt;というポストフィックスを付けなければいけない。&lt;/p&gt;

&lt;p&gt;テストの書き方については、&lt;a href=&#34;https://atom.io/docs/latest/hacking-atom-writing-specs&#34;&gt;Atomのマニュアル&lt;/a&gt;とか、&lt;a href=&#34;https://github.com/atom/atom/tree/master/spec&#34;&gt;Atomのテスト&lt;/a&gt;とか、Jasmineのマニュアルとかを参照ということで、ここでは割愛する。テスト書くのは必須ではないし。&lt;/p&gt;

&lt;p&gt;テストは&lt;code&gt;Ctrl+Alt+p&lt;/code&gt;で実行できる。&lt;/p&gt;

&lt;h4 id=&#34;8-その他ファイルの編集&#34;&gt;8. その他ファイルの編集&lt;/h4&gt;

&lt;p&gt;README.md、LICENSE.md、CHANGELOG.mdを修正。詳細は割愛。&lt;/p&gt;

&lt;h4 id=&#34;9-githubへ保存&#34;&gt;9. GitHubへ保存&lt;/h4&gt;

&lt;p&gt;GitHubにjapanese-word-selectionという名のレポジトリを作り、そこにソースを保存。詳細は割愛。
Atomのドキュメントによると、今のところ、GitHubへのソース保存は以下のパブリッシュのために必須な模様。&lt;/p&gt;

&lt;h4 id=&#34;10-パブリッシュ&#34;&gt;10. パブリッシュ&lt;/h4&gt;

&lt;p&gt;作ったパッケージをリリースすることを、パブリッシュという。
手順は&lt;a href=&#34;https://atom.io/docs/latest/hacking-atom-package-word-count#publishing&#34;&gt;Atomのドキュメント&lt;/a&gt;に説明されている。&lt;/p&gt;

&lt;p&gt;パブリッシュするには、&lt;strong&gt;apm&lt;/strong&gt; という、Atomのパッケージを管理するコマンドラインツールが必要。どうもAtom本体と一緒にインストールされるっぽい。&lt;/p&gt;

&lt;p&gt;やることは、&amp;lt;パッケージルート&amp;gt;に&lt;code&gt;cd&lt;/code&gt;して、&lt;code&gt;apm publish minor&lt;/code&gt;を実行するだけ。
このコマンドは以下の処理をする。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;(初回のみ)パッケージ名をatom.ioに登録する。&lt;/li&gt;
&lt;li&gt;package.jsonのversionをインクリメントしてコミットする。&lt;code&gt;apm publish&lt;/code&gt;にminorを指定するので、0.1.0になる。代わりにmajorかpatchを指定すると、1.0.0か0.0.1になる。&lt;/li&gt;
&lt;li&gt;Gitのタグを作る。&lt;/li&gt;
&lt;li&gt;GitHubに変更とタグをpushする。&lt;/li&gt;
&lt;li&gt;atom.ioにパッケージを登録する。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;私の場合、初回だったので、コマンド実行中にatom.ioのアカウントを作ってAPIトークンを取得する手順があった。
以下がコマンドのメッセージ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# cd japanese-word-selection
# apm publish minor
Welcome to Atom!

Before you can publish packages, you&#39;ll need an API token.

Visit your account page on Atom.io https://atom.io/account,
copy the token and paste it below when prompted.

Press [Enter] to open your account page on Atom.io.
Token&amp;gt; hogeeeeeeeeeeeeeeeee
Saving token to Keychain done
Registering japanese-word-selection done
Preparing and tagging a new version done
Pushing v0.1.0 tag done
Publishing japanese-word-selection@v0.1.0 done
Congrats on publishing a new package!
Check it out at https://atom.io/packages/japanese-word-selection
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://atom.io/packages/japanese-word-selection&#34;&gt;https://atom.io/packages/japanese-word-selection&lt;/a&gt; に行ったらちゃんとjapanese-word-selectionのページができていた。
これでパブリッシュまで完了。&lt;/p&gt;

&lt;p&gt;因みに、&lt;code&gt;apm unpublish パッケージ名@バージョン&lt;/code&gt;で&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/12/02/unpublish-atom-package/&#34;&gt;パブリッシュを取り消す&lt;/a&gt;ことができる。&lt;/p&gt;

&lt;h4 id=&#34;11-パッケージのアップデートの開発&#34;&gt;11. パッケージのアップデートの開発&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;apm publish&lt;/code&gt;をすると、パブリッシュしたバージョンがインストールされた状態になる。
具体的には、&lt;code&gt;%userprofile%\.atom\packages\&lt;/code&gt;にそのパッケージが入っている状態になる。&lt;/p&gt;

&lt;p&gt;パッケージのアップデートを開発する際は、修正している版のパッケージ(&amp;lt;パッケージルート&amp;gt;に入っている方)を優先してロードして欲しくなるが、そのためには&lt;code&gt;%userprofile%\.atom\dev\packages\&lt;/code&gt;に修正版(のリンク)をいれて、Atomをdev modeで起動する必要がある。&lt;/p&gt;

&lt;p&gt;この手順は、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;lt;パッケージルート&amp;gt;に&lt;code&gt;cd&lt;/code&gt;して、&lt;code&gt;apm link --dev&lt;/code&gt;を実行する。これでそのフォルダへのリンクが&lt;code&gt;.atom\dev\packages\&lt;/code&gt;に作成される。&lt;/li&gt;
&lt;li&gt;Atomのメニューの &lt;strong&gt;View &amp;gt; Developer &amp;gt; Open In Dev Mode&lt;/strong&gt; からdev modeのAtomウィンドウを開く。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因みに、Package Generatorは、作成したパッケージフォルダへのリンクを&lt;code&gt;.atom\packages\&lt;/code&gt;に作成する。リンクの一覧は&lt;code&gt;apm links&lt;/code&gt;で参照でき、&lt;code&gt;apm unlink&lt;/code&gt;で削除できる。&lt;/p&gt;

&lt;h2 id=&#34;関連エントリ&#34;&gt;関連エントリ&lt;/h2&gt;

&lt;p&gt;後日もう一つパッケージを作り、&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/09/06/disturb-me/&#34;&gt;それに関する記事&lt;/a&gt;を書いた。
こちらはjapanese-word-selectionでやらなかったコマンドなどの実装をやっている。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
