<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>http://tbd.kaitoy.xyz/tags/oop/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2016</rights>
    <updated>2015-10-28 13:38:47 -0600 MDT</updated>

    
      
        <item>
          <title>よいオブジェクトの七つの美徳</title>
          <link>http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/</link>
          <pubDate>Wed, 28 Oct 2015 13:38:47 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;Seven Virtues of a Good Object&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Martin Fowler&lt;a href=&#34;http://martinfowler.com/bliki/InversionOfControl.html&#34;&gt;曰く&lt;/a&gt;、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ライブラリは本質的には呼び出し可能な関数の集合で、最近は普通クラス内にまとめられる。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;クラス内にまとめられた関数?
失礼を承知で言わせてもらうが、これは間違っている。
そして、これはオブジェクト指向プログラミングにおいて、クラスに対する非常に一般的な誤解だ。
クラスは関数をまとめるものではないし、オブジェクトはデータ構造体ではない。&lt;/p&gt;

&lt;p&gt;では、なにが適切なオブジェクトなのか?
どれが不適切なオブジェクトなのか?
その違いは何か?
これは論争を呼ぶ主題ではあるが、とても重要だ。
オブジェクトが何かを理解しなければ、オブジェクト指向ソフトウェアをどうやって書くんだ?
まあ、JavaやRubyなどのおかげで、書けることは書ける。
しかし、はたして良いものができるだろうか?
不幸にも、これは厳密な科学ではなく、様々な意見がある。
ここに、良いオブジェクトの特性を私なりにリストアップする。&lt;/p&gt;

&lt;h1 id=&#34;クラス-vs-オブジェクト&#34;&gt;クラス vs オブジェクト&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-1.png&#34; src=&#34;http://tbd.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-1.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトについて議論を始める前に、クラスとは何かを定義しよう。
それはオブジェクトが生まれる(インスタント化される)場所だ。
クラスの主な責任は、要求に応じて新しいオブジェクトを構築し、使われなくなったオブジェクトを破壊することだ。
クラスはその子供たちがどのように見えどのように振る舞うべきかを知っている。
言い換えれば、子供たちが従うべき契約を知っている。&lt;/p&gt;

&lt;p&gt;クラスが「オブジェクトのテンプレート」であると言われることもある。(例えば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9_%28%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%29&#34;&gt;Wikipediaにはそう書いてある&lt;/a&gt;。)
この定義はクラスを受動的なポジションに置いているので正しくない。
この定義は、だれかがテンプレートを取得してそこからオブジェクトを構築するということを想定している。
これは、技術的には正しいかもしれないが、概念的には間違っている。
クラスとその子供たちだけが居るのであって、他の誰も関係すべきではない。
あるオブジェクトがクラスに他のオブジェクトを作るように頼み、そのクラスがオブジェクトを構築する。それだけだ。
RubyはJavaやC++に比べてこの概念をかなりうまく表現している。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;photo = File.new(&#39;/tmp/photo.png&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;photo&lt;/code&gt;オブジェクトは&lt;code&gt;File&lt;/code&gt;クラスによって構築される。(&lt;code&gt;new&lt;/code&gt;はそのクラスへのエントリポイント。)
オブジェクトは、いったん構築されると、自身に基づいて行動する。
オブジェクトは、自身を誰が構築したかとか、何人兄弟姉妹がいるかとかを知っているべきではない。
そう、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_%28%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%29&#34;&gt;リフレクション&lt;/a&gt;は酷いアイデアだと言っている。
それについては他の記事で詳しく書くとして、ここでは、オブジェクトについてと、その最高と最悪の両面について話そう。&lt;/p&gt;

&lt;h1 id=&#34;1-彼は実世界に存在している&#34;&gt;1. 彼は実世界に存在している&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-2.png&#34; src=&#34;http://tbd.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-2.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;まず第一に、オブジェクトは生きた有機体だ。
もっと言えば、オブジェクトは&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%93%AC%E4%BA%BA%E5%8C%96&#34;&gt;擬人化&lt;/a&gt;されるべきだ。
つまり、人間(もしくは、君がより好むならペット)のように扱われるべきだ。
基本的にこれは、オブジェクトはデータ構造体や関数の集合ではないということを意味している。
代わりに、オブジェクトは独立したエンティティで、それ自身のライフサイクル、振る舞い、性質を持つ。&lt;/p&gt;

&lt;p&gt;従業員、部署、HTTPリクエスト、MySQLのテーブル、ファイルの行、ファイルそのもの、これらは適切なオブジェクトだ。
なぜならこれらは、ソフトウェアを停止した時でも実世界に存在しているから。
より正確には、オブジェクトは実世界のモノの表現のひとつだ。
オブジェクトは実世界のモノと他のオブジェクトとの間のプロキシだ。
そのようなモノが存在しなければ、明らかにオブジェクトは存在しない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;photo = File.new(&#39;/tmp/photo.png&#39;)
puts photo.width()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この例では、&lt;code&gt;File&lt;/code&gt;に新しいオブジェクト&lt;code&gt;photo&lt;/code&gt;を構築するよう頼んでいる。
&lt;code&gt;photo&lt;/code&gt;はディスク上の実際のファイルの表現となる。
ファイルもまた仮想のもので、コンピュータが起動している間だけ存在すると言う人がいるかもしれない。
それには私も同意し、「実世界」の定義を次のように改善しよう。
オブジェクトが住むプログラムの範囲外に存在する全てのもの。
ディスク上のファイルはプログラムの範囲外にあり、その表現をプログラム内に作成することは完全に正しいことと言える。&lt;/p&gt;

&lt;p&gt;コントローラ、パーサ、フィルタ、バリデータ、サービスロケータ、シングルトン、ファクトリー、これれは良いオブジェクトではない。(そう、ほとんどのGoFパターンはアンチパターンだ!)
これらはソフトウェアの外側、実世界に存在していない。
他のオブジェクト同士を結びつけるためだけに考案されたものだ。
人工的で偽のモノだ。何も表現していない。
真面目な話、XMLパーサ、これが表現するものはなんだ?
何もない。&lt;/p&gt;

&lt;p&gt;上記オブジェクトのいくつかは名前を変えれば良いオブジェクトになる。他のものは決して存在を許されない。
例えば、XMLパーサは「パース可能なXML」と改名でき、プログラム外に存在するXMLドキュメントを表現するようになる。&lt;/p&gt;

&lt;p&gt;常に、「このオブジェクトの背後にある実世界のエンティティは何か?」を自問しよう。
もし回答が見つからなければ、リファクタリングを考えるときだ。&lt;/p&gt;

&lt;h1 id=&#34;2-彼は契約によって働く&#34;&gt;2. 彼は契約によって働く&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-3.png&#34; src=&#34;http://tbd.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-3.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;良いオブジェクトは常に契約によって働く。
彼は、個人的な実力ではなく、契約に従うということを理由に雇われることを期待している。
一方、我々がオブジェクトを雇うとき、差別待遇をして、特定のクラスの特定のオブジェクトが我々のために働いてくれると期待してはいけない。
どんなオブジェクトも契約通りのことをすると考えるべきだ。
オブジェクトが期待通りの働きをしている限りは、彼の出生や性別や信仰に興味を持つべきではない。&lt;/p&gt;

&lt;p&gt;例えば、ある写真をスクリーンに表示したいとする。その写真はPNGフォーマットのファイルから読みこまれる。
私は&lt;code&gt;DataFile&lt;/code&gt;クラスのオブジェクトと契約を結び、その画像のバイナリコンテンツをくれるよう頼む。&lt;/p&gt;

&lt;p&gt;しかし待ってほしい。私はそのデータが厳密にどこから来るかを気にするだろうか?
ディスク上のファイル、HTTPリクエスト、Dropbox上のドキュメントかもしれないが、実際私は気にしない。
私が気にするのは、オブジェクトがPNGデータが入ったバイト配列をくれるということだけだ。
つまり、私が結ぶ契約は以下のようなものだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Binary {
  byte[] read();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、(DataFileクラスだけでなく)どんなクラスのどんなオブジェクトでも私のもとで働くことができる。
オブジェクトが働く資格を得るためにすべきは、&lt;code&gt;Binary&lt;/code&gt;インターフェースを実装することにより、契約に従うということだけだ。&lt;/p&gt;

&lt;p&gt;この際のルールは単純で、良いオブジェクトの全てのpublicメソッドは、インターフェースのものを実装すべきだということだ。
もしオブジェクトがインターフェースから継承していないpublicメソッドを持っていたら、それはダメな設計だ。&lt;/p&gt;

&lt;p&gt;これには実用的な理由が二つある。
第一に、無契約で働いているオブジェクトは、ユニットテストで使うモックが作れない。
第二に、無契約なオブジェクトは&lt;a href=&#34;https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;デコレータ&lt;/a&gt;で拡張できない。&lt;/p&gt;

&lt;h1 id=&#34;3-彼はユニーク&#34;&gt;3. 彼はユニーク&lt;/h1&gt;

&lt;p&gt;良いオブジェクトは常に、ユニークであるために何かを内包しているべきだ。
何も内包していないと、そのオブジェクトとまったく同じクローンが存在し得ることになる。私はこれはダメなことだと考えている。
以下がクローンが存在し得る悪いオブジェクトの例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class HTTPStatus implements Status {
  private URL page = new URL(&amp;quot;http://www.google.com&amp;quot;);
  @Override
  public int read() throws IOException {
    return HttpURLConnection.class.cast(
      this.page.openConnection()
    ).getResponseCode();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HTTPStatus&lt;/code&gt;クラスのインスタンスは複数作れ、それら全ては互いに等しい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;first = new HTTPStatus();
second = new HTTPStatus();
assert first.equals(second);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明らかにユーティリティクラスは、スタティックメソッドだけを持つので、よいオブジェクトにインスタンス化できない。
より一般的には、ユーティリティクラスはこの記事で述べられているどのメリットも持たず、「クラス」と呼ぶことさえできない。
ユーティリティクラスは単純にオブジェクトパラダイムの酷い乱用で、モダンなオブジェクト指向言語の作者がスタティックメソッドを有効にしたせいで存在している。&lt;/p&gt;

&lt;h1 id=&#34;4-彼は不変-immutable&#34;&gt;4. 彼は不変(Immutable)&lt;/h1&gt;

&lt;p&gt;良いオブジェクトは内包する状態を決して変えるべきではない。
オブジェクトは実世界のエンティティの表現であることを思い出してほしい。このエンティティは、オブジェクトが存続する間は変化しないはずだ。
言い換えれば、オブジェクトはそれが表すエンティティに決して背いてはいけない。
オブジェクトがその所有者を変化させることはないよね。&lt;/p&gt;

&lt;p&gt;不変であることが、全てのメソッドが常に同じ値を返すことを意味するわけではないことに注意してほしい。
むしろ、良い不変オブジェクトはとても動的だ。
しかし、それは内部状態を変えることはない。例えば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class HTTPStatus implements Status {
  private URL page;
  public HTTPStatus(URL url) {
    this.page = url;
  }
  @Override
  public int read() throws IOException {
    return HttpURLConnection.class.cast(
      this.page.openConnection()
    ).getResponseCode();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;メソッドは異なる値を返す可能性があるが、このオブジェクトは不変だ。
ある一つのウェブページを指し、他のどこを指すこともない。
内包する状態を決して変えないし、表現しているURLに背くこともない。&lt;/p&gt;

&lt;p&gt;なぜこの不変性が美徳なのか?
次の記事で詳細を説明している: &lt;a href=&#34;http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html&#34;&gt;オブジェクトは不変であるべきだ&lt;/a&gt;。
要するに、不変オブジェクトが優れている理由は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不変オブジェクトは簡単に構築、テスト、使用できる。&lt;/li&gt;
&lt;li&gt;真の不変オブジェクトは常にスレッドセーフ。&lt;/li&gt;
&lt;li&gt;時間的結合(訳注: コードの実行順の暗黙的な制約)を回避するのに役立つ。&lt;/li&gt;
&lt;li&gt;不変オブジェクトを使っても副作用がおきない。(防御的コピー無)&lt;/li&gt;
&lt;li&gt;エラー発生時の原子性が保証されている。&lt;/li&gt;
&lt;li&gt;キャッシュしやすい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/07/26/why-null-is-bad/&#34;&gt;NULL参照&lt;/a&gt;を防ぐ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もちろん、良いオブジェクトは&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/&#34;&gt;setter&lt;/a&gt;をもたない。セッターはオブジェクトの状態を変え得るし、URLに背くことを強要する。
言い換えると、&lt;code&gt;HTTPStatus&lt;/code&gt;で&lt;code&gt;setURL()&lt;/code&gt;メソッドを実装することは酷い間違いとなる。&lt;/p&gt;

&lt;p&gt;その他にも、不変オブジェクトを使うことで、設計は必然的に凝集度の高いものになり、また密で理解しやすいものになる。
これについては&lt;a href=&#34;http://www.yegor256.com/2014/11/07/how-immutability-helps.html&#34;&gt;不変性がどう役に立つか&lt;/a&gt;という記事で説明している。&lt;/p&gt;

&lt;h1 id=&#34;5-彼のクラスはスタティックなものをいっさいもたない&#34;&gt;5. 彼のクラスはスタティックなものをいっさいもたない&lt;/h1&gt;

&lt;p&gt;スタティックメソッドは、オブジェクトではなくクラスの挙動を実装する。
&lt;code&gt;File&lt;/code&gt;クラスがあり、その子供が&lt;code&gt;size()&lt;/code&gt;メソッドを持つとする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class File implements Measurable {
  @Override
  public int size() {
    // calculate the size of the file and return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまではよい。&lt;code&gt;size()&lt;/code&gt;メソッドは&lt;code&gt;Measurable&lt;/code&gt;契約によって存在し、&lt;code&gt;File&lt;/code&gt;クラスの全てのオブジェクトはそのサイズを測ることができる。
このクラスを、代わりにスタティックメソッドを持つように実装するのは酷い間違いだ。
(こうした設計は&lt;a href=&#34;http://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html&#34;&gt;ユーティリティクラス&lt;/a&gt;と呼ばれ、JavaやRubyなどのほぼ全てのOOP言語でとても人気だ。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// TERRIBLE DESIGN, DON&#39;T USE!
class File {
  public static int size(String file) {
    // calculate the size of the file and return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設計はオブジェクト指向パラダイムの真逆を行く。
なぜかって?
なぜならスタティックメソッドはオブジェクト指向プログラミングを「クラス指向」プログラミングに変えてしまうからだ。
この、&lt;code&gt;size()&lt;/code&gt;メソッドは、オブジェクトではなくクラスの挙動を公開する。
これの何が間違っているかと言われるかもしれない。
なぜオブジェクトとクラス両方をコード中で第一級市民として使えないのか?
なぜ両方ともがメソッドやプロパティを持てないのか?&lt;/p&gt;

&lt;p&gt;この問題は、クラス指向プログラミングでは、分離ができなくなるというものだ。
複雑な問題をブレイクダウンできなくなる。
なぜなら、プログラム全体の中でクラスのインスタンスがたったひとつしか存在しないからだ。
OOPの力は、オブジェクトをスコープを分離するための道具として使えることだ。
あるオブジェクトをメソッド中でインスタンス化したとき、そのオブジェクトは特定のタスク専任となる。
そのオブジェクトは、メソッド周辺の他のオブジェクトから完璧に分離されている。
このオブジェクトはメソッドスコープのローカル変数だ。
スタティックメソッドを持つクラスは、どこで使うにしろ常にグローバル変数だ。
このため、この変数とのやりとりを分離することはできない。&lt;/p&gt;

&lt;p&gt;オブジェクト指向の原理に概念的に反しているということの他にも、パブリックなスタティックメソッドは実用的な欠点も持っている。&lt;/p&gt;

&lt;p&gt;第一に、モックを作れない。
(いや、&lt;a href=&#34;https://code.google.com/p/powermock/&#34;&gt;PowerMock&lt;/a&gt;を使うことはできる。が、これはJavaプロジェクトで取り得る決断の中で最悪なものとなるだろう。。。私はそれを数年前にやってしまった。)&lt;/p&gt;

&lt;p&gt;第二に、定義上スレッドセーフではない。なぜなら、常にスタティック変数とともに動くからで、スタティック変数は全てのスレッドからアクセスできるからだ。
スタティックメソッドをスレッドセーフに作ることもできるが、この場合常に明示的な同期が必要になる。&lt;/p&gt;

&lt;p&gt;パブリックなスタティックメソッドを見つけたら常に、即座に書き直すべきだ。
スタティック(グローバル)変数がどれだけ酷いかについては説明したくもない。それは明らかだ。&lt;/p&gt;

&lt;h1 id=&#34;6-彼の名前は職名ではない&#34;&gt;6. 彼の名前は職名ではない&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-4.png&#34; src=&#34;http://tbd.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-4.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;オブジェクト名はそのオブジェクトが何であるかを示すべきで、何をするかを示すべきではない。
実世界の物に名付けるのと同様に。
ページ集めではなく本、水入れではなくカップ、体飾りではなくTシャツ。
もちろん、プリンタやコンピュータのような例外はあるが、これらはこの記事を読まなかった人々によってごく最近発明されたものだ。&lt;/p&gt;

&lt;p&gt;例えば、次のような名前はその持ち主が何であるかを示す。
りんご、ファイル、HTTPリクエスト群、ソケット、XMLドキュメント、ユーザリスト、正規表現、整数、PostgreSQLテーブル、Jeffrey Lebowski。
適切な名前はいつも小さい絵として描ける。正規表現でさえ描ける。&lt;/p&gt;

&lt;p&gt;逆に、次に挙げる名前の例は持ち主が何をするかを示す。
ファイルリーダ、テキストパーサ、URLバリデータ、XMLプリンタ、サービスロケータ、シングルトン、スクリプトランナ、Javaプログラマ。
これらの絵を描けるか?
描けない。
こういう名前は良いオブジェクトには適さない。
これらは酷い設計につながる酷い名前だ。&lt;/p&gt;

&lt;p&gt;一般的に、「-er」で終わる名前を避けるべきだ。そのほとんどはダメなものだ。&lt;/p&gt;

&lt;p&gt;「&lt;code&gt;FileReader&lt;/code&gt;の代わりは何」と疑問に思うだろう。
よりよい名前は何?&lt;/p&gt;

&lt;p&gt;ええと、我々は既に&lt;code&gt;File&lt;/code&gt;を持っていて、それは実世界のディスク上のファイルの表現だ。
この表現は十分に強力ではない。なぜなら、それはファイルの内容を読む方法を知らないからだ。
その能力を持ったより強力なものを作りたい。
何という名前にする?
名前は、その持ち主が何をするかではなく、何であるかを示すべきであるということを思い出してほしい。
持ち主は何か?
データを持ったファイルだ。ただのファイルではなく。
&lt;code&gt;File&lt;/code&gt;っぽいけど、もっと洗練されたものだ。データを持った。
なので、&lt;code&gt;FileWithData&lt;/code&gt;、もしくは単に&lt;code&gt;DataFile&lt;/code&gt;というのはどうだろう?&lt;/p&gt;

&lt;p&gt;同様のロジックを他の全ての名前にも適用すべきだ。
常に何をするかよりも何であるかを考えよう。
オブジェクトに職名ではなく、リアルで、意味のある名前を付けよう。&lt;/p&gt;

&lt;p&gt;より詳しくは「&lt;a href=&#34;http://www.yegor256.com/2015/03/09/objects-end-with-er.html&#34;&gt;-ERで終わるオブジェクトを作るな&lt;/a&gt;」を参照。&lt;/p&gt;

&lt;h1 id=&#34;7-彼のクラスはfinalかabstractのどちらか&#34;&gt;7. 彼のクラスはFinalかAbstractのどちらか&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-5.png&#34; src=&#34;http://tbd.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-5.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;良いオブジェクトはfinalまたはabstractなクラスから生成される。
&lt;code&gt;final&lt;/code&gt;クラスは継承によって拡張できないクラスだ。
&lt;code&gt;abstract&lt;/code&gt;クラスは子供を持てないクラスだ。
簡単に言うと、クラスは、「君は僕を決して壊せない。僕はブラックボックスだ。」か、または「僕は壊れている。直してから使ってくれ。」のどちらかを言う。&lt;/p&gt;

&lt;p&gt;その間には何もない。finalクラスはブラックボックスで、あらゆる意味で変更できない。
オブジェクトは現状のままで働き、君はそれを使うか捨てるかしかしない。
そのプロパティを継承する別のクラスを作ることはできない。
これは&lt;code&gt;final&lt;/code&gt;修飾子によって禁止されている。
そのようなfinalクラスを拡張する唯一の手段は、その子供をデコレートすることだ。
例えば、(上記)&lt;code&gt;HTTPStatus&lt;/code&gt;クラスがあり、それを気に入らなかったとする。
いやまあ好きではあるけど、私にとっては十分強力ではないんだ。
HTTPステータスが400より大きい場合に例外を投げて欲しい。
&lt;code&gt;read()&lt;/code&gt;メソッドにもう少し処理をしてもらいたい。
古風なやり方は、そのクラスを拡張してメソッドを上書きすることだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class OnlyValidStatus extends HTTPStatus {
  public OnlyValidStatus(URL url) {
    super(url);
  }
  @Override
  public int read() throws IOException {
    int code = super.read();
    if (code &amp;gt; 400) {
      throw new RuntimException(&amp;quot;unsuccessful HTTP code&amp;quot;);
    }
    return code;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこれではダメなのか?
メソッドのひとつをオーバーライドすることで親クラス全体のロジックを壊す危険があるので全然ダメだ。
&lt;code&gt;read()&lt;/code&gt;を子クラスでオーバーライドしたら、親クラスから来る全てのメソッドがその新しいやつを使うことになる、ということを忘れないで欲しい。
これは、文字通り新しい「実装のかけら」をクラスの内部に挿入するということだ。
哲学的に言って、これは反則だ。&lt;/p&gt;

&lt;p&gt;一方、finalクラスを拡張するためには、それをブラックボックスのように扱い、他の実装でデコレートする必要がある。(&lt;a href=&#34;https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;デコレータパターン&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class OnlyValidStatus implements Status {
  private final Status origin;
  public OnlyValidStatus(Status status) {
    this.origin = status;
  }
  @Override
  public int read() throws IOException {
    int code = this.origin.read();
    if (code &amp;gt; 400) {
      throw new RuntimException(&amp;quot;unsuccessful HTTP code&amp;quot;);
    }
    return code;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このクラスがもともとと同じインターフェース、&lt;code&gt;Status&lt;/code&gt;を実装していることに注目して欲しい。
&lt;code&gt;HTTPStatus&lt;/code&gt;のインスタンスはコンストラクタを通して渡され、内包される。
そして、全てのメソッド呼び出しは割り込まれ、必要に応じて独自に実装される。
この設計だと、もとのオブジェクトをブラックボックスとして扱い、その内部のロジックには決して触らない。&lt;/p&gt;

&lt;p&gt;もし&lt;code&gt;final&lt;/code&gt;というキーワードを使わなかったら、だれでも(君自身でも)そのクラスを拡張し、損なうことができる。(よって&lt;code&gt;final&lt;/code&gt;でないクラスは悪い設計だ。)&lt;/p&gt;

&lt;p&gt;abstractクラスは真反対なケースだ。それは不完全で、そのままでは使えないことを示している。
独自の実装ロジックを挿入する必要があるが、それは許可された部分だけに限られる。
この部分は&lt;code&gt;abstract&lt;/code&gt;メソッドとして明示的に示されている。
例えば、&lt;code&gt;HTTPStatus&lt;/code&gt;は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class ValidatedHTTPStatus implements Status {
  @Override
  public final int read() throws IOException {
    int code = this.origin.read();
    if (!this.isValid()) {
      throw new RuntimException(&amp;quot;unsuccessful HTTP code&amp;quot;);
    }
    return code;
  }
  protected abstract boolean isValid();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見て分かるとおり、このクラスはHTTPコードを検証する方法を知らないので、継承して&lt;code&gt;isValid()&lt;/code&gt;をオーバーライドすることによってそのロジックを挿入することを期待している。
この継承は親クラスを損なわない。他の全メソッドが&lt;code&gt;final&lt;/code&gt;によって守られているからだ。(メソッドの修飾子に注目してくれ。)
つまり、このクラスは攻撃への備えがしてあって、完全に防御している。&lt;/p&gt;

&lt;p&gt;まとめると、クラスは&lt;code&gt;final&lt;/code&gt;か&lt;code&gt;abstract&lt;/code&gt;のどちらかであるべきで、その中間はない。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;この記事は、オブジェクト指向原理主義者であるYegorが彼のオブジェクト観の概論を書いたものだ。
彼のオブジェクトに対するとんがった信念が読み取れる。&lt;/p&gt;

&lt;p&gt;記事の内容をまとめると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;オブジェクトは何か実体と対応していないといけない。&lt;/li&gt;
&lt;li&gt;クラスはインターフェースを実装していないといけない。&lt;/li&gt;
&lt;li&gt;オブジェクトはユニーク性を保証するフィールドを持っていないといけない。&lt;/li&gt;
&lt;li&gt;オブジェクトは不変でないといけない&lt;/li&gt;
&lt;li&gt;クラスはスタティックメソッド/フィールドを持っていてはいけない。&lt;/li&gt;
&lt;li&gt;erで終わるクラス名を使ってはいけない。&lt;/li&gt;
&lt;li&gt;クラスにはfinalかabstractが付いていないといけない。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#1と#6はだいたい同じことを主張していて、その内容は実用的というよりかは哲学的だ。
敢えて実用面について言えば、同じ哲学を共有しているチームがこの主張に従えば、そのチーム内でコードの可読性や保守性が上がるというメリットがあると考えられる。
が、オブジェクト指向原理主義よりもGoFのデザインパターンの方がはるかに広く深く浸透しているので、このメリットはあまりありがたみが無い。
私はオブジェクト真理教に入信したわけではないので、これからもControllerとかFactoryとかServiceとかいうクラスを書くだろう。&lt;/p&gt;

&lt;p&gt;#2については、言っていることは分かるしインターフェースのメリットもよく理解しているつもりだが、わんさとクラスを書かないといけないのに逐一インターフェースまで書いてられるかというのが本音だ。
実際には、モックを書いたり多態したいとき、または将来そうなると天啓があったとき、つまりは必要に応じてインターフェースを書くのであって、なんでもかんでも書いていたら書くのも読むのもいたずらに大変になってしまう。(そういう方針をとって開発者から不満が噴出したプロジェクトが身近にあったと聞いた。)
Yegorのプロジェクトでは全てのクラスがインターフェースを実装しているんだろうか。信じ難い。&lt;/p&gt;

&lt;p&gt;#3も、ちょっと実用的な雰囲気の主張だが、よくみるとこれに従うことでどんなメリットがあるかとか、従わないことでどんな問題が発生するかとかが書いてない。
哲学的な主張か。
私が開発している&lt;a href=&#34;https://github.com/kaitoy/pcap4j&#34;&gt;Pcap4J&lt;/a&gt;には、ネットワークパケットを表すクラスが多数あるが、それらからインスタンス化されるオブジェクトは必ずしもユニークではない。
例えば、Ethernetヘッダを表すクラスである&lt;a href=&#34;https://github.com/kaitoy/pcap4j/blob/master/pcap4j-core/src/main/java/org/pcap4j/packet/EthernetPacket.java&#34;&gt;EthernetHeader&lt;/a&gt;は、Ethernetパケットの送り元と送り先が同じで、且つレイヤ3のプロトコルが同じなら&lt;code&gt;equals()&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;を返す。
つまり、実世界で異なるパケットのヘッダでも、Java世界では同一とみなされることがよくある。
この実装で実用上困ることは無い気がするけど、オブジェクト指向原理主義に照らすとダメってことか?
&lt;code&gt;UUID&lt;/code&gt;みたいなフィールドでも加えればいいのか?
そんなフィールドはEthernetヘッダにはないのに?&lt;/p&gt;

&lt;p&gt;#4は好き。ただ全てに適用できるかというと疑問。不変オブジェクトで、例えば&lt;a href=&#34;http://qiita.com/disc99/items/840cf9936687f97a482b#effective-java-builder&#34;&gt;Builderパターン(GoFじゃなくてEffective Javaの方)&lt;/a&gt;が対応している問題をどう解決するんだろう?
すごく頑張ってYegorの言いつけを守りながら、Builderパターンっぽくインスタンス化できるEthernetHeader(という名のEthernetヘッダフィールドの値を保持するクラス)を書いてみたら以下のようになった。&lt;/p&gt;

&lt;p&gt;まず、一般的なヘッダを表す&lt;code&gt;Header&lt;/code&gt;クラスを作る。不変で、&lt;code&gt;id&lt;/code&gt;という適当なフィールドを持つ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.util.MacAddress;

public final class Header {
  private final int id;

  public Header(int id) {
    this.id = id;
  }

  public int getId() { return id; }

  public DstAddrSetEthernetHeader dstAddr(MacAddress dstAddr) {
    return new DstAddrSetEthernetHeader(this, dstAddr);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;Header&lt;/code&gt;をデコレートして拡張し、&lt;code&gt;dstAddr&lt;/code&gt;というフィールドを追加したもちろん不変なクラス&lt;code&gt;DstAddrSetEthernetHeader&lt;/code&gt;(dstAddrだけがセットされたEthernetヘッダ)を作る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.util.MacAddress;

public final class DstAddrSetEthernetHeader {
  private final Header header;
  private final MacAddress dstAddr;

  DstAddrSetEthernetHeader(Header header, MacAddress dstAddr) {
    this.header = header;
    this.dstAddr = dstAddr;
  }

  public MacAddress getDstAddr() { return dstAddr; }

  public int getId() { return header.getId(); }

  public DstAddrAndSrcAddrSetEthernetHeader srcAddr(MacAddress srcAddr) {
    return new DstAddrAndSrcAddrSetEthernetHeader(this, srcAddr);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに&lt;code&gt;DstAddrSetEthernetHeader&lt;/code&gt;をデコレートして拡張し、&lt;code&gt;srcAddr&lt;/code&gt;というフィールドを追加したもちろん不変なクラス&lt;code&gt;DstAddrAndSrcAddrSetEthernetHeader&lt;/code&gt;(dstAddrとsrcAddrがセットされたEthernetヘッダ)を作る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.util.MacAddress;

public final class DstAddrAndSrcAddrSetEthernetHeader {
  private final DstAddrSetEthernetHeader header;
  private final MacAddress srcAddr;

  DstAddrAndSrcAddrSetEthernetHeader(DstAddrSetEthernetHeader header, MacAddress srcAddr) {
    this.header = header;
    this.srcAddr = srcAddr;
  }

  public MacAddress getSrcAddr() { return srcAddr; }

  public int getId() { return header.getId(); }

  public MacAddress getDstAddr() { return header.getDstAddr(); }

  public EthernetHeader type(EtherType type) {
    return new EthernetHeader(this, type);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっとビルド対象である&lt;code&gt;EthernetHeader&lt;/code&gt;を書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.util.MacAddress;

public final class EthernetHeader {
  private final int id;
  private final MacAddress dstAddr;
  private final MacAddress srcAddr;
  private final EtherType type;

  public EthernetHeader(DstAddrAndSrcAddrSetEthernetHeader header, EtherType type) {
    this.id = header.getId();
    this.dstAddr = header.getDstAddr();
    this.srcAddr = header.getSrcAddr();
    this.type = type;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記4つのクラスを使って、次のようにBuilderパターンっぽいことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.util.MacAddress;

public class ImmutableBuilderSample {
  public static void main(String[] args) {
    EthernetHeader header
      = new Header(1)
          .dstAddr(MacAddress.getByName(&amp;quot;aa:bb:cc:dd:ee:ff&amp;quot;))
          .srcAddr(MacAddress.getByName(&amp;quot;11:22:33:44:55:66&amp;quot;))
          .type(EtherType.IPV4);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パラメータの設定順を自由にしたければ、さらに&lt;code&gt;SrcAddrSetEthernetHeader&lt;/code&gt;とか&lt;code&gt;TypeSetEthernetHeader&lt;/code&gt;とか&lt;code&gt;DstAddrAndTypeSetEthernetHeader&lt;/code&gt;とか作らないといけない。これは疲れる。
沢山オブジェクトを作るのに、最後の&lt;code&gt;EthernetHeader&lt;/code&gt;以外のが使い捨てというのも辛い。
&lt;code&gt;EthernetHeader&lt;/code&gt;は3つしかフィールドがないからまだましな方なんだが。&lt;/p&gt;

&lt;p&gt;私は、不変クラスはスレッドセーフにすることを主目的として作る。
普通アプリケーションはマルチスレッドになるんだから、基本的にクラスは不変を目指して作り、どうしても可変にしたくなったときは内部で同期してスレッドセーフに保つか、外で同期してもらうか、またはシングルスレッドで使ってもらうかを考える。
上記のBuilderなんかは可変フィールドを使わないとまともに作れないし、その性質上マルチスレッドで使うことは普通ないし、無理に不変にする必要はなかろう。&lt;/p&gt;

&lt;p&gt;#5については、Yegorが問題視していることにはだいたい納得できる。(哲学的な部分以外は。。。)
しかし、Yegorが、スタティックメソッドが可変フィールドを参照することを前提に話しているところにひっかかる。
私はpublic staticなフィールドをfinal無しで書くことはないし、スタティックメソッドは殆どの場合引数だけを使うように書き、たまにfinalなフィールドを参照させるくらいだ。(ちょっとあやしいけど多分。)
世のユーティリティクラスもだいたいそんな感じで書かれているんじゃなかろうか。
この場合、スレッドセーフじゃないという問題点は出ないし、問題の分離も、スタティックフィールドでデータを共有するわけではないのでちゃんとできる。
モックはできないけど、ユーティリティクラスのモックを書きたいことなんてあるだろうか?&lt;/p&gt;

&lt;p&gt;#7は同意。abstractじゃないメソッドをオーバーライドするのって気持ち悪いし。
ところでデコレータパターンってすごい便利で汎用性高いと思うんだけど、いざというときに思いつかないようで、あんまり使ったことないな。&lt;/p&gt;

&lt;p&gt;以上ひとつひとつの主張について考えてみたけど、反感が多いな。
これはオブジェクト真理教に入信するメリットが見えてこないからだろう。
もともとOOPっていうのは、手続き型言語が隆盛な時代の関数を使った処理の分離という考え方を押し進め、処理と処理対象データを一緒にして分離するという実用的で技術的な目的のもとに生まれたもので、オブジェクトは実世界のモノを表現しなきゃいけないってのは後付けの哲学だ。
OOPはそれを共通認識として発展したわけではないので、極端な哲学に縛られていると長い歴史に揉まれた強力なノウハウの多くが使えなくなってしまう。
GoFのデザインパターンを否定するなら、GoFが解決した問題への別解を提示してくれないとなかなか受け入れがたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ORMは不快なアンチパターン</title>
          <link>http://tbd.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/</link>
          <pubDate>Sun, 13 Sep 2015 13:52:30 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html&#34;&gt;ORM Is an Offensive Anti-Pattern&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;結論から言えば、ORMはオブジェクト指向プログラミングの原則の全てに違反するひどいアンチパターンだ。オブジェクトをバラバラに引き裂き、もの言わぬ受身なデータ入れに変えてしまう。
小さいWebアプリケーションから、数千のテーブルをCRUD操作するエンタープライズシステムまで、どんなアプリケーションにもORMが存在することはゆるせない。
代わりになるものは?
SQLを話すオブジェクトだ。&lt;/p&gt;

&lt;h1 id=&#34;ormの仕組み&#34;&gt;ORMの仕組み&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E9%96%A2%E4%BF%82%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0&#34;&gt;オブジェクト関係マッピング&lt;/a&gt; (Object-relatinal mapping、ORM)は、オブジェクト指向言語(例えばJava)からリレーショナルデータベースにアクセスする技術(またはデザインパターン)だ。
ほとんどの言語で複数のORM実装がある。
例えば、Javaの&lt;a href=&#34;http://hibernate.org/orm/&#34;&gt;Hibernate&lt;/a&gt;、Ruby on Ralsの&lt;a href=&#34;http://guides.rubyonrails.org/active_record_basics.html&#34;&gt;ActiveRecord&lt;/a&gt;、PHPの&lt;a href=&#34;http://www.doctrine-project.org/&#34;&gt;Doctrine&lt;/a&gt;、Pythonの&lt;a href=&#34;http://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;。
Javaでは、ORMデザインは&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java_Persistence_API&#34;&gt;JPA&lt;/a&gt;として標準化されてさえいる。&lt;/p&gt;

&lt;p&gt;最初に、ORMがどう動くかを見てみよう。JavaとPostgreSQLとHibernateを使い、データベースに&lt;code&gt;post&lt;/code&gt; (訳注: ブログポスト、ブログの記事)という単一のテーブルがあるとする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;+-----+------------+--------------------------+
| id  | date       | title                    |
+-----+------------+--------------------------+
|   9 | 10/24/2014 | How to cook a sandwich   |
|  13 | 11/03/2014 | My favorite movies       |
|  27 | 11/17/2014 | How much I love my job   |
+-----+------------+--------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、このテーブルをJavaアプリケーションからCRUD操作したい。(CRUDはcreate、read、update、deleteの略。)
まず、&lt;code&gt;Post&lt;/code&gt;クラスを書く。(長くてごめん。けどなるべく短くしたんだ。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@Table(name = &amp;quot;post&amp;quot;)
public class Post {
  private int id;
  private Date date;
  private String title;

  @Id
  @GeneratedValue
  public int getId() {
    return this.id;
  }

  @Temporal(TemporalType.TIMESTAMP)
  public Date getDate() {
    return this.date;
  }

  public Title getTitle() {
    return this.title;
  }

  public void setDate(Date when) {
    this.date = when;
  }

  public void setTitle(String txt) {
    this.title = txt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hibernateでの処理をする前に、セッションファクトリを作らないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SessionFactory factory = new AnnotationConfiguration()
  .configure()
  .addAnnotatedClass(Post.class)
  .buildSessionFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このファクトリは&lt;code&gt;Post&lt;/code&gt;オブジェクトを操作したいときに「セッション」を作ってくれる。
セッションを使う全ての操作は以下のようなコードブロックで囲わないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Session session = factory.openSession(); try {
  Transaction txn = session.beginTransaction();
  // your manipulations with the ORM, see below
  txn.commit();
} catch (HibernateException ex) {
  txn.rollback();
} finally {
  session.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セッションが準備できたら、以下のようにしてデータベーステーブルから全てのpostのリストを取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List posts = session.createQuery(&amp;quot;FROM Post&amp;quot;).list();
for (Post post : (List&amp;lt;Post&amp;gt;) posts){
  System.out.println(&amp;quot;Title: &amp;quot; + post.getTitle());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで何が起こっているかは明確だと思う。
Hibernateという巨大で強力なエンジンが、データベースへの接続、SQLの&lt;code&gt;SELECT&lt;/code&gt;リクエスト発行、及びデータの取得をする。
そして、&lt;code&gt;Post&lt;/code&gt;クラスのインスタンスを作り、データをつめる。
そのオブジェクトが我々に渡されるとき、それにはデータが詰まっていて、getterでデータを取り出すことができる。上記&lt;code&gt;getTitle()&lt;/code&gt;でやっているように。&lt;/p&gt;

&lt;p&gt;逆の処理をしてオブジェクトをデータベースに送りたい場合は、同じことを逆の手順でやればいい。
&lt;code&gt;Post&lt;/code&gt;のインスタンスを作り、データを入れ、Hibernateに保存するよう頼む。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Post post = new Post();
post.setDate(new Date());
post.setTitle(&amp;quot;How to cook an omelette&amp;quot;); session.save(post);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これがほぼ全てのORMの仕組みだ。
基本的な原則はいつも同じで、ORMオブジェクトは無気力なデータの包みだ。
我々はORMフレームワークと話して、ORMフレームワークはデータベースと話す。
オブジェクトは我々のリクエストをORMフレームワークに送り、そのレスポンスを読むのを助けてくれるだけだ。
こうしたオブジェクトは、getterやsetterのほかに何のメソッドも持たない。どのデータベースから来たのかすら知らない。&lt;/p&gt;

&lt;p&gt;これがオブジェクト関係マッピングの仕組みだ。&lt;/p&gt;

&lt;p&gt;これの何が間違ってるかって? 全てだ!&lt;/p&gt;

&lt;h1 id=&#34;ormの何が悪いのか&#34;&gt;ORMの何が悪いのか&lt;/h1&gt;

&lt;p&gt;真面目な話、何が悪い?
Hibernateは既に10年以上にわたって最も人気のあるJavaライブラリの一つだ。
この世のほぼ全てのSQL集約的なアプリケーションが使っている。
Javaのチュートリアルは、データベースに接続するアプリケーションのためのものとしてHibernate(またはTopLinkやOpenJPAのような&lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software&#34;&gt;ほかのORM&lt;/a&gt;)を挙げる。
それはデファクトスタンダードであって、なお間違っていると言っているのか?
そうだ。&lt;/p&gt;

&lt;p&gt;私はORMの根底にあるアイデア全体が間違っていると訴えている。
この発明は多分、OOPにおいて最大の失敗である&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/07/26/why-null-is-bad/&#34;&gt;NULL&lt;/a&gt;に次ぐ失敗だ。&lt;/p&gt;

&lt;p&gt;実際、私だけがこんなことを言っているわけではないし、最初に言ったわけでもないことは明白だ。
この問題に関しては、既に多くの記述が尊敬すべき著者によって公開されている。例えば、Martin Fowlerによる&lt;a href=&#34;http://martinfowler.com/bliki/OrmHate.html&#34;&gt;OrmHate&lt;/a&gt;、Jeff Atwoodによる&lt;a href=&#34;http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/&#34;&gt;Object-Relational Mapping Is the Vietnam of Computer Science&lt;/a&gt;、Ted Newardによる&lt;a href=&#34;http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx&#34;&gt;The Vietnam of Computer Science&lt;/a&gt;、Laurie Vossによる&lt;a href=&#34;http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern&#34;&gt;ORM Is an Anti-Pattern&lt;/a&gt;などで、他にも沢山ある。&lt;/p&gt;

&lt;p&gt;しかし、私の論点はこれらの著者とは違っている。
彼らが挙げている、「ORMは遅い」とか「データベースアップグレードが難しい」といった理由は実用的で有効ではあるが、重要なポイントが欠けている。
こういう実用的な論点に対しては、Bozhidar Bozhanovが彼のブログポストの&lt;a href=&#34;http://techblog.bozho.net/orm-haters-dont-get-it/&#34;&gt;ORM Haters Don’t Get It&lt;/a&gt;の中でとてもよい実用的な回答を示している。&lt;/p&gt;

&lt;p&gt;重要なポイントとは、ORMが、データベースとのやり取りをオブジェクト内にカプセル化するのではなく、それを抜き取り、密で堅い&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;生ける有機体&lt;/a&gt;を文字通りばらばらに引き裂く、ということだ。
引き裂かれたオブジェクトの欠片はデータを保持し、ほかの欠片(ORMのエンジンであるセッションファクトリ内に実装されているもの)はそのデータの扱い方を知っていて、それをリレーショナルデータベースへ転送する。
下の絵を見てくれ。これはORMがやっていることを図示している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/orm-is-offensive-anti-pattern/orm-anti-pattern.svg&#34; alt=&#34;orm-anti-pattern.svg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ブログポストの記事を読むとき、二つのコンポーネントを扱わないといけない。一つはORMで、もう一つは手足を奪われたオブジェクト。
OOPにおいては、扱うふるまいは単一のエントリーポイント、つまり一つのオブジェクトから提供されることになっている。
しかしORMの場合、ふるまいは二つのエントリーポイント、つまりORMと「もの」から提供される。
これはもはやオブジェクトとは呼べない。&lt;/p&gt;

&lt;p&gt;この不快でひどいオブジェクト指向パラダイム違反のせいで、上記記事で述べられているような多くの実用的な問題を抱える。
私はこれにもう少しだけ付け加える。&lt;/p&gt;

&lt;h2 id=&#34;sqlが隠蔽されない&#34;&gt;SQLが隠蔽されない&lt;/h2&gt;

&lt;p&gt;ORMユーザはSQL(もしくは&lt;a href=&#34;https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html&#34;&gt;HQL&lt;/a&gt;のような方言)を書くはずだ。
前記の例を見てほしい。全てのブログポストを取得するために&lt;code&gt;session.createQuery(&amp;quot;FROM Post&amp;quot;)&lt;/code&gt;を実行している。
これはSQLではないけど、よく似たものだ。
つまり、リレーショナルモデルはオブジェクト内にカプセル化されていない。
代わりに、それはアプリケーション全体に公開されている。
オブジェクトに触る誰しもが、何かを取得したり保存したりするためにリレーショナルモデルを扱わないといけない。
つまり、ORMはSQLを隠蔽したりラップしたりしておらず、アプリケーション全体に撒き散らしている。&lt;/p&gt;

&lt;h2 id=&#34;テストが困難&#34;&gt;テストが困難&lt;/h2&gt;

&lt;p&gt;ブログポストのリストを操作するオブジェクトがある場合、それは&lt;code&gt;SessionFactory&lt;/code&gt;のインスタンスを扱わないといけない。
この依存をどうする?
モックを作らないといけない?
これはどのくらい複雑な作業だろうか?
上記コードを見てほしい。ユニットテストがどれだけ冗長でやっかいなものになるかわかるはずだ。
代わりに、統合テストを書いてアプリケーション全体をテスト用PostgreSQLに接続することもできる。
この場合、&lt;code&gt;SessionFactory&lt;/code&gt;のモックは不要だ。
しかしこういうテストは遅く、さらに注目すべきことには、データベースに対して何もしないオブジェクトがデータベースインスタンスに対してテストされることになる。最悪な設計だ。&lt;/p&gt;

&lt;p&gt;もう一度繰り返すが、ORMの実用的な問題は結果に過ぎない。
根本的な欠陥は、ORMがオブジェクトをバラバラにし、&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;オブジェクト&lt;/a&gt;の真の概念にひどく違反していることだ。&lt;/p&gt;

&lt;h1 id=&#34;sqlを話すオブジェクト&#34;&gt;SQLを話すオブジェクト&lt;/h1&gt;

&lt;p&gt;他の選択肢は?
例を挙げて教えよう。
あの、&lt;code&gt;Post&lt;/code&gt;クラスを私のやり方で設計してみよう。
これは二つのクラスに分ける必要がある。&lt;code&gt;Post&lt;/code&gt;と&lt;code&gt;Posts&lt;/code&gt;だ。
単数形と複数形。
私の&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;以前の記事&lt;/a&gt;ですでに述べたように、よいオブジェクトは常に現実世界のエンティティの抽象だ。
この原則が実際にどう働くかをここに示す。
我々は二つのエンティティを扱う。データベーステーブルとテーブルの行だ。
これが二つのクラスを作る理由だ。&lt;code&gt;Posts&lt;/code&gt;がテーブルを表し、&lt;code&gt;Post&lt;/code&gt;が行を表す。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://tbd.kaitoy.xyz/images/orm-is-offensive-anti-pattern/sql-speaking-object.svg&#34; alt=&#34;sql-speaking-object.svg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;例の&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;記事&lt;/a&gt;で既に述べたように、全てのオブジェクトは契約によって働き、インターフェースを実装すべきだ。
我々の設計も二つのインターフェースから始めよう。
もちろん、オブジェクトは不変だ。&lt;code&gt;Posts&lt;/code&gt;は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
interface Posts {
  Iterable&amp;lt;Post&amp;gt; iterate();
  Post add(Date date, String title);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Post&lt;/code&gt;は以下だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
interface Post {
  int id();
  Date date();
  String title();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データベーステーブル内の全てのpostを表示するには以下のようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Posts posts = // we&#39;ll discuss this right now
for (Post post : posts.iterate()){
  System.out.println(&amp;quot;Title: &amp;quot; + post.title());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しいpostを作る場合は以下のようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Posts posts = // we&#39;ll discuss this right now
posts.add(new Date(), &amp;quot;How to cook an omelette&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにすると真のオブジェクトになる。
これらのオブジェクトは全ての処理を受け持ち、実装の詳細を完璧に隠蔽する。
トランザクションもセッションもファクトリもない。
これらのオブジェクトが実際にPostgreSQLと話しているのかテキストファイルからデータを持ってきているのかすらわからない。
&lt;code&gt;Posts&lt;/code&gt;に求められるのは、全てのブログポストを取得する機能と新しいブログポストを作る機能だけだ。
実装の詳細は完璧に内部に隠蔽されている。
これから、どのようにこれら二つのクラスを実装できるかを見ていきたい。&lt;/p&gt;

&lt;p&gt;ここではJDBCラッパに&lt;a href=&#34;http://jdbc.jcabi.com/&#34;&gt;jcabi-jdbc&lt;/a&gt;を使うが、好みに応じてほかのものやJDBCを直接使ってもよい。
それは全く重要ではない。重要なのは、データベースとのやり取りをオブジェクト内に隠蔽することだ。
&lt;code&gt;Posts&lt;/code&gt;から始めよう。&lt;code&gt;PgPosts&lt;/code&gt;クラス(「pg」はPostgreSQLのこと)に実装する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class PgPosts implements Posts {
  private final Source dbase;
  public PgPosts(DataSource data) {
    this.dbase = data;
  }
  public Iterable&amp;lt;Post&amp;gt; iterate() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT id FROM post&amp;quot;)
      .select(
        new ListOutcome&amp;lt;Post&amp;gt;(
          new ListOutcome.Mapping&amp;lt;Post&amp;gt;() {
            @Override
            public Post map(final ResultSet rset) {
              return new PgPost(rset.getInteger(1));
            }
          }
        )
      );
  }
  public Post add(Date date, String title) {
    return new PgPost(
      this.dbase,
      new JdbcSession(this.dbase)
        .sql(&amp;quot;INSERT INTO post (date, title) VALUES (?, ?)&amp;quot;)
        .set(new Utc(date))
        .set(title)
        .insert(new SingleOutcome&amp;lt;Integer&amp;gt;(Integer.class))
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に&lt;code&gt;Post&lt;/code&gt;を&lt;code&gt;PgPost&lt;/code&gt;クラスに実装する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class PgPost implements Post {
  private final Source dbase;
  private final int number;
  public PgPost(DataSource data, int id) {
    this.dbase = data;
    this.number = id;
  }
  public int id() {
    return this.number;
  }
  public Date date() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT date FROM post WHERE id = ?&amp;quot;)
      .set(this.number)
      .select(new SingleOutcome&amp;lt;Utc&amp;gt;(Utc.class));
  }
  public String title() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT title FROM post WHERE id = ?&amp;quot;)
      .set(this.number)
      .select(new SingleOutcome&amp;lt;String&amp;gt;(String.class));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今作ったクラスを使ってデータベースとやり取りする完全なシナリオは以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Posts posts = new PgPosts(dbase);
for (Post post : posts.iterate()){
  System.out.println(&amp;quot;Title: &amp;quot; + post.title());
}
Post post = posts.add(new Date(), &amp;quot;How to cook an omelette&amp;quot;);
System.out.println(&amp;quot;Just added post #&amp;quot; + post.id());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/aintshy/hub/tree/0.7.2/src/main/java/com/aintshy/pgsql&#34;&gt;ここ&lt;/a&gt;で完全な実用的な例を見られる。
これはオープンソースのWebアプリで、上で説明したのと全く同じアプローチ、つまりSQLを話すオブジェクトを使ってPostgreSQLにアクセスする。&lt;/p&gt;

&lt;h1 id=&#34;性能は&#34;&gt;性能は?&lt;/h1&gt;

&lt;p&gt;「性能は?」と君が叫んでいるのが聞こえる。
数行上のスクリプトにはデータベースとの冗長なやりとりを書いた。
まず、&lt;code&gt;SELECT id&lt;/code&gt;でブログポストのIDを取得し、さらに、タイトルを取得するために&lt;code&gt;SELECT title&lt;/code&gt;をそれぞれのブログポストに対して実行する。
これは非効率だ。単に遅すぎると言ってもいい。&lt;/p&gt;

&lt;p&gt;心配はいらない。これはオブジェクト指向プログラミングであり、柔軟なんだ!
&lt;code&gt;PgPost&lt;/code&gt;のデコレータを作り、全てのデータをそのコンストラクタで受け取って内部で永遠にキャッシュしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class ConstPost implements Post {
  private final Post origin;
  private final Date dte;
  private final String ttl;
  public ConstPost(Post post, Date date, String title) {
    this.origin = post;
    this.dte = date;
    this.ttl = title;
  }
  public int id() {
    return this.origin.id();
  }
  public Date date() {
    return this.dte;
  }
  public String title() {
    return this.ttl;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このデコレータはPostgreSQLやJDBCについて何も関与しないことに注目してほしい。
単に&lt;code&gt;Post&lt;/code&gt;オブジェクトをデコレートして日付(date)とタイトル(title)をキャッシュするだけだ。
例によってこのデコレータは不変だ。&lt;/p&gt;

&lt;p&gt;さて、&lt;code&gt;Posts&lt;/code&gt;の別の実装を作って、「定数」オブジェクトを返すようにしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class ConstPgPosts implements Posts {
  // ...
  public Iterable&amp;lt;Post&amp;gt; iterate() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT * FROM post&amp;quot;)
      .select(
        new ListOutcome&amp;lt;Post&amp;gt;(
          new ListOutcome.Mapping&amp;lt;Post&amp;gt;() {
            @Override
            public Post map(final ResultSet rset) {
              return new ConstPost(
                new PgPost(rset.getInteger(1)),
                Utc.getTimestamp(rset, 2),
                rset.getString(3)
              );
            }
          }
        )
      );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今、この新しいクラスの&lt;code&gt;iterate()&lt;/code&gt;が返す全てのブログポストには、データベースとの一往復で取得された日付とタイトルが入っている。
デコレータやインターフェースの複数の実装を使うことで、どんな機能も望みどおりに構成することができる。
最も重要なことは、機能は拡張されたが設計は複雑になっていないことだ。クラスのサイズが大きくなっていないからね。
代わりに、小さく、それ故強度と凝集度が高い新しいクラスを導入した。&lt;/p&gt;

&lt;h1 id=&#34;トランザクションは&#34;&gt;トランザクションは?&lt;/h1&gt;

&lt;p&gt;全てのオブジェクトはそれ自身のトランザクションを扱い、それを&lt;code&gt;SELECT&lt;/code&gt;や&lt;code&gt;INSERT&lt;/code&gt;と同様にカプセル化すべきだ。
これはトランザクションのネストにつながる。
トランザクションのネストは、データベースサーバがサポートしていれば全く素晴らしいものだ。
サポートされていなければ、セッション全体に渡るトランザクションを表すオブジェクトを作り、「callable」クラスを受け取ればいい。
以下がその例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class Txn {
  private final DataSource dbase;
  public &amp;lt;T&amp;gt; T call(Callable&amp;lt;T&amp;gt; callable) {
    JdbcSession session = new JdbcSession(this.dbase);
    try {
      session.sql(&amp;quot;START TRANSACTION&amp;quot;).exec();
      T result = callable.call();
      session.sql(&amp;quot;COMMIT&amp;quot;).exec();
      return result;
    } catch (Exception ex) {
      session.sql(&amp;quot;ROLLBACK&amp;quot;).exec();
      throw ex;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ひとつのトランザクションに複数のオブジェクト操作をラップしたい場合はこのようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Txn(dbase).call(
  new Callable&amp;lt;Integer&amp;gt;() {
    @Override
    public Integer call() {
      Posts posts = new PgPosts(dbase);
      Post post = posts.add(new Date(), &amp;quot;How to cook an omelette&amp;quot;);
      posts.comments().post(&amp;quot;This is my first comment!&amp;quot;);
      return post.id();
    }
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードは新しいブログポストを作ってコメントを加える。
もし処理に失敗したら、トランザクション全体がロールバックされる。&lt;/p&gt;

&lt;p&gt;私にはこのアプローチがオブジェクト指向に見える。
私はこれを「SQLを話すオブジェクト」と呼んでいる。
なぜなら、このオブジェクトはデータベースサーバとSQLを話す方法を知っているからだ。
それはオブジェクトのスキルで、完璧に内部にカプセル化されている。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;ORMはHibernateをちょっと使ったことがあるくらい。
IPAのデータベーススペシャリストの試験を申し込んだものの参考書が理解できなくてあきらめた過去もあり、この分野には苦手意識があって、あまり大きい声は出せない。&lt;/p&gt;

&lt;p&gt;Hibernateについてちょっと言えば、使い始めはすばらしいものに見えて興奮するが、だんだんとその融通の利かなさにうんざりしてきて、結局DAOとかにSQLを書きまくったり、自分でデータをキャッシュする仕組みを書いたりする羽目になる、というイメージ。
Hibernateを初歩的に使うと一行もSQL(やHQL)を書かずにRDBを使うアプリケーションを書けるので、ORMはSQLを学ぶコストをカットするためのツールであると勘違いしてしまうが、実際にはインピーダンスミスマッチの解決が主目的であって、実用に際してはRDBとSQLへの深い知識が必要になる。&lt;/p&gt;

&lt;p&gt;もちろんこれはORMの「実用的な問題」であって、Yegorが書いていることとは違う。&lt;/p&gt;

&lt;p&gt;日本では、Yegorも挙げているLaurie Vossの&lt;a href=&#34;http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern&#34;&gt;2011年半ばのブログポスト&lt;/a&gt;がきっかけでORMの問題が話題になったようだ。
これは&lt;a href=&#34;https://ja.wikipedia.org/wiki/NoSQL&#34;&gt;NoSQL&lt;/a&gt;が日本で大きく取り上げられ始めた時期ともかぶっている気がする。
もっと前から本当に性能にシビアなWebサービス界ではNoSQLを使うのが主流になっていたみたいだけど。
これはGoogle、Amazon、FacebookといったWebサービス企業のカリスマがNoSQLを押したのもあるか。
ホリエモンもエンジニアだったころ自社のサービスを作った時に使ったとか。これは15年以上前の話だから、かなり先見性があったんだな。&lt;/p&gt;

&lt;p&gt;今RDBをもっとも使っている分野であろうエンタープライズ向けのシステムやパッケージソフトも、サービス化が大きなトレンドであり、それに加えてマルチテナント化が進めば扱うデータ量が増え、性能に対してどんどんシビアになり、NoSQLを取り入れる動きが増えるんだろう。
&lt;a href=&#34;http://japan.zdnet.com/article/35061140/&#34;&gt;2015年はNoSQL元年&lt;/a&gt;なんて記事もある。この記事によれば、NoSQLは大量の非構造化データを扱うIoTやM2Mの分野に有効だそうな。&lt;/p&gt;

&lt;p&gt;まあこれもYegorが書いていることとは関係ないけど。&lt;/p&gt;

&lt;p&gt;Yegorが言っていること、ORMは本来オブジェクトの仕事であるものを取り上げてしまうのでだめだという理屈は、オブジェクト原理主義者から見ればそうなのかもしれないが、一般の開発者から見ればそれがいいんじゃないかという話になって、議論はかみ合わない。
Yegor自身が前半で書いているORMを使ったコードより、後半のOOP原理的コードの方がかなり長い。
それってORMを使った方がやっぱりいいんじゃないのという感想を持つ人が多いのでは。(少なくとも「実用的な問題」を抜きにすれば。)&lt;/p&gt;

&lt;p&gt;オブジェクト原理主義をしっかり理解し、そのメリットを知らなければYegorの説教も馬の耳にだ。というわけで、次は&lt;a href=&#34;http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html&#34;&gt;Seven Virtues of a Good Object&lt;/a&gt;を読むか。(&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;訳した。&lt;/a&gt;)&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>なぜNullはダメか</title>
          <link>http://tbd.kaitoy.xyz/2015/07/26/why-null-is-bad/</link>
          <pubDate>Sun, 26 Jul 2015 19:07:20 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/26/why-null-is-bad/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;Why NULL is Bad?&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Javaで&lt;code&gt;NULL&lt;/code&gt;を使う単純な例を以下に示す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    return null;
  }
  return new Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このメソッドの何が間違っているのか? オブジェクトの代わりに&lt;code&gt;NULL&lt;/code&gt;を返す可能性がある、というのが間違っているところだ。
&lt;code&gt;NULL&lt;/code&gt;はオブジェクト指向パラダイムにおけるひどい慣習で、全力で避けるべきものだ。
これについては多くの意見が既に発表されている。
たとえば、Tony Hoareによるプレゼン&lt;a href=&#34;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&#34;&gt;Null References, The Billion Dollar Mistake&lt;/a&gt;や、David Westの著書&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;の全体に渡って述べられている。&lt;/p&gt;

&lt;p&gt;ここで、その論拠のすべてをまとめ、&lt;code&gt;NULL&lt;/code&gt;の使用を回避して適切なオブジェクト指向構造に置き換える方法の例を紹介したいと思う。&lt;/p&gt;

&lt;p&gt;基本的に、&lt;code&gt;NULL&lt;/code&gt;の代わりになり得るものはふたつある。&lt;/p&gt;

&lt;p&gt;ひとつは&lt;a href=&#34;https://en.wikipedia.org/wiki/Null_Object_pattern&#34;&gt;Nullオブジェクト&lt;/a&gt;デザインパターンだ。(それをひとつの不変オブジェクトにするのが最善。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    return Employee.NOBODY;
  }
  return Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もうひとつは、オブジェクトを返せないときに例外を投げて&lt;a href=&#34;http://martinfowler.com/ieeeSoftware/failFast.pdf&#34;&gt;フェイルファスト&lt;/a&gt;することだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    throw new EmployeeNotFoundException(name);
  }
  return Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、&lt;code&gt;NULL&lt;/code&gt;に反対する論拠を見てみよう。&lt;/p&gt;

&lt;p&gt;因みに、上記Tony HoareのプレゼンやDavid Westの著書に加えて、私はこの記事を書く前に以下の本や記事を読んだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Robert Martinの&lt;a href=&#34;http://www.amazon.com/dp/0132350882/&#34;&gt;Clean Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Steve McConnellの&lt;a href=&#34;http://www.amazon.com/dp/0735619670/&#34;&gt;Code Complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;John Sonmezの&lt;a href=&#34;http://elegantcode.com/2010/05/01/say-no-to-null/&#34;&gt;Say &amp;ldquo;No&amp;rdquo; to &amp;ldquo;Null&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;StackOverflowの&lt;a href=&#34;http://stackoverflow.com/questions/1274792/is-returning-null-bad-design&#34;&gt;Is returning null bad design?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;アドホック-場当たりな-エラー処理&#34;&gt;アドホック(場当たりな)エラー処理&lt;/h3&gt;

&lt;p&gt;インプットとしてオブジェクトを受け取った場合は常に、それが&lt;code&gt;NULL&lt;/code&gt;でないか、また有効なオブジェクト参照かどうかを確認しないといけない。
その確認を忘れると、&lt;code&gt;NullPointerException&lt;/code&gt; (NPE)が実行時に処理を止めてしまう恐れがある。
このため、ロジックが複数の確認処理やif/then/else分岐に汚染されてしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// this is a terrible design, don&#39;t reuse
Employee employee = dept.getByName(&amp;quot;Jeffrey&amp;quot;);
if (employee == null) {
  System.out.println(&amp;quot;can&#39;t find an employee&amp;quot;);
  System.exit(-1);
} else {
  employee.transferTo(dept2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/C%E8%A8%80%E8%AA%9E&#34;&gt;C&lt;/a&gt;などの命令文を並べる手続き型言語において、例外的な状況に対応する手法だ。
OOPは、主にこういったアドホックエラー処理のブロックを排除する目的で、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86&#34;&gt;例外処理&lt;/a&gt;を導入した。
OOPでは、例外処理をアプリケーションレベルのエラーハンドラにまかせることで、コードをかなりきれいで短いものにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dept.getByName(&amp;quot;Jeffrey&amp;quot;).transferTo(dept2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;参照は手続き型言語から受け継がれたものだと認識し、Nullオブジェクトか例外を変わりに使うべきだ。&lt;/p&gt;

&lt;h3 id=&#34;あいまいな意図&#34;&gt;あいまいな意図&lt;/h3&gt;

&lt;p&gt;上記メソッドの目的を明確に伝えるためには、&lt;code&gt;getByName()&lt;/code&gt;は&lt;code&gt;getByNameOrNullIfNotFound()&lt;/code&gt;という名前でなければいけない。
これと同様の名前を、オブジェクトか&lt;code&gt;NULL&lt;/code&gt;を返す全ての関数が持たなければいけない。
さもなくば、だれかがあいまいなコードを読むはめになる。だから、コードの意図を明確にするために、関数に長い名前をつけるべきだ。&lt;/p&gt;

&lt;p&gt;このあいまいさを排除するために、関数は、実オブジェクトを返すか、Nullオブジェクトを返すか、例外を投げる、しかしてはいけない。&lt;/p&gt;

&lt;p&gt;性能を考慮すると&lt;code&gt;NULL&lt;/code&gt;を返さざるを得ない場合もあるだろうと主張する人がいるかもしれない。
たとえば、Javaの&lt;code&gt;&lt;a href=&#34;http://docs.oracle.com/javase/jp/7/api/java/util/Map.html&#34;&gt;Map&lt;/a&gt;&lt;/code&gt;インターフェースの&lt;code&gt;get()&lt;/code&gt;メソッドは、指定された要素がないときに&lt;code&gt;NULL&lt;/code&gt;を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Employee employee = employees.get(&amp;quot;Jeffrey&amp;quot;);
if (employee == null) {
  throw new EmployeeNotFoundException();
}
return employee;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは、&lt;code&gt;Map&lt;/code&gt;が&lt;code&gt;NULL&lt;/code&gt;を使っているおかげで、mapを一回しか検索しない。
もし、&lt;code&gt;Map&lt;/code&gt;の&lt;code&gt;get()&lt;/code&gt;を、要素が見つからないときに例外を投げるように修正したら、以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (!employees.containsKey(&amp;quot;Jeffrey&amp;quot;)) { // first search
  throw new EmployeeNotFoundException();
}
return employees.get(&amp;quot;Jeffrey&amp;quot;); // second search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明らかに、この方法は最初のものより2倍遅い。さて、どうする?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;インターフェースは、(作者を攻めるわけではないが、)設計に問題がある。
その&lt;code&gt;get()&lt;/code&gt;メソッドは&lt;code&gt;Iterator&lt;/code&gt;を返すべきで、その場合以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator found = Map.search(&amp;quot;Jeffrey&amp;quot;);
if (!found.hasNext()) {
  throw new EmployeeNotFoundException();
}
return found.next();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに、C++の標準ライブラリの&lt;a href=&#34;http://www.cppll.jp/cppreference/cppmap_details.html&#34;&gt;map::find()&lt;/a&gt;はまさにこのように設計されている。&lt;/p&gt;

&lt;h3 id=&#34;コンピュータ思考-vs-オブジェクト思考&#34;&gt;コンピュータ思考 vs. オブジェクト思考&lt;/h3&gt;

&lt;p&gt;Javaのオブジェクトはデータ構造を指すポインタで、&lt;code&gt;NULL&lt;/code&gt;は何も指さないポインタ(Intel x86プロセッサでは0x00000000)であることを知っている人にとっては、&lt;code&gt;if (employee == null)&lt;/code&gt;という文は理解できる。&lt;/p&gt;

&lt;p&gt;しかし、もし君がオブジェクトになって考えたとすると、この文はかなり意味のないものになる。オブジェクト視点で上記コードは以下のように見える。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;- もしもし、ソフトウェア部ですか?
- はい。
- Jeffreyと話したいのですが。
- 少々お待ちください。。。
- もしもし。
- あなたはNULLですか?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会話の最後の質問が変だろ?&lt;/p&gt;

&lt;p&gt;代わりに、もしJeffreyへの取り次ぎをお願いした後で電話が切れたら、自分に問題(例外)が発生した、ということにする。
この時点で、もう一度電話してみるか、Jeffreyにつながらないので仕事が進みませんと上司に報告する。&lt;/p&gt;

&lt;p&gt;あるいは、ソフトウェア部の人が、Jeffreyではないがだいたいの質問に答えられる人に取り次いでくれるかもしれないし、
Jeffreyにしかわからない用事だから無理、と拒否してくるかもしれない(Nullオブジェクト)。&lt;/p&gt;

&lt;h3 id=&#34;遅いエラー&#34;&gt;遅いエラー&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://martinfowler.com/ieeeSoftware/failFast.pdf&#34;&gt;フェイルファスト&lt;/a&gt;な&lt;code&gt;getByName()&lt;/code&gt;に対して、Nullオブジェクトを使った方はゆっくり死のうとしている。途中で他のものを殺しながら。
問題が発生したので例外処理をすぐに始めるべきだと周りに知らせる代わりに、クライアントからエラーを隠している。&lt;/p&gt;

&lt;p&gt;この議論は、前述した「アドホックエラー処理」に近い。&lt;/p&gt;

&lt;p&gt;コードはできるだけもろい方がいい。必要なときに壊れるように。&lt;/p&gt;

&lt;p&gt;メソッドを、それが扱うデータに対してできるだけ厳しくさせ、与えられたデータに不備があったりメソッドの使用方法に反していたら、例外を投げるようにすべきだ。&lt;/p&gt;

&lt;p&gt;もしくは、共通的な挙動をする他は常に例外を投げるNullオブジェクトを返すべきだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  Employee employee;
  if (id == 0) {
    employee = new Employee() {
      @Override
      public String name() {
        return &amp;quot;anonymous&amp;quot;;
      }
      @Override
      public void transferTo(Department dept) {
        throw new AnonymousEmployeeException(
          &amp;quot;I can&#39;t be transferred, I&#39;m anonymous&amp;quot;
        );
      }
    };
  } else {
    employee = Employee(id);
  }
  return employee;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可変で不完全なオブジェクト&#34;&gt;可変で不完全なオブジェクト&lt;/h3&gt;

&lt;p&gt;一般的に、オブジェクトは&lt;a href=&#34;http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html&#34;&gt;不変的&lt;/a&gt;に設計することが望ましい。
これはつまり、オブジェクトはインスタンス化の際に必要な情報を全て受け取り、その後そのライフサイクル全体に渡ってその状態を変えないということだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF&#34;&gt;遅延読み込み&lt;/a&gt;をする際によく使われ、オブジェクトを不完全で可変にしてしまう。以下が例だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Department {
  private Employee found = null;
  public synchronized Employee manager() {
    if (this.found == null) {
      this.found = new Employee(&amp;quot;Jeffrey&amp;quot;);
    }
    return this.found;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この手法は、広く使われてはいるが、OOPにおけるアンチパターンだ。
主な理由は、実行環境の性能問題の責任をオブジェクトに負わせているからだ。本来それは&lt;code&gt;Employee&lt;/code&gt;オブジェクトが気にすべきことではない。&lt;/p&gt;

&lt;p&gt;オブジェクトが、自身の状態を管理して、自身の役割に関するふるまいを公開する代わりに、戻り値のキャッシュの面倒を見なければいけない。これが遅延読み込みというものだ。&lt;/p&gt;

&lt;p&gt;キャッシュはemployee(従業員)がオフィスでするようなことじゃないだろ?&lt;/p&gt;

&lt;p&gt;解決策?
遅延読み込みを上記の例みたいな原始的な方法でやらないことだ。代わりに、キャッシュ処理をアプリケーションの他のレイヤに移せばいい。&lt;/p&gt;

&lt;p&gt;たとえば、Javaなら、アスペクト指向プログラミングのアスペクトが使える。
たとえば、&lt;a href=&#34;http://aspects.jcabi.com/&#34;&gt;jcabi-aspects&lt;/a&gt;には&lt;code&gt;&lt;a href=&#34;http://aspects.jcabi.com/annotation-cacheable.html&#34;&gt;@Cacheable&lt;/a&gt;&lt;/code&gt;というアノテーションがあり、メソッドの戻り値をキャッシュできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.jcabi.aspects.Cacheable;
public class Department {
  @Cacheable(forever = true)
  public Employee manager() {
    return new Employee(&amp;quot;Jacky Brown&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;君がこの分析に納得して&lt;code&gt;NULL&lt;/code&gt;を使うのをやめることを願う。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;http://www.youtube.com/embed/o3aNJX7AP3M&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Nullを使っちゃだめという意見はめずらしくないが、その根拠をコードの信頼性、可読性といった技術的な側面からだけでなく、
オブジェクト界に降り立って見たときに感じる違和感というオブジェクト哲学的な側面からも説明する辺りが面白い。&lt;/p&gt;

&lt;p&gt;まあNullを完全に使わないという境地には、少なくともJavaのコードでは一生たどり着ける気がしないが。
メソッドの先頭で引数のNullチェックをするとかもダメなんだろうか。それがダメだとフェイルファストができなかったり、メッセージのないNullPointerExceptionが発生したりして微妙。
あ、フルスクラッチで完全に自己完結したアプリケーションを作る場合の話か。それならそもそもNullを渡すなという話にしかならないか。&lt;/p&gt;

&lt;p&gt;自分で書くクラスやライブラリについて、Nullは内部的には使うけど、APIには一切Nullを返させない、くらいなら実現するのは難しくなさそうだし、やったほうがいい気もする。(この場合遅延読み込みで一時的にNullをセットしておくのはあり。)
ただ、性能を考えた場合は、例えばエラー処理はアドホックが一番軽くて、次にNullオブジェクトパターンで、例外はちょっと重めという風になるだろうから、Nullを返したくなることもありそう。&lt;/p&gt;

&lt;p&gt;ことあるごとに例外を投げてくるAPIは使う側にとってはうっとうしいしなぁ。
多彩な例外を投げ分けるJavaのリフレクションみたいなのは、使うとコードが散らかってかなわん。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Getter/Setterは悪だ。以上。</title>
          <link>http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/</link>
          <pubDate>Wed, 22 Jul 2015 00:21:15 MDT</pubDate>
          <author>Kaito Yamada</author>
          <guid>http://tbd.kaitoy.xyz/2015/07/22/getters-setters-evil/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2003年にAllen Holubが書いた&lt;a href=&#34;http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html&#34;&gt;Why getter and setter methods are evil&lt;/a&gt;という有名な記事に端を発する古い議論がある。それは、getter/setterはアンチパターンで避けるべきものなのか、
もしくはオブジェクト指向プログラミングに必須なものなのかというもの。
この議論に少しだけ私の意見を加えたいと思う。&lt;/p&gt;

&lt;p&gt;上記記事の要旨はこうだ。
getterやsetterはひどい慣習で、これらを使うやつらはゆるせん。誤解の無いようもう一度言うが、
私はget/setを可能な限り避けるべきだと言っているのではない。それらは君のコードに決して現れてはいけないのだ。&lt;/p&gt;

&lt;p&gt;横柄で目につく物言いだろう?
君は15年来get/setパターンを使い続けている尊敬を集めるJavaアーキテクトなんだろう?
どこぞの馬の骨にこんなデタラメを言われたくはないだろう?
ああ、その気持ちはわかる。私がDavid Westの&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;という本に出会ったとき、
私もほとんど同じことを感じた。
Object Thinkingは、私が今まで読んだオブジェクト指向プログラミングについての本の中で最高のものだ。
だからお願いだ。ひとまず落ち着いて。私に説明させてほしい。&lt;/p&gt;

&lt;h3 id=&#34;既存の論拠&#34;&gt;既存の論拠&lt;/h3&gt;

&lt;p&gt;オブジェクト指向の世界で、アクセッサ(getterやsetterの別名)に反対する論拠はいくつかあるが、
私にはそれら全てが十分に有力であるとは思えない。ひとつひとつ簡単に見ていこう。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;頼め、尋ねるな&lt;/p&gt;

&lt;p&gt;Allen Holub曰く、「ある処理をする際、その処理のために君が欲しい情報をオブジェクトに尋ねてはいけない。
その情報を持ったオブジェクトにその処理をするよう頼みなさい。」&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;カプセル化原則違反&lt;/p&gt;

&lt;p&gt;setterを通してどんな新たなデータも入力できるので、
一つのオブジェクトをその他の様々なオブジェクトが様々に扱うことができてしまう。
また、だれでもオブジェクトを変更できるので、
オブジェクトが単純に自身の状態を安全にカプセル化できない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;実装の詳細の暴露&lt;/p&gt;

&lt;p&gt;あるオブジェクトから他のオブジェクトを取得できる場合、前者のオブジェクトの実装の詳細に過度に依存してしまう。
もし明日その実装、例えば返すオブジェクトの型が変わったら、周辺のコードも書き換えないといけない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これらの全ての論拠は正当だが、重要なポイントが抜けている。&lt;/p&gt;

&lt;h3 id=&#34;根本的な誤解&#34;&gt;根本的な誤解&lt;/h3&gt;

&lt;p&gt;ほとんどのプログラマはオブジェクトはメソッドを持ったデータ構造だと考えている。
ここでBozhidar Bozhanovによる記事、&lt;a href=&#34;https://dzone.com/articles/getters-and-setters-are-not&#34;&gt;Getters and Setters Are Not Evil&lt;/a&gt;から引用する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;しかし、人々がgetterやsetterをつけるオブジェクトのほとんどが、単純なデータホルダだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この思い違いが巨大な誤解の結果だ!
オブジェクトは単純なデータホルダではない。オブジェクトはメソッド付きのデータ構造ではない。
このデータホルダというコンセプトは、CやCOBOLといった手続き型言語からオブジェクト指向プログラミングに持ち込まれたものだ。
もう一度言う。オブジェクトはデータとそれを操作する関数をセットにしたものではない。
オブジェクトはデータエンティティではない。では何か?&lt;/p&gt;

&lt;h3 id=&#34;ボールと犬&#34;&gt;ボールと犬&lt;/h3&gt;

&lt;p&gt;真のオブジェクト指向プログラミングでは、
オブジェクトは&lt;a href=&#34;http://tbd.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;生きている生物&lt;/a&gt;だ。私や君と同じように。
オブジェクトは生きている有機体で、それ自身の挙動や、特性や、ライフサイクルを持っている。&lt;/p&gt;

&lt;p&gt;生きている有機体はsetterを持てるだろうか? 犬にボールを&amp;rdquo;set&amp;rdquo;できるだろうか? 無理だろう。
だが、以下のコードはまさにそれをしている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setBall(new Ball());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどう感じる?&lt;/p&gt;

&lt;p&gt;また、ボールを犬から取得できるだろうか?
まあ、できるかもしれない、もしその犬がボールを食べて、君が手術をするのであれば。
この場合、確かに、犬からボールを&amp;rdquo;get&amp;rdquo;できる。以下のコードが今話したようなことをやっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
Ball ball = dog.getBall();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またさらにばかげた例がこれだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setWeight(&amp;quot;23kg&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現実世界でこの処理がどんなか想像できるかな?&lt;/p&gt;

&lt;p&gt;君が毎日書いているコードはこれに似ているかい?
もしそうなら、君は手続き型プログラマだ。認めなさい。
David Westが彼の本の30ページでそれについて以下のように言っている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;成功した手続き型開発者が成功するオブジェクト開発者に移行するための最初のステップは、ロボトミーだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;君はロボトミーが必要か？
因みに、WestのObject Thinkingを読んでいた時、私には明らかに必要だったので受けた。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクト思考&#34;&gt;オブジェクト思考&lt;/h3&gt;

&lt;p&gt;オブジェクト思考を開始すると、君は即座にメソッド名を変更し、多分以下のコードに辿り着く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.take(new Ball());
Ball ball = dog.give();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今、私たちは犬を実際の動物として扱っている。この犬は、ボールを私たちから受け取り、頼めば返してくれる。
ここで特筆すべきは、この犬は &lt;code&gt;NULL&lt;/code&gt; を返すことはできない。犬は &lt;code&gt;NULL&lt;/code&gt; が何なのかなんて知らないからね。オブジェクト思考は即座に&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;NULL参照&lt;/a&gt;をコードから排除する。&lt;/p&gt;

&lt;p&gt;さらに、オブジェクト思考はオブジェクト不変性につながる。
犬の体重の例を、君は以下のように書き換えるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog(&amp;quot;23kg&amp;quot;);
int weight = dog.weight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この犬は不変な生きた有機体であり、だれも外からその体重やサイズや名前などを変更することはできない。
この犬は要求に応じて体重や名前を教えてくれる。
オブジェクトの中身を要求するパブリックメソッドには何の問題もないが、
こういったメソッドは&amp;rdquo;getter&amp;rdquo;ではなく、&amp;rdquo;get&amp;rdquo;というプレフィックスは決して付かない。
私たちは犬から何かを取ろうというのではない。犬から名前を取るのではなく、犬に名前を教えてくれるよう頼むのだ。
この違いが分かるかな?&lt;/p&gt;

&lt;p&gt;語義論の話をしているというわけでもない。
手続き型プログラミング思考とオブジェクト指向プログラミング思考とを区別しようというのだ。
手続き型プログラミングでは、私たちはデータを扱い、必要に応じてそれを操作したり取得したりセットしたり消したりする。
私たちはデータの責任者で、そのデータは単なる受動的なコンポーネントだ。
犬は私たちとは何の関係もなく、ただのデータホルダだ。それは生命を持っていない。
私たちはそれから必要なものを何でも自由に取得できるし、どんなデータでもセットすることができる。
これがCやCOBOLやPascalなどの手続き型言語のやりかただ。&lt;/p&gt;

&lt;p&gt;それに対して、真のオブジェクト指向の世界では、オブジェクトを生きた有機体のように扱い、
オブジェクトには生まれた日と死ぬ瞬間がある。また、君が望むなら、アイデンティティや性質を持たせてもいい。
犬にはデータの一部(例えば体重)をくれるよう頼むことができるし、犬はその情報を返してもよい。
ただ、この犬は能動的なコンポーネントであることを忘れてはいけない。
こちらの要求に対し、何をするかは犬が決めるのだ。&lt;/p&gt;

&lt;p&gt;以上が、getやsetで始まるメソッドをオブジェクトに持たせることが概念的に間違っている理由だ。
それは、多くの人々が主張するように、カプセル化を崩すということではない。
それは、君がオブジェクト的な思考をしているか、もしくは今だCOBOLをJavaのシンタックスで書いているかということだ。&lt;/p&gt;

&lt;p&gt;追伸: そうだ、君はこう尋ねるかもしれない。JavaBeans、JPA、JAXBなどのget/set表記に頼るJava APIはどうなんだ?
Rubyに付属するアクセッサ生成を簡易化する機能は?
ああ、それらは全て私たちにとっての不幸だ。
手続き型COBOLの原始的な世界に留まることは、真のオブジェクトからなる美しい世界を正しく理解し感謝するのに比べてはるかに簡単だ。&lt;/p&gt;

&lt;p&gt;追追伸: 言い忘れたが、setterを使った依存性注入もひどいアンチパターンだ。
それについてはいずれ書く。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;http://www.youtube.com/embed/WSgP85kr6eU&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Javaを始めた当初から今まで、Getter/Setterは絶対正義だと信じ、クラスを作れば無心でIDEの言いなりにそれを生成していたので、
この記事はなかなかに刺激的だった。(まあfinalなフィールドが好きなのでsetterの方はあまり作らなかったが。)&lt;/p&gt;

&lt;p&gt;ただ、記事の本質としては、Getter/Setterパターン、つまり、
オブジェクトのフィールドをprivateにし、メソッドを介してアクセスさせるようにすることで、実装の詳細を隠蔽し、
APIと分離させることを図るデザインパターンの技術的役割や目的を否定しているわけではなく、
オブジェクト指向の哲学的な部分にも則り、Getter/Setterパターンを真のオブジェクト界に向けて昇華させましょうと言っているように読める。&lt;/p&gt;

&lt;p&gt;犬とボールのやり取りをするコードのビフォーアフターはsetBall/getBallがtake/giveになっただけで、
これだけ見れば処理が変わるわけでもないし、コンパイラに言わせればどっちでもいいだろとなる。
ただ、プログラマにボールを無下につっこまれるビフォーの犬よりも、
自ら能動的にボールを受け取り返してくれるアフターの犬の方が幸せそうで愛らしいのは確かだ。
真のオブジェクト界を垣間見た気がする。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
