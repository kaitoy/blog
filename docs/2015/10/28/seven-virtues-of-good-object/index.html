<!DOCTYPE html>
<html lang="en-us">
    <head>
        <script data-ad-client="ca-pub-6244473643910448" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<meta name="google-site-verification" content="9qs7VjxtSrYMqw5OElxCdKv_gnssSRi6acB2iYlZnGA" />
<meta property="og:url" content="https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/">
<meta property="og:site_name" content="To Be Decided">
<meta name="twitter:card" content="summary"></meta>
<link rel="canonical" href="https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/">



  <meta property="og:type" content="article">
  <meta property="og:title" content="よいオブジェクトの七つの美徳 | To Be Decided">
  <title>よいオブジェクトの七つの美徳 | To Be Decided</title>
  <meta property="og:description" content="このエントリでは、Yegor Bugayenkoによる記事、Seven Virtues of a Good Objectを紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。">
  <meta name="description" content="このエントリでは、Yegor Bugayenkoによる記事、Seven Virtues of a Good Objectを紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。">
  <meta property="og:image" content="https://www.kaitoy.xyz/images/teamedio_logo.svg">



        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <style>

    html body {
        font-family: 'Noto Sans JP', sans-serif;
        background-color: #fefefe;
    }

    :root {
        --accent: #fa1e44;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://www.kaitoy.xyz/css/main.css">






<script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
<script>
  var webFontConfig = {
    google: {
      families: ['Noto Sans JP:400,700:japanese'],
      active: function() {
        sessionStorage.fonts = true;
      }
    },
    timeout: 3000
  };
  WebFont.load(webFontConfig);
</script>


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/monokai.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>

    

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>








<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.55.1" />
        
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=UA-65248565-1"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments)};
          gtag('js', new Date());

          gtag('config', 'UA-65248565-1');
        </script>
        
    </head>

    

    <body>
         
<div id="fb-root"></div>
<script async defer crossorigin="anonymous" src="https://connect.facebook.net/ja_JP/sdk.js#xfbml=1&version=v3.2"></script>

        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                <div class="navbar-header">

                    <a class="navbar-brand visible-xs" href="#">よいオブジェクトの七つの美徳</a>

                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>

                </div>

                <div class="collapse navbar-collapse">

                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/post/">Posts</a></li>
                            
                                <li><a href="/tags/">Tags</a></li>
                            
                                <li><a href="/about/">About</a></li>
                            
                        </ul>
                    

                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="mailto:kaitoy@pcap4j.org"><i class="fa fa-envelope-o"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://github.com/kaitoy"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/kaito-yamada-8558b913a"><i class="fa fa-linkedin"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.facebook.com/yamada.kaito.90"><i class="fa fa-facebook-square"></i></a></li>
                            
                        </ul>
                    

                </div>

            </div>

        </nav>


<main>

    <div class="single-post">
        <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2015/10/28/seven-virtues-of-good-object/">よいオブジェクトの七つの美徳</a></h4>
    <h5>Wed, Oct 28, 2015</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/oop"><kbd class="item-tag">oop</kbd></a>
    

</div>


        <div class="cover">
            <a href="/2015/10/28/seven-virtues-of-good-object/">
                <img src="https://www.kaitoy.xyz/images/teamedio_logo.svg" alt="よいオブジェクトの七つの美徳">
            </a>
        </div>

        
        <h4 class="page-header">Table of Contents</h4>
        <aside>
            <nav id="TableOfContents">
<ul>
<li><a href="#クラス-vs-オブジェクト">クラス vs オブジェクト</a></li>
<li><a href="#1-彼は実世界に存在している">1. 彼は実世界に存在している</a></li>
<li><a href="#2-彼は契約によって働く">2. 彼は契約によって働く</a></li>
<li><a href="#3-彼はユニーク">3. 彼はユニーク</a></li>
<li><a href="#4-彼は不変-immutable">4. 彼は不変(Immutable)</a></li>
<li><a href="#5-彼のクラスはスタティックなものをいっさいもたない">5. 彼のクラスはスタティックなものをいっさいもたない</a></li>
<li><a href="#6-彼の名前は職名ではない">6. 彼の名前は職名ではない</a></li>
<li><a href="#7-彼のクラスはfinalかabstractのどちらか">7. 彼のクラスはFinalかAbstractのどちらか</a></li>
</ul>
</nav>
        </aside>
        <hr>
        

        <br> <div class="text-justify"><p>このエントリでは、Yegor Bugayenkoによる記事、<a href="http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html">Seven Virtues of a Good Object</a>を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。</p>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6244473643910448"
     data-ad-slot="1845600530"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>


<hr />

<p>Martin Fowler<a href="http://martinfowler.com/bliki/InversionOfControl.html">曰く</a>、</p>

<blockquote>
<p>ライブラリは本質的には呼び出し可能な関数の集合で、最近は普通クラス内にまとめられる。</p>
</blockquote>

<p>クラス内にまとめられた関数?
失礼を承知で言わせてもらうが、これは間違っている。
そして、これはオブジェクト指向プログラミングにおいて、クラスに対する非常に一般的な誤解だ。
クラスは関数をまとめるものではないし、オブジェクトはデータ構造体ではない。</p>

<p>では、なにが適切なオブジェクトなのか?
どれが不適切なオブジェクトなのか?
その違いは何か?
これは論争を呼ぶ主題ではあるが、とても重要だ。
オブジェクトが何かを理解しなければ、オブジェクト指向ソフトウェアをどうやって書くんだ?
まあ、JavaやRubyなどのおかげで、書けることは書ける。
しかし、はたして良いものができるだろうか?
不幸にも、これは厳密な科学ではなく、様々な意見がある。
ここに、良いオブジェクトの特性を私なりにリストアップする。</p>

<h1 id="クラス-vs-オブジェクト">クラス vs オブジェクト</h1>

<p><img alt="good-object-1.png" src="/images/seven-virtues-of-good-object/good-object-1.png" width="300" style="margin: 0px auto; display: block;"></p>

<p>オブジェクトについて議論を始める前に、クラスとは何かを定義しよう。
それはオブジェクトが生まれる(インスタント化される)場所だ。
クラスの主な責任は、要求に応じて新しいオブジェクトを構築し、使われなくなったオブジェクトを破壊することだ。
クラスはその子供たちがどのように見えどのように振る舞うべきかを知っている。
言い換えれば、子供たちが従うべき契約を知っている。</p>

<p>クラスが「オブジェクトのテンプレート」であると言われることもある。(例えば<a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9_%28%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%29">Wikipediaにはそう書いてある</a>。)
この定義はクラスを受動的なポジションに置いているので正しくない。
この定義は、だれかがテンプレートを取得してそこからオブジェクトを構築するということを想定している。
これは、技術的には正しいかもしれないが、概念的には間違っている。
クラスとその子供たちだけが居るのであって、他の誰も関係すべきではない。
あるオブジェクトがクラスに他のオブジェクトを作るように頼み、そのクラスがオブジェクトを構築する。それだけだ。
RubyはJavaやC++に比べてこの概念をかなりうまく表現している。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">photo = <span style="color:#40ffff">File</span>.new(<span style="color:#ed9d13">&#39;/tmp/photo.png&#39;</span>)</code></pre></div>
<p><code>photo</code>オブジェクトは<code>File</code>クラスによって構築される。(<code>new</code>はそのクラスへのエントリポイント。)
オブジェクトは、いったん構築されると、自身に基づいて行動する。
オブジェクトは、自身を誰が構築したかとか、何人兄弟姉妹がいるかとかを知っているべきではない。
そう、<a href="https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_%28%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%29">リフレクション</a>は酷いアイデアだと言っている。
それについては他の記事で詳しく書くとして、ここでは、オブジェクトについてと、その最高と最悪の両面について話そう。</p>

<h1 id="1-彼は実世界に存在している">1. 彼は実世界に存在している</h1>

<p><img alt="good-object-2.png" src="/images/seven-virtues-of-good-object/good-object-2.png" width="300" style="margin: 0px auto; display: block;"></p>

<p>まず第一に、オブジェクトは生きた有機体だ。
もっと言えば、オブジェクトは<a href="https://ja.wikipedia.org/wiki/%E6%93%AC%E4%BA%BA%E5%8C%96">擬人化</a>されるべきだ。
つまり、人間(もしくは、君がより好むならペット)のように扱われるべきだ。
基本的にこれは、オブジェクトはデータ構造体や関数の集合ではないということを意味している。
代わりに、オブジェクトは独立したエンティティで、それ自身のライフサイクル、振る舞い、性質を持つ。</p>

<p>従業員、部署、HTTPリクエスト、MySQLのテーブル、ファイルの行、ファイルそのもの、これらは適切なオブジェクトだ。
なぜならこれらは、ソフトウェアを停止した時でも実世界に存在しているから。
より正確には、オブジェクトは実世界のモノの表現のひとつだ。
オブジェクトは実世界のモノと他のオブジェクトとの間のプロキシだ。
そのようなモノが存在しなければ、明らかにオブジェクトは存在しない。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">photo = <span style="color:#40ffff">File</span>.new(<span style="color:#ed9d13">&#39;/tmp/photo.png&#39;</span>)
<span style="color:#24909d">puts</span> photo.width()</code></pre></div>
<p>この例では、<code>File</code>に新しいオブジェクト<code>photo</code>を構築するよう頼んでいる。
<code>photo</code>はディスク上の実際のファイルの表現となる。
ファイルもまた仮想のもので、コンピュータが起動している間だけ存在すると言う人がいるかもしれない。
それには私も同意し、「実世界」の定義を次のように改善しよう。
オブジェクトが住むプログラムの範囲外に存在する全てのもの。
ディスク上のファイルはプログラムの範囲外にあり、その表現をプログラム内に作成することは完全に正しいことと言える。</p>

<p>コントローラ、パーサ、フィルタ、バリデータ、サービスロケータ、シングルトン、ファクトリー、これれは良いオブジェクトではない。(そう、ほとんどのGoFパターンはアンチパターンだ!)
これらはソフトウェアの外側、実世界に存在していない。
他のオブジェクト同士を結びつけるためだけに考案されたものだ。
人工的で偽のモノだ。何も表現していない。
真面目な話、XMLパーサ、これが表現するものはなんだ?
何もない。</p>

<p>上記オブジェクトのいくつかは名前を変えれば良いオブジェクトになる。他のものは決して存在を許されない。
例えば、XMLパーサは「パース可能なXML」と改名でき、プログラム外に存在するXMLドキュメントを表現するようになる。</p>

<p>常に、「このオブジェクトの背後にある実世界のエンティティは何か?」を自問しよう。
もし回答が見つからなければ、リファクタリングを考えるときだ。</p>

<h1 id="2-彼は契約によって働く">2. 彼は契約によって働く</h1>

<p><img alt="good-object-3.png" src="/images/seven-virtues-of-good-object/good-object-3.png" width="300" style="margin: 0px auto; display: block;"></p>

<p>良いオブジェクトは常に契約によって働く。
彼は、個人的な実力ではなく、契約に従うということを理由に雇われることを期待している。
一方、我々がオブジェクトを雇うとき、差別待遇をして、特定のクラスの特定のオブジェクトが我々のために働いてくれると期待してはいけない。
どんなオブジェクトも契約通りのことをすると考えるべきだ。
オブジェクトが期待通りの働きをしている限りは、彼の出生や性別や信仰に興味を持つべきではない。</p>

<p>例えば、ある写真をスクリーンに表示したいとする。その写真はPNGフォーマットのファイルから読みこまれる。
私は<code>DataFile</code>クラスのオブジェクトと契約を結び、その画像のバイナリコンテンツをくれるよう頼む。</p>

<p>しかし待ってほしい。私はそのデータが厳密にどこから来るかを気にするだろうか?
ディスク上のファイル、HTTPリクエスト、Dropbox上のドキュメントかもしれないが、実際私は気にしない。
私が気にするのは、オブジェクトがPNGデータが入ったバイト配列をくれるということだけだ。
つまり、私が結ぶ契約は以下のようなものだ。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">interface</span> <span style="color:#447fcf;text-decoration:underline">Binary</span> {
  <span style="color:#6ab825;font-weight:bold">byte</span>[] <span style="color:#447fcf">read</span>();
}</code></pre></div>
<p>この場合、(DataFileクラスだけでなく)どんなクラスのどんなオブジェクトでも私のもとで働くことができる。
オブジェクトが働く資格を得るためにすべきは、<code>Binary</code>インターフェースを実装することにより、契約に従うということだけだ。</p>

<p>この際のルールは単純で、良いオブジェクトの全てのpublicメソッドは、インターフェースのものを実装すべきだということだ。
もしオブジェクトがインターフェースから継承していないpublicメソッドを持っていたら、それはダメな設計だ。</p>

<p>これには実用的な理由が二つある。
第一に、無契約で働いているオブジェクトは、ユニットテストで使うモックが作れない。
第二に、無契約なオブジェクトは<a href="https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">デコレータ</a>で拡張できない。</p>

<h1 id="3-彼はユニーク">3. 彼はユニーク</h1>

<p>良いオブジェクトは常に、ユニークであるために何かを内包しているべきだ。
何も内包していないと、そのオブジェクトとまったく同じクローンが存在し得ることになる。私はこれはダメなことだと考えている。
以下がクローンが存在し得る悪いオブジェクトの例。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">HTTPStatus</span> <span style="color:#6ab825;font-weight:bold">implements</span> Status {
  <span style="color:#6ab825;font-weight:bold">private</span> URL page = <span style="color:#6ab825;font-weight:bold">new</span> URL(<span style="color:#ed9d13">&#34;http://www.google.com&#34;</span>);
  <span style="color:#ffa500">@Override</span>
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">read</span>() <span style="color:#6ab825;font-weight:bold">throws</span> IOException {
    <span style="color:#6ab825;font-weight:bold">return</span> HttpURLConnection.<span style="color:#bbb">class</span>.<span style="color:#bbb">cast</span>(
      <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">page</span>.<span style="color:#bbb">openConnection</span>()
    ).<span style="color:#bbb">getResponseCode</span>();
  }
}</code></pre></div>
<p><code>HTTPStatus</code>クラスのインスタンスは複数作れ、それら全ては互いに等しい。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">first = <span style="color:#6ab825;font-weight:bold">new</span> HTTPStatus();
second = <span style="color:#6ab825;font-weight:bold">new</span> HTTPStatus();
<span style="color:#6ab825;font-weight:bold">assert</span> first.<span style="color:#bbb">equals</span>(second);</code></pre></div>
<p>明らかにユーティリティクラスは、スタティックメソッドだけを持つので、よいオブジェクトにインスタンス化できない。
より一般的には、ユーティリティクラスはこの記事で述べられているどのメリットも持たず、「クラス」と呼ぶことさえできない。
ユーティリティクラスは単純にオブジェクトパラダイムの酷い乱用で、モダンなオブジェクト指向言語の作者がスタティックメソッドを有効にしたせいで存在している。</p>

<h1 id="4-彼は不変-immutable">4. 彼は不変(Immutable)</h1>

<p>良いオブジェクトは内包する状態を決して変えるべきではない。
オブジェクトは実世界のエンティティの表現であることを思い出してほしい。このエンティティは、オブジェクトが存続する間は変化しないはずだ。
言い換えれば、オブジェクトはそれが表すエンティティに決して背いてはいけない。
オブジェクトがその所有者を変化させることはないよね。</p>

<p>不変であることが、全てのメソッドが常に同じ値を返すことを意味するわけではないことに注意してほしい。
むしろ、良い不変オブジェクトはとても動的だ。
しかし、それは内部状態を変えることはない。例えば、</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ffa500">@Immutable</span>
<span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">HTTPStatus</span> <span style="color:#6ab825;font-weight:bold">implements</span> Status {
  <span style="color:#6ab825;font-weight:bold">private</span> URL page;
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#447fcf">HTTPStatus</span>(URL url) {
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">page</span> = url;
  }
  <span style="color:#ffa500">@Override</span>
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">read</span>() <span style="color:#6ab825;font-weight:bold">throws</span> IOException {
    <span style="color:#6ab825;font-weight:bold">return</span> HttpURLConnection.<span style="color:#bbb">class</span>.<span style="color:#bbb">cast</span>(
      <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">page</span>.<span style="color:#bbb">openConnection</span>()
    ).<span style="color:#bbb">getResponseCode</span>();
  }
}</code></pre></div>
<p><code>read()</code>メソッドは異なる値を返す可能性があるが、このオブジェクトは不変だ。
ある一つのウェブページを指し、他のどこを指すこともない。
内包する状態を決して変えないし、表現しているURLに背くこともない。</p>

<p>なぜこの不変性が美徳なのか?
次の記事で詳細を説明している: <a href="http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">オブジェクトは不変であるべきだ</a>。
要するに、不変オブジェクトが優れている理由は、</p>

<ul>
<li>不変オブジェクトは簡単に構築、テスト、使用できる。</li>
<li>真の不変オブジェクトは常にスレッドセーフ。</li>
<li>時間的結合(訳注: コードの実行順の暗黙的な制約)を回避するのに役立つ。</li>
<li>不変オブジェクトを使っても副作用がおきない。(防御的コピー無)</li>
<li>エラー発生時の原子性が保証されている。</li>
<li>キャッシュしやすい。</li>
<li><a href="https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/">NULL参照</a>を防ぐ。</li>
</ul>

<p>もちろん、良いオブジェクトは<a href="https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/">setter</a>をもたない。セッターはオブジェクトの状態を変え得るし、URLに背くことを強要する。
言い換えると、<code>HTTPStatus</code>で<code>setURL()</code>メソッドを実装することは酷い間違いとなる。</p>

<p>その他にも、不変オブジェクトを使うことで、設計は必然的に凝集度の高いものになり、また密で理解しやすいものになる。
これについては<a href="http://www.yegor256.com/2014/11/07/how-immutability-helps.html">不変性がどう役に立つか</a>という記事で説明している。</p>

<h1 id="5-彼のクラスはスタティックなものをいっさいもたない">5. 彼のクラスはスタティックなものをいっさいもたない</h1>

<p>スタティックメソッドは、オブジェクトではなくクラスの挙動を実装する。
<code>File</code>クラスがあり、その子供が<code>size()</code>メソッドを持つとする。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">File</span> <span style="color:#6ab825;font-weight:bold">implements</span> Measurable {
  <span style="color:#ffa500">@Override</span>
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">size</span>() {
    <span style="color:#999;font-style:italic">// calculate the size of the file and return
</span><span style="color:#999;font-style:italic"></span>  }
}</code></pre></div>
<p>ここまではよい。<code>size()</code>メソッドは<code>Measurable</code>契約によって存在し、<code>File</code>クラスの全てのオブジェクトはそのサイズを測ることができる。
このクラスを、代わりにスタティックメソッドを持つように実装するのは酷い間違いだ。
(こうした設計は<a href="http://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html">ユーティリティクラス</a>と呼ばれ、JavaやRubyなどのほぼ全てのOOP言語でとても人気だ。)</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#999;font-style:italic">// TERRIBLE DESIGN, DON&#39;T USE!
</span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">File</span> {
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">size</span>(String file) {
    <span style="color:#999;font-style:italic">// calculate the size of the file and return
</span><span style="color:#999;font-style:italic"></span>  }
}</code></pre></div>
<p>この設計はオブジェクト指向パラダイムの真逆を行く。
なぜかって?
なぜならスタティックメソッドはオブジェクト指向プログラミングを「クラス指向」プログラミングに変えてしまうからだ。
この、<code>size()</code>メソッドは、オブジェクトではなくクラスの挙動を公開する。
これの何が間違っているかと言われるかもしれない。
なぜオブジェクトとクラス両方をコード中で第一級市民として使えないのか?
なぜ両方ともがメソッドやプロパティを持てないのか?</p>

<p>この問題は、クラス指向プログラミングでは、分離ができなくなるというものだ。
複雑な問題をブレイクダウンできなくなる。
なぜなら、プログラム全体の中でクラスのインスタンスがたったひとつしか存在しないからだ。
OOPの力は、オブジェクトをスコープを分離するための道具として使えることだ。
あるオブジェクトをメソッド中でインスタンス化したとき、そのオブジェクトは特定のタスク専任となる。
そのオブジェクトは、メソッド周辺の他のオブジェクトから完璧に分離されている。
このオブジェクトはメソッドスコープのローカル変数だ。
スタティックメソッドを持つクラスは、どこで使うにしろ常にグローバル変数だ。
このため、この変数とのやりとりを分離することはできない。</p>

<p>オブジェクト指向の原理に概念的に反しているということの他にも、パブリックなスタティックメソッドは実用的な欠点も持っている。</p>

<p>第一に、モックを作れない。
(いや、<a href="https://code.google.com/p/powermock/">PowerMock</a>を使うことはできる。が、これはJavaプロジェクトで取り得る決断の中で最悪なものとなるだろう。。。私はそれを数年前にやってしまった。)</p>

<p>第二に、定義上スレッドセーフではない。なぜなら、常にスタティック変数とともに動くからで、スタティック変数は全てのスレッドからアクセスできるからだ。
スタティックメソッドをスレッドセーフに作ることもできるが、この場合常に明示的な同期が必要になる。</p>

<p>パブリックなスタティックメソッドを見つけたら常に、即座に書き直すべきだ。
スタティック(グローバル)変数がどれだけ酷いかについては説明したくもない。それは明らかだ。</p>

<h1 id="6-彼の名前は職名ではない">6. 彼の名前は職名ではない</h1>

<p><img alt="good-object-4.png" src="/images/seven-virtues-of-good-object/good-object-4.png" width="300" style="margin: 0px auto; display: block;"></p>

<p>オブジェクト名はそのオブジェクトが何であるかを示すべきで、何をするかを示すべきではない。
実世界の物に名付けるのと同様に。
ページ集めではなく本、水入れではなくカップ、体飾りではなくTシャツ。
もちろん、プリンタやコンピュータのような例外はあるが、これらはこの記事を読まなかった人々によってごく最近発明されたものだ。</p>

<p>例えば、次のような名前はその持ち主が何であるかを示す。
りんご、ファイル、HTTPリクエスト群、ソケット、XMLドキュメント、ユーザリスト、正規表現、整数、PostgreSQLテーブル、Jeffrey Lebowski。
適切な名前はいつも小さい絵として描ける。正規表現でさえ描ける。</p>

<p>逆に、次に挙げる名前の例は持ち主が何をするかを示す。
ファイルリーダ、テキストパーサ、URLバリデータ、XMLプリンタ、サービスロケータ、シングルトン、スクリプトランナ、Javaプログラマ。
これらの絵を描けるか?
描けない。
こういう名前は良いオブジェクトには適さない。
これらは酷い設計につながる酷い名前だ。</p>

<p>一般的に、「-er」で終わる名前を避けるべきだ。そのほとんどはダメなものだ。</p>

<p>「<code>FileReader</code>の代わりは何」と疑問に思うだろう。
よりよい名前は何?</p>

<p>ええと、我々は既に<code>File</code>を持っていて、それは実世界のディスク上のファイルの表現だ。
この表現は十分に強力ではない。なぜなら、それはファイルの内容を読む方法を知らないからだ。
その能力を持ったより強力なものを作りたい。
何という名前にする?
名前は、その持ち主が何をするかではなく、何であるかを示すべきであるということを思い出してほしい。
持ち主は何か?
データを持ったファイルだ。ただのファイルではなく。
<code>File</code>っぽいけど、もっと洗練されたものだ。データを持った。
なので、<code>FileWithData</code>、もしくは単に<code>DataFile</code>というのはどうだろう?</p>

<p>同様のロジックを他の全ての名前にも適用すべきだ。
常に何をするかよりも何であるかを考えよう。
オブジェクトに職名ではなく、リアルで、意味のある名前を付けよう。</p>

<p>より詳しくは「<a href="http://www.yegor256.com/2015/03/09/objects-end-with-er.html">-ERで終わるオブジェクトを作るな</a>」を参照。</p>

<h1 id="7-彼のクラスはfinalかabstractのどちらか">7. 彼のクラスはFinalかAbstractのどちらか</h1>

<p><img alt="good-object-5.png" src="/images/seven-virtues-of-good-object/good-object-5.png" width="300" style="margin: 0px auto; display: block;"></p>

<p>良いオブジェクトはfinalまたはabstractなクラスから生成される。
<code>final</code>クラスは継承によって拡張できないクラスだ。
<code>abstract</code>クラスは子供を持てないクラスだ。
簡単に言うと、クラスは、「君は僕を決して壊せない。僕はブラックボックスだ。」か、または「僕は壊れている。直してから使ってくれ。」のどちらかを言う。</p>

<p>その間には何もない。finalクラスはブラックボックスで、あらゆる意味で変更できない。
オブジェクトは現状のままで働き、君はそれを使うか捨てるかしかしない。
そのプロパティを継承する別のクラスを作ることはできない。
これは<code>final</code>修飾子によって禁止されている。
そのようなfinalクラスを拡張する唯一の手段は、その子供をデコレートすることだ。
例えば、(上記)<code>HTTPStatus</code>クラスがあり、それを気に入らなかったとする。
いやまあ好きではあるけど、私にとっては十分強力ではないんだ。
HTTPステータスが400より大きい場合に例外を投げて欲しい。
<code>read()</code>メソッドにもう少し処理をしてもらいたい。
古風なやり方は、そのクラスを拡張してメソッドを上書きすることだ。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">OnlyValidStatus</span> <span style="color:#6ab825;font-weight:bold">extends</span> HTTPStatus {
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#447fcf">OnlyValidStatus</span>(URL url) {
    <span style="color:#6ab825;font-weight:bold">super</span>(url);
  }
  <span style="color:#ffa500">@Override</span>
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">read</span>() <span style="color:#6ab825;font-weight:bold">throws</span> IOException {
    <span style="color:#6ab825;font-weight:bold">int</span> code = <span style="color:#6ab825;font-weight:bold">super</span>.<span style="color:#bbb">read</span>();
    <span style="color:#6ab825;font-weight:bold">if</span> (code &gt; 400) {
      <span style="color:#6ab825;font-weight:bold">throw</span> <span style="color:#6ab825;font-weight:bold">new</span> RuntimException(<span style="color:#ed9d13">&#34;unsuccessful HTTP code&#34;</span>);
    }
    <span style="color:#6ab825;font-weight:bold">return</span> code;
  }
}</code></pre></div>
<p>なぜこれではダメなのか?
メソッドのひとつをオーバーライドすることで親クラス全体のロジックを壊す危険があるので全然ダメだ。
<code>read()</code>を子クラスでオーバーライドしたら、親クラスから来る全てのメソッドがその新しいやつを使うことになる、ということを忘れないで欲しい。
これは、文字通り新しい「実装のかけら」をクラスの内部に挿入するということだ。
哲学的に言って、これは反則だ。</p>

<p>一方、finalクラスを拡張するためには、それをブラックボックスのように扱い、他の実装でデコレートする必要がある。(<a href="https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3">デコレータパターン</a>)</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">OnlyValidStatus</span> <span style="color:#6ab825;font-weight:bold">implements</span> Status {
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> Status origin;
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#447fcf">OnlyValidStatus</span>(Status status) {
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">origin</span> = status;
  }
  <span style="color:#ffa500">@Override</span>
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">read</span>() <span style="color:#6ab825;font-weight:bold">throws</span> IOException {
    <span style="color:#6ab825;font-weight:bold">int</span> code = <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">origin</span>.<span style="color:#bbb">read</span>();
    <span style="color:#6ab825;font-weight:bold">if</span> (code &gt; 400) {
      <span style="color:#6ab825;font-weight:bold">throw</span> <span style="color:#6ab825;font-weight:bold">new</span> RuntimException(<span style="color:#ed9d13">&#34;unsuccessful HTTP code&#34;</span>);
    }
    <span style="color:#6ab825;font-weight:bold">return</span> code;
  }
}</code></pre></div>
<p>このクラスがもともとと同じインターフェース、<code>Status</code>を実装していることに注目して欲しい。
<code>HTTPStatus</code>のインスタンスはコンストラクタを通して渡され、内包される。
そして、全てのメソッド呼び出しは割り込まれ、必要に応じて独自に実装される。
この設計だと、もとのオブジェクトをブラックボックスとして扱い、その内部のロジックには決して触らない。</p>

<p>もし<code>final</code>というキーワードを使わなかったら、だれでも(君自身でも)そのクラスを拡張し、損なうことができる。(よって<code>final</code>でないクラスは悪い設計だ。)</p>

<p>abstractクラスは真反対なケースだ。それは不完全で、そのままでは使えないことを示している。
独自の実装ロジックを挿入する必要があるが、それは許可された部分だけに限られる。
この部分は<code>abstract</code>メソッドとして明示的に示されている。
例えば、<code>HTTPStatus</code>は以下のようになる。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">abstract</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">ValidatedHTTPStatus</span> <span style="color:#6ab825;font-weight:bold">implements</span> Status {
  <span style="color:#ffa500">@Override</span>
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">read</span>() <span style="color:#6ab825;font-weight:bold">throws</span> IOException {
    <span style="color:#6ab825;font-weight:bold">int</span> code = <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">origin</span>.<span style="color:#bbb">read</span>();
    <span style="color:#6ab825;font-weight:bold">if</span> (!<span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">isValid</span>()) {
      <span style="color:#6ab825;font-weight:bold">throw</span> <span style="color:#6ab825;font-weight:bold">new</span> RuntimException(<span style="color:#ed9d13">&#34;unsuccessful HTTP code&#34;</span>);
    }
    <span style="color:#6ab825;font-weight:bold">return</span> code;
  }
  <span style="color:#6ab825;font-weight:bold">protected</span> <span style="color:#6ab825;font-weight:bold">abstract</span> <span style="color:#6ab825;font-weight:bold">boolean</span> <span style="color:#447fcf">isValid</span>();
}</code></pre></div>
<p>見て分かるとおり、このクラスはHTTPコードを検証する方法を知らないので、継承して<code>isValid()</code>をオーバーライドすることによってそのロジックを挿入することを期待している。
この継承は親クラスを損なわない。他の全メソッドが<code>final</code>によって守られているからだ。(メソッドの修飾子に注目してくれ。)
つまり、このクラスは攻撃への備えがしてあって、完全に防御している。</p>

<p>まとめると、クラスは<code>final</code>か<code>abstract</code>のどちらかであるべきで、その中間はない。</p>

<hr />

<p>以上がYegorの記事。</p>

<p>この記事は、オブジェクト指向原理主義者であるYegorが彼のオブジェクト観の概論を書いたものだ。
彼のオブジェクトに対するとんがった信念が読み取れる。</p>

<p>記事の内容をまとめると、</p>

<ol>
<li>オブジェクトは何か実体と対応していないといけない。</li>
<li>クラスはインターフェースを実装していないといけない。</li>
<li>オブジェクトはユニーク性を保証するフィールドを持っていないといけない。</li>
<li>オブジェクトは不変でないといけない</li>
<li>クラスはスタティックメソッド/フィールドを持っていてはいけない。</li>
<li>erで終わるクラス名を使ってはいけない。</li>
<li>クラスにはfinalかabstractが付いていないといけない。</li>
</ol>

<p>#1と#6はだいたい同じことを主張していて、その内容は実用的というよりかは哲学的だ。
敢えて実用面について言えば、同じ哲学を共有しているチームがこの主張に従えば、そのチーム内でコードの可読性や保守性が上がるというメリットがあると考えられる。
が、オブジェクト指向原理主義よりもGoFのデザインパターンの方がはるかに広く深く浸透しているので、このメリットはあまりありがたみが無い。
私はオブジェクト真理教に入信したわけではないので、これからもControllerとかFactoryとかServiceとかいうクラスを書くだろう。</p>

<p>#2については、言っていることは分かるしインターフェースのメリットもよく理解しているつもりだが、わんさとクラスを書かないといけないのに逐一インターフェースまで書いてられるかというのが本音だ。
実際には、モックを書いたり多態したいとき、または将来そうなると天啓があったとき、つまりは必要に応じてインターフェースを書くのであって、なんでもかんでも書いていたら書くのも読むのもいたずらに大変になってしまう。(そういう方針をとって開発者から不満が噴出したプロジェクトが身近にあったと聞いた。)
Yegorのプロジェクトでは全てのクラスがインターフェースを実装しているんだろうか。信じ難い。</p>

<p>#3も、ちょっと実用的な雰囲気の主張だが、よくみるとこれに従うことでどんなメリットがあるかとか、従わないことでどんな問題が発生するかとかが書いてない。
哲学的な主張か。
私が開発している<a href="https://github.com/kaitoy/pcap4j">Pcap4J</a>には、ネットワークパケットを表すクラスが多数あるが、それらからインスタンス化されるオブジェクトは必ずしもユニークではない。
例えば、Ethernetヘッダを表すクラスである<a href="https://github.com/kaitoy/pcap4j/blob/master/pcap4j-core/src/main/java/org/pcap4j/packet/EthernetPacket.java">EthernetHeader</a>は、Ethernetパケットの送り元と送り先が同じで、且つレイヤ3のプロトコルが同じなら<code>equals()</code>が<code>true</code>を返す。
つまり、実世界で異なるパケットのヘッダでも、Java世界では同一とみなされることがよくある。
この実装で実用上困ることは無い気がするけど、オブジェクト指向原理主義に照らすとダメってことか?
<code>UUID</code>みたいなフィールドでも加えればいいのか?
そんなフィールドはEthernetヘッダにはないのに?</p>

<p>#4は好き。ただ全てに適用できるかというと疑問。不変オブジェクトで、例えば<a href="http://qiita.com/disc99/items/840cf9936687f97a482b#effective-java-builder">Builderパターン(GoFじゃなくてEffective Javaの方)</a>が対応している問題をどう解決するんだろう?
すごく頑張ってYegorの言いつけを守りながら、Builderパターンっぽくインスタンス化できるEthernetHeader(という名のEthernetヘッダフィールドの値を保持するクラス)を書いてみたら以下のようになった。</p>

<p>まず、一般的なヘッダを表す<code>Header</code>クラスを作る。不変で、<code>id</code>という適当なフィールドを持つ。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">package</span> <span style="color:#447fcf;text-decoration:underline">test</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.util.MacAddress</span>;

<span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">Header</span> {
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">int</span> id;

  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#447fcf">Header</span>(<span style="color:#6ab825;font-weight:bold">int</span> id) {
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">id</span> = id;
  }

  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">getId</span>() { <span style="color:#6ab825;font-weight:bold">return</span> id; }

  <span style="color:#6ab825;font-weight:bold">public</span> DstAddrSetEthernetHeader <span style="color:#447fcf">dstAddr</span>(MacAddress dstAddr) {
    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">new</span> DstAddrSetEthernetHeader(<span style="color:#6ab825;font-weight:bold">this</span>, dstAddr);
  }
}</code></pre></div>
<p>次に、<code>Header</code>をデコレートして拡張し、<code>dstAddr</code>というフィールドを追加したもちろん不変なクラス<code>DstAddrSetEthernetHeader</code>(dstAddrだけがセットされたEthernetヘッダ)を作る。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">package</span> <span style="color:#447fcf;text-decoration:underline">test</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.util.MacAddress</span>;

<span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">DstAddrSetEthernetHeader</span> {
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> Header header;
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> MacAddress dstAddr;

  DstAddrSetEthernetHeader(Header header, MacAddress dstAddr) {
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">header</span> = header;
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">dstAddr</span> = dstAddr;
  }

  <span style="color:#6ab825;font-weight:bold">public</span> MacAddress <span style="color:#447fcf">getDstAddr</span>() { <span style="color:#6ab825;font-weight:bold">return</span> dstAddr; }

  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">getId</span>() { <span style="color:#6ab825;font-weight:bold">return</span> header.<span style="color:#bbb">getId</span>(); }

  <span style="color:#6ab825;font-weight:bold">public</span> DstAddrAndSrcAddrSetEthernetHeader <span style="color:#447fcf">srcAddr</span>(MacAddress srcAddr) {
    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">new</span> DstAddrAndSrcAddrSetEthernetHeader(<span style="color:#6ab825;font-weight:bold">this</span>, srcAddr);
  }
}</code></pre></div>
<p>さらに<code>DstAddrSetEthernetHeader</code>をデコレートして拡張し、<code>srcAddr</code>というフィールドを追加したもちろん不変なクラス<code>DstAddrAndSrcAddrSetEthernetHeader</code>(dstAddrとsrcAddrがセットされたEthernetヘッダ)を作る。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">package</span> <span style="color:#447fcf;text-decoration:underline">test</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.packet.namednumber.EtherType</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.util.MacAddress</span>;

<span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">DstAddrAndSrcAddrSetEthernetHeader</span> {
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> DstAddrSetEthernetHeader header;
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> MacAddress srcAddr;

  DstAddrAndSrcAddrSetEthernetHeader(DstAddrSetEthernetHeader header, MacAddress srcAddr) {
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">header</span> = header;
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">srcAddr</span> = srcAddr;
  }

  <span style="color:#6ab825;font-weight:bold">public</span> MacAddress <span style="color:#447fcf">getSrcAddr</span>() { <span style="color:#6ab825;font-weight:bold">return</span> srcAddr; }

  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">int</span> <span style="color:#447fcf">getId</span>() { <span style="color:#6ab825;font-weight:bold">return</span> header.<span style="color:#bbb">getId</span>(); }

  <span style="color:#6ab825;font-weight:bold">public</span> MacAddress <span style="color:#447fcf">getDstAddr</span>() { <span style="color:#6ab825;font-weight:bold">return</span> header.<span style="color:#bbb">getDstAddr</span>(); }

  <span style="color:#6ab825;font-weight:bold">public</span> EthernetHeader <span style="color:#447fcf">type</span>(EtherType type) {
    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">new</span> EthernetHeader(<span style="color:#6ab825;font-weight:bold">this</span>, type);
  }
}</code></pre></div>
<p>やっとビルド対象である<code>EthernetHeader</code>を書く。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">package</span> <span style="color:#447fcf;text-decoration:underline">test</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.packet.namednumber.EtherType</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.util.MacAddress</span>;

<span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">EthernetHeader</span> {
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> <span style="color:#6ab825;font-weight:bold">int</span> id;
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> MacAddress dstAddr;
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> MacAddress srcAddr;
  <span style="color:#6ab825;font-weight:bold">private</span> <span style="color:#6ab825;font-weight:bold">final</span> EtherType type;

  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#447fcf">EthernetHeader</span>(DstAddrAndSrcAddrSetEthernetHeader header, EtherType type) {
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">id</span> = header.<span style="color:#bbb">getId</span>();
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">dstAddr</span> = header.<span style="color:#bbb">getDstAddr</span>();
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">srcAddr</span> = header.<span style="color:#bbb">getSrcAddr</span>();
    <span style="color:#6ab825;font-weight:bold">this</span>.<span style="color:#bbb">type</span> = type;
  }
}</code></pre></div>
<p>上記4つのクラスを使って、次のようにBuilderパターンっぽいことができる。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#6ab825;font-weight:bold">package</span> <span style="color:#447fcf;text-decoration:underline">test</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.packet.namednumber.EtherType</span>;
<span style="color:#6ab825;font-weight:bold">import</span> <span style="color:#447fcf;text-decoration:underline">org.pcap4j.util.MacAddress</span>;

<span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">class</span> <span style="color:#447fcf;text-decoration:underline">ImmutableBuilderSample</span> {
  <span style="color:#6ab825;font-weight:bold">public</span> <span style="color:#6ab825;font-weight:bold">static</span> <span style="color:#6ab825;font-weight:bold">void</span> <span style="color:#447fcf">main</span>(String[] args) {
    EthernetHeader header
      = <span style="color:#6ab825;font-weight:bold">new</span> Header(1)
          .<span style="color:#bbb">dstAddr</span>(MacAddress.<span style="color:#bbb">getByName</span>(<span style="color:#ed9d13">&#34;aa:bb:cc:dd:ee:ff&#34;</span>))
          .<span style="color:#bbb">srcAddr</span>(MacAddress.<span style="color:#bbb">getByName</span>(<span style="color:#ed9d13">&#34;11:22:33:44:55:66&#34;</span>))
          .<span style="color:#bbb">type</span>(EtherType.<span style="color:#bbb">IPV4</span>);
  }
}</code></pre></div>
<p>パラメータの設定順を自由にしたければ、さらに<code>SrcAddrSetEthernetHeader</code>とか<code>TypeSetEthernetHeader</code>とか<code>DstAddrAndTypeSetEthernetHeader</code>とか作らないといけない。これは疲れる。
沢山オブジェクトを作るのに、最後の<code>EthernetHeader</code>以外のが使い捨てというのも辛い。
<code>EthernetHeader</code>は3つしかフィールドがないからまだましな方なんだが。</p>

<p>私は、不変クラスはスレッドセーフにすることを主目的として作る。
普通アプリケーションはマルチスレッドになるんだから、基本的にクラスは不変を目指して作り、どうしても可変にしたくなったときは内部で同期してスレッドセーフに保つか、外で同期してもらうか、またはシングルスレッドで使ってもらうかを考える。
上記のBuilderなんかは可変フィールドを使わないとまともに作れないし、その性質上マルチスレッドで使うことは普通ないし、無理に不変にする必要はなかろう。</p>

<p>#5については、Yegorが問題視していることにはだいたい納得できる。(哲学的な部分以外は。。。)
しかし、Yegorが、スタティックメソッドが可変フィールドを参照することを前提に話しているところにひっかかる。
私はpublic staticなフィールドをfinal無しで書くことはないし、スタティックメソッドは殆どの場合引数だけを使うように書き、たまにfinalなフィールドを参照させるくらいだ。(ちょっとあやしいけど多分。)
世のユーティリティクラスもだいたいそんな感じで書かれているんじゃなかろうか。
この場合、スレッドセーフじゃないという問題点は出ないし、問題の分離も、スタティックフィールドでデータを共有するわけではないのでちゃんとできる。
モックはできないけど、ユーティリティクラスのモックを書きたいことなんてあるだろうか?</p>

<p>#7は同意。abstractじゃないメソッドをオーバーライドするのって気持ち悪いし。
ところでデコレータパターンってすごい便利で汎用性高いと思うんだけど、いざというときに思いつかないようで、あんまり使ったことないな。</p>

<p>以上ひとつひとつの主張について考えてみたけど、反感が多いな。
これはオブジェクト真理教に入信するメリットが見えてこないからだろう。
もともとOOPっていうのは、手続き型言語が隆盛な時代の関数を使った処理の分離という考え方を押し進め、処理と処理対象データを一緒にして分離するという実用的で技術的な目的のもとに生まれたもので、オブジェクトは実世界のモノを表現しなきゃいけないってのは後付けの哲学だ。
OOPはそれを共通認識として発展したわけではないので、極端な哲学に縛られていると長い歴史に揉まれた強力なノウハウの多くが使えなくなってしまう。
GoFのデザインパターンを否定するなら、GoFが解決した問題への別解を提示してくれないとなかなか受け入れがたい。</p></div>

        <section class="share-buttons">
          <div class="share-button">
            <div class="fb-share-button" data-href="https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/" data-layout="box_count" data-size="small"><a target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.kaitoy.xyz%2f2015%2f10%2f28%2fseven-virtues-of-good-object%2f&amp;src=sdkpreparse" class="fb-xfbml-parse-ignore">Share</a></div>
          </div>
          <div class="share-button">
            <a class="twitter-share-button"
              href="https://twitter.com/intent/tweet?text=%e3%82%88%e3%81%84%e3%82%aa%e3%83%96%e3%82%b8%e3%82%a7%e3%82%af%e3%83%88%e3%81%ae%e4%b8%83%e3%81%a4%e3%81%ae%e7%be%8e%e5%be%b3&amp;url=https%3a%2f%2fwww.kaitoy.xyz%2f2015%2f10%2f28%2fseven-virtues-of-good-object%2f"
              data-size="large">
            Tweet</a>
          </div>
          <div class="share-button">
            <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="vertical-normal" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/v4/public/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
          </div>
          <div class="share-button">
            <a data-pocket-label="pocket" data-pocket-count="vertical" class="pocket-btn" data-lang="en"></a>
            <script type="text/javascript">!function(d,i){if(!d.getElementById(i)){var j=d.createElement("script");j.id=i;j.src="https://widgets.getpocket.com/v1/j/btn.js?v=1";var w=d.getElementById(i);d.body.appendChild(j);}}(document,"pocket-btn-js");</script>
          </div>
        </section>
    </div>

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <ins class="adsbygoogle"
         style="display:block"
         data-ad-client="ca-pub-6244473643910448"
         data-ad-slot="1845600530"
         data-ad-format="auto"></ins>
    <script>
    (adsbygoogle = window.adsbygoogle || []).push({});
    </script>

    <section class="tbd-pagination">
      <div class="row">
        <div class="col-sm-6">
          <div class="prev">
            
            <a href="https://www.kaitoy.xyz/2015/10/12/step-by-step-to-add-a-protocol-support-to-pcap4j-2/">
              <i class="fa fa-angle-left"></i>
              Step by Step to Add a Protocol Support to Pcap4J (Part 2)
            </a>
            
          </div>
        </div>
        <div class="col-sm-6">
          <div class="next text-right">
            
            <a href="https://www.kaitoy.xyz/2015/11/16/thanks-bye-bye-japanese-wrap/">
              ありがとうさようならjapanese-wrap
              <i class="fa fa-angle-right"></i>
            </a>
            
          </div>
        </div>
      </div>
    </section>

    
    

    

        <h4 class="page-header">Related</h4>

        <div class="related-links">
           <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2016/06/25/seven-deadly-sins-of-a-software-project/">ソフトウェアプロジェクトの7つの大罪</a></h4>
    <h5>Sat, Jun 25, 2016</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2016/02/09/continuous-integration-is-dead/">継続的インテグレーションは死んだ</a></h4>
    <h5>Tue, Feb 9, 2016</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/ci"><kbd class="item-tag">ci</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/management"><kbd class="item-tag">management</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2016/01/11/who-is-software-architect/">ソフトウェアアーキテクトは何をするのか?</a></h4>
    <h5>Mon, Jan 11, 2016</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/management"><kbd class="item-tag">management</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2016/01/03/oop-alternative-to-utility-classes/">オブジェクト指向プログラミングにおいてユーティリティクラスに代わるもの</a></h4>
    <h5>Sun, Jan 3, 2016</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/oop"><kbd class="item-tag">oop</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2015/12/03/software-quality-award-2015/">Pcap4JがSoftware Quality Award 2015で入賞</a></h4>
    <h5>Thu, Dec 3, 2015</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/pcap4j"><kbd class="item-tag">pcap4j</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2015/09/13/orm-is-offensive-anti-pattern/">ORMは不快なアンチパターン</a></h4>
    <h5>Sun, Sep 13, 2015</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/oop"><kbd class="item-tag">oop</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/orm"><kbd class="item-tag">orm</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2015/07/26/why-null-is-bad/">なぜNullはダメか</a></h4>
    <h5>Sun, Jul 26, 2015</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/oop"><kbd class="item-tag">oop</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2015/07/22/getters-setters-evil/">Getter/Setterは悪だ。以上。</a></h4>
    <h5>Wed, Jul 22, 2015</h5>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/oop"><kbd class="item-tag">oop</kbd></a>
    

</div>
  <div class="item">

    
    
    

    
    

    <h4 class="post-title"><a href="/2015/07/18/first-post/">First Post</a></h4>
    <h5>Sat, Jul 18, 2015</h5>
    
    <a href="https://www.kaitoy.xyz/tags/blog"><kbd class="item-tag">blog</kbd></a>
    
    <a href="https://www.kaitoy.xyz/tags/yegor256"><kbd class="item-tag">yegor256</kbd></a>
    

</div>
 
        </div>
    

    

        <h4 class="page-header">Comments</h4>

        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "kaitoy-tobedecided" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    

</main>

        <footer>

            <p class="copyright text-muted">&copy; 2015 Kaito Yamada. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a></p>

        </footer>

        <script>window.twttr = (function(d, s, id) {
          var js, fjs = d.getElementsByTagName(s)[0],
            t = window.twttr || {};
          if (d.getElementById(id)) return t;
          js = d.createElement(s);
          js.id = id;
          js.src = "https://platform.twitter.com/widgets.js";
          fjs.parentNode.insertBefore(js, fjs);

          t._e = [];
          t.ready = function(f) {
            t._e.push(f);
          };

          return t;
        }(document, "script", "twitter-wjs"));</script>

    </body>

</html>

