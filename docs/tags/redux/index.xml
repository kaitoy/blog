<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>https://www.kaitoy.xyz/tags/redux/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2018</rights>
    <updated>2018-10-07 13:26:22 &#43;0900 JST</updated>

    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その8: Redux-Saga</title>
          <link>https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/</link>
          <pubDate>Sun, 07 Oct 2018 13:26:22 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/&#34;&gt;前回&lt;/a&gt;は&lt;a href=&#34;https://redux.js.org/basics/usagewithreact&#34;&gt;React Redux&lt;/a&gt;をセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reduxのmiddleware&#34;&gt;ReduxのMiddleware&lt;/h1&gt;

&lt;p&gt;Redux単体では同期的なデータフローしか実装できない。
つまり、Actionを発生させたら、即座にディスパッチされ、stateが更新される。
一方、非同期なフローとは、REST APIを呼んでその結果でstateを更新するような処理。
REST API呼び出しが非同期なわけだが、これをReduxのピュアなフローのどこで実行するのかというと、&lt;a href=&#34;https://redux.js.org/advanced/middleware&#34;&gt;Middleware&lt;/a&gt;で実行する。&lt;/p&gt;

&lt;p&gt;MiddlewareはStoreの&lt;code&gt;dispatch()&lt;/code&gt;をラップして、Actionをトラップして副作用を含む任意の処理をするための機能。
Middlewareの仕組みについては&lt;a href=&#34;https://qiita.com/pirosikick/items/d7f9e5e197a2e8aad62f&#34;&gt;この記事&lt;/a&gt;が分かりやすい。&lt;/p&gt;

&lt;p&gt;Middlewareには例えば、発生したActionの内容と、それによるstateの変化をログに出力する&lt;a href=&#34;https://github.com/evgenyrodionov/redux-logger&#34;&gt;redux-logger&lt;/a&gt;がある。
デバッグに有用そうなので入れておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux-logger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v3.0.6が入った。&lt;/p&gt;

&lt;p&gt;Middlewareは、Reduxの&lt;code&gt;applyMiddleware()&lt;/code&gt;というAPIを使って、&lt;code&gt;createStore()&lt;/code&gt;実行時に適用できる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-import { createStore } from &#39;redux&#39;;
+import { createStore, applyMiddleware } from &#39;redux&#39;;
+import { logger } from &#39;redux-logger&#39;;
 import rootReducer from &#39;./reducers/rootReducer&#39;;

 export default function configureStore(initialState = {}) {
+  const middlewares = [];
+  if (process.env.NODE_ENV === `development`) {
+    middlewares.push(logger);
+  }
+
   const store = createStore(
     rootReducer,
     initialState,
+    applyMiddleware(...middlewares),
   );
   return store;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。
これで、HOGEボタンをクリックしたときにコンソールに以下のようなログが出るようになる。
(ログは&lt;code&gt;yarn start&lt;/code&gt;とかの開発モードの時だけでる。)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;action HOGE_BUTTON_CLICKED @ 23:19:35.190
 prev state Object { hoge: {…} }
 action Object { type: &amp;quot;HOGE_BUTTON_CLICKED&amp;quot;, payload: undefined }
 next state Object { hoge: {…} }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;非同期処理&#34;&gt;非同期処理&lt;/h1&gt;

&lt;p&gt;非同期処理をするためのMiddlewareには&lt;a href=&#34;https://github.com/reduxjs/redux-thunk&#34;&gt;redux-thunk&lt;/a&gt;とか&lt;a href=&#34;https://github.com/redux-utilities/redux-promise&#34;&gt;redux-promise&lt;/a&gt;とかがあるけど、なかでもGitHubのスター数が一番多い&lt;a href=&#34;https://redux-saga.js.org/&#34;&gt;Redux Saga&lt;/a&gt;を使うことにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux-saga
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v0.16.0が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;因みに次にスター数が多いのがredux-thunkで、これはActionをfunctionオブジェクトで書けるようにするMiddleware。
そのfunctionの中で非同期処理をすることで、非同期なReduxフローを実現できる。
redux-sagaはredux-thunkに比べて以下の特長を持つ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コールバック地獄に悩まされることが無い&lt;/li&gt;
&lt;li&gt;Actionをプレーン且つピュアに保てるのでテストしやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;redux-sagaの使い方&#34;&gt;Redux Sagaの使い方&lt;/h1&gt;

&lt;p&gt;Redux Sagaでは、非同期処理はSagaというコンポーネントに書く。
Sagaでは、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ディスパッチされるActionをWatcherが監視し、&lt;/li&gt;
&lt;li&gt;特定のActionが来たらWorkerを起動し、&lt;/li&gt;
&lt;li&gt;Workerが非同期処理などのTaskを実行し、&lt;/li&gt;
&lt;li&gt;その結果を通知するActionをディスパッチする、&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった処理を実行する。&lt;/p&gt;

&lt;p&gt;これらの処理は、Saga Middlewareから呼ばれる&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Generator&#34;&gt;ジェネレータ関数&lt;/a&gt;のなかで、EffectというオブジェクトをSaga Middlewareに返すことで、Saga Middlewareに指示して実行させる。
このEffectを生成する&lt;a href=&#34;https://redux-saga.js.org/docs/api/&#34;&gt;API&lt;/a&gt;がRedux Sagaからいろいろ提供されている。&lt;/p&gt;

&lt;p&gt;上記処理の1~4はそれぞれ以下のAPIで実装できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;take(pattern)&lt;/code&gt;: ディスパッチされるActionを監視して、&lt;code&gt;pattern&lt;/code&gt;にマッチしたら取得するEffectを生成する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork(fn, ...args)&lt;/code&gt;: 渡された関数&lt;code&gt;fn&lt;/code&gt;をノンブロッキングで呼び出すEffectを生成する。&lt;code&gt;fn&lt;/code&gt;はジェネレータか&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;を返す関数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call(fn, ...args)&lt;/code&gt;: 渡された関数&lt;code&gt;fn&lt;/code&gt;を同期的に呼び出すEffectを生成する。&lt;code&gt;fn&lt;/code&gt;はジェネレータか&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;を返す関数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put(action)&lt;/code&gt;: Actionオブジェクトの&lt;code&gt;action&lt;/code&gt;をディスパッチするEffectを生成する。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;rest-api呼び出し&#34;&gt;REST API呼び出し&lt;/h1&gt;

&lt;p&gt;非同期実行で最もよくあるのがREST API呼び出しであろう。
REST API呼び出し処理は&lt;code&gt;call()&lt;/code&gt;で実行するわけだけど、&lt;code&gt;call()&lt;/code&gt;にはPromiseを返す必要があるので、使うライブラリはそこを考慮しないといけない。&lt;/p&gt;

&lt;p&gt;ざっと調べたところ、&lt;a href=&#34;https://www.npmjs.com/package/axios&#34;&gt;axios&lt;/a&gt;、&lt;a href=&#34;https://www.npmjs.com/package/superagent&#34;&gt;SuperAgent&lt;/a&gt;、&lt;a href=&#34;https://www.npmjs.com/package/r2&#34;&gt;r2&lt;/a&gt;あたりが選択肢。
最も人気のあるaxiosを使うことにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add axios
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v0.18.0が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;REST API呼び出しのコードは&lt;code&gt;src/services/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/services/api.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import axios from &#39;axios&#39;;

export const HOGE_URL = &#39;https://httpbin.org/get&#39;;

export function getHoge() {
  return axios.get(HOGE_URL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getHoge()&lt;/code&gt;はGETリクエストを送ってPromiseオブジェクトを返す。
このPromiseオブジェクトはレスポンスボディやステータスコードを保持する&lt;a href=&#34;https://github.com/axios/axios#response-schema&#34;&gt;Response&lt;/a&gt;オブジェクトに解決される。&lt;/p&gt;

&lt;h1 id=&#34;rest-api呼び出しを表現するaction&#34;&gt;REST API呼び出しを表現するAction&lt;/h1&gt;

&lt;p&gt;REST API呼び出しをする場合、呼び出し開始、呼び出し成功、呼び出し失敗の3種類のActionで表現するのが一つの&lt;a href=&#34;https://redux.js.org/advanced/asyncactions&#34;&gt;プラクティス&lt;/a&gt;。
これら3種類を、同一のtypeのActionのプロパティ値を変えて表現するやりかたもあるけど、ここでは別々のtypeのアクションとする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/actions/actionTypes.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; export const HOGE_BUTTON_CLICKED = &#39;HOGE_BUTTON_CLICKED&#39;;
+export const HOGE_FETCH_SUCCEEDED = &#39;HOGE_FETCH_SUCCEEDED&#39;;
+export const HOGE_FETCH_FAILED = &#39;HOGE_FETCH_FAILED&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/actions/actions.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import {
   HOGE_BUTTON_CLICKED,
+  HOGE_FETCH_SUCCEEDED,
+  HOGE_FETCH_FAILED,
 } from &#39;./actionTypes&#39;;

 export function hogeButtonClicked(payload) {
   return {
     type: HOGE_BUTTON_CLICKED,
     payload,
   };
 }
+
+export function hogeFetchSucceeded(payload, meta) {
+  return {
+    type: HOGE_FETCH_SUCCEEDED,
+    payload,
+    meta,
+  };
+}
+
+export function hogeFetchFailed(payload) {
+  return {
+    type: HOGE_FETCH_FAILED,
+    error: true,
+    payload,
+  };
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sagaの実装&#34;&gt;Sagaの実装&lt;/h1&gt;

&lt;p&gt;Sagaのソースは&lt;code&gt;src/sagas/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;が来たら&lt;code&gt;getHoge()&lt;/code&gt;を実行するSagaは以下のような感じ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/sagas/hoge.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { call, fork, put, take } from &#39;redux-saga/effects&#39;;
import { getHoge } from &#39;../services/apis&#39;;
import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;
import { hogeFetchSucceeded, hogeFetchFailed } from &#39;../actions/actions&#39;;

// Task
function* fetchHoge() {
  try {
    const response = yield call(getHoge);
    const payload = response.data;
    const meta = { statusCode: response.status, statusText: response.statusText };
    yield put(hogeFetchSucceeded(payload, meta));
  } catch (ex) {
    yield put(hogeFetchFailed(ex));
  }
}

// Watcher
export function* watchHogeButtonClicked(): Generator&amp;lt;any, void, Object&amp;gt; {
  while (true) {
    const action = yield take(HOGE_BUTTON_CLICKED);
    yield fork(fetchHoge, action); // actionはfetchHogeの引数に渡される。使ってないけど…
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watcherは&lt;code&gt;take&lt;/code&gt;して&lt;code&gt;fork&lt;/code&gt;するのを無限ループで回すのが常なので、これをもうちょっときれいに書けるAPIが用意されていて、以下のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { takeEvery } from &#39;redux-saga/effects&#39;

// Watcher
export function* watchHogeButtonClicked(): Generator&amp;lt;any, void, Object&amp;gt; {
  yield takeEvery(HOGE_BUTTON_CLICKED, fetchHoge)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、&lt;code&gt;fetchHoge()&lt;/code&gt;の最後の引数に&lt;code&gt;take&lt;/code&gt;したActionオブジェクトが渡される。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、今後Watcherはモジュールを分けていくつも書いていくことになるので、それらをまとめて起動するためのモジュール&lt;code&gt;rootSaga.js&lt;/code&gt;を作って、そこで各Watcherを&lt;code&gt;import&lt;/code&gt;して&lt;code&gt;call()&lt;/code&gt;したい。
&lt;code&gt;call()&lt;/code&gt;はブロッキングなAPIなので、パラレルに実行するために&lt;code&gt;all()&lt;/code&gt;を使う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/sagas/rootSaga.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { call, all } from &#39;redux-saga/effects&#39;;
import { watchHogeButtonClicked } from &#39;./hoge&#39;;

export default function* rootSaga() {
  yield all([
    call(watchHogeButtonClicked),
    // call(watchAnotherAction),
    // call(watchYetAnotherAction),
  ]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そもそもブロッキングな&lt;code&gt;call()&lt;/code&gt;を使うのがだめなので、代わりに&lt;code&gt;fork()&lt;/code&gt;を使ってもいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/sagas/rootSaga.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { fork } from &#39;redux-saga/effects&#39;;
import { watchHogeButtonClicked } from &#39;./hoge&#39;;

export default function* rootSaga() {
  yield fork(watchHogeButtonClicked);
  // yield fork(watchAnotherAction);
  // yield fork(watchYetAnotherAction);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どっちがいいんだろう。&lt;/p&gt;

&lt;h1 id=&#34;saga-middlewareの追加と起動&#34;&gt;Saga Middlewareの追加と起動&lt;/h1&gt;

&lt;p&gt;Saga Middlewareは以下のように追加して起動する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { createStore, applyMiddleware } from &#39;redux&#39;;
+import createSagaMiddleware from &#39;redux-saga&#39;;
 import { logger } from &#39;redux-logger&#39;;
+import rootSaga from &#39;./sagas/rootSaga&#39;;
 import rootReducer from &#39;./reducers/rootReducer&#39;;

+const sagaMiddleware = createSagaMiddleware();

 export default function configureStore(initialState = {}) {
   const middlewares = [];
   if (process.env.NODE_ENV === `development`) {
     middlewares.push(logger);
   }
+  middlewares.push(sagaMiddleware);

   const store = createStore(
     rootReducer,
     initialState,
     applyMiddleware(...middlewares),
   );
+  sagaMiddleware.run(rootSaga);
   return store;
 }
&lt;/code&gt;&lt;/pre&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その7: React Redux</title>
          <link>https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/</link>
          <pubDate>Mon, 01 Oct 2018 07:54:53 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/&#34;&gt;前回&lt;/a&gt;はReduxをセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;react-redux&#34;&gt;React Redux&lt;/h1&gt;

&lt;p&gt;前回はReduxをセットアップして、ActionをStoreにディスパッチしてstateを更新できるようになった。
今回はこれをReactにつなぐ。&lt;/p&gt;

&lt;p&gt;使うのは&lt;a href=&#34;https://redux.js.org/basics/usagewithreact&#34;&gt;React Redux&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add react-redux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v5.0.7が入った。&lt;/p&gt;

&lt;h1 id=&#34;presentational-components-と-container-components&#34;&gt;Presentational Components と Container Components&lt;/h1&gt;

&lt;p&gt;React Reduxの使い方を理解するには、&lt;a href=&#34;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&#34;&gt;Presentational Components と Container Components&lt;/a&gt; という概念を知らないといけない。
これはReactコンポーネントを役割別に分ける考え方で、それぞれ以下のような特徴をもつ。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Presentational Components&lt;/th&gt;
&lt;th&gt;Container Components&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;主な役割&lt;/td&gt;
&lt;td&gt;DOMをレンダリングする&lt;/td&gt;
&lt;td&gt;データを取得したりstateを更新したりする(Reduxとつなぐ)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Reduxとの関連&lt;/td&gt;
&lt;td&gt;無し&lt;/td&gt;
&lt;td&gt;有り&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;データの読み込み&lt;/td&gt;
&lt;td&gt;propsから読む&lt;/td&gt;
&lt;td&gt;Reduxのstateオブジェクトから読む&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;データの更新&lt;/td&gt;
&lt;td&gt;propsで渡されたコールバックを呼ぶ&lt;/td&gt;
&lt;td&gt;ReduxのActionをディスパッチする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;作り方&lt;/td&gt;
&lt;td&gt;自前で書く&lt;/td&gt;
&lt;td&gt;React Reduxで生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;要するに、普通にReactで作ったUIコンポーネントを、React Reduxで生成するContainer ComponentでラップしてやることでReduxのStoreとつなぐことができる。&lt;/p&gt;

&lt;h1 id=&#34;connect&#34;&gt;connect()&lt;/h1&gt;

&lt;p&gt;Container Componentの生成にはReact Reduxの&lt;a href=&#34;https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&#34;&gt;connect()&lt;/a&gt;というAPIを使う。&lt;/p&gt;

&lt;p&gt;React Reduxを使う場合、Reduxのstateの更新に応じてReactコンポーネントに新しいpropsを渡して再レンダリングすることになるが、この新しいpropsを作ってコンポーネントに渡す処理を定義するのが&lt;code&gt;connect()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;の第一引数には、ReduxのstateのプロパティとReactコンポーネントのpropsのプロパティとのマッピングをする関数である&lt;code&gt;mapStateToProps()&lt;/code&gt;を渡す。
&lt;code&gt;mapStateToProps()&lt;/code&gt;はstateの更新に応じて呼び出され、引数にstate(と現在のprops)が渡される。
&lt;code&gt;mapStateToProps()&lt;/code&gt;が返すオブジェクトはReactコンポーネントに渡されるpropsにマージされる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;の第二引数には、Storeの&lt;code&gt;dispatch()&lt;/code&gt;を呼び出す処理とReactコンポーネントのpropsのプロパティとのマッピングをする関数である&lt;code&gt;mapDispatchToProps()&lt;/code&gt;を渡す。
&lt;code&gt;mapDispatchToProps()&lt;/code&gt;の引数には&lt;code&gt;dispatch()&lt;/code&gt;が渡される。
&lt;code&gt;mapDispatchToProps()&lt;/code&gt;が返すオブジェクトはReactコンポーネントに渡されるpropsにマージされる。&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;mapDispatchToProps()&lt;/code&gt;は第二引数に&lt;code&gt;props&lt;/code&gt;を受け取ることもできて、この場合、propsの更新に反応して呼び出されるコールバックになる。)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;を実行すると関数が返ってくる。
この関数にReactコンポーネント(Presentational Component)を渡して実行すると、Storeに接続されたReactコンポーネント(Container Component)が返ってくる。&lt;/p&gt;

&lt;h2 id=&#34;connect-の使い方&#34;&gt;connect()の使い方&lt;/h2&gt;

&lt;p&gt;前回作ったStoreをHOGEボタン(これはPresentational Component)につなげるContainer Componentを書いてみる。
Container Componentのソースは&lt;code&gt;src/containers/&lt;/code&gt;に入れる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/containers/HogeButton.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import Button from &#39;@material-ui/core/Button&#39;;
import { connect } from &#39;react-redux&#39;;
import { hogeButtonClicked } from &#39;../actions/actions&#39;;

function mapStateToProps(state) {
  return {
    clicked: state.hoge.clicked
  };
}

function mapDispatchToProps(dispatch) {
  return {
    onClick: function() {
      dispatch(hogeButtonClicked());
    }
  };
}

const HogeButton = connect(
  mapStateToProps,
  mapDispatchToProps,
)(Button);

export default HogeButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;p&gt;HOGEボタンをクリックすると、以下の流れで状態が遷移する。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hogeButtonClicked()&lt;/code&gt;が呼ばれて&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;アクションが生成されてdispatchされる。&lt;/li&gt;
&lt;li&gt;Storeの中で&lt;code&gt;state.hoge.clicked&lt;/code&gt;が更新される。&lt;/li&gt;
&lt;li&gt;stateの更新に反応して&lt;code&gt;mapStateToProps()&lt;/code&gt;が呼び出され、その戻り値がpropsにマージされる。&lt;/li&gt;
&lt;li&gt;新しいpropsを使って、新たにHOGEボタンがレンダリングされる。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connect-のシンプルな書き方&#34;&gt;connect()のシンプルな書き方&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;mapDispatchToProps&lt;/code&gt;は実はプレーンオブジェクトでもいい。
この場合、オブジェクトのキーと値はそれぞれ、propsのプロパティ名とAction Creatorにする。
(Action Creatorは&lt;code&gt;connect()&lt;/code&gt;が&lt;code&gt;dispatch()&lt;/code&gt;でラップしてくれる。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const mapDispatchToProps ⁼ {
  onClick: hogeButtonClicked,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;mapStateToProps&lt;/code&gt;と&lt;code&gt;mapDispatchToProps&lt;/code&gt;はexportするわけでも再利用するわけでもないので、&lt;code&gt;connect()&lt;/code&gt;の中に直接書いてしまってもいい。
この場合、&lt;code&gt;mapStateToProps&lt;/code&gt;はアロー関数で書いて、&lt;code&gt;return&lt;/code&gt;は省略してしまうのがいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HogeButton = connect(
  (state) =&amp;gt; ({
    clicked: state.hoge.clicked
  }),
  {
    onClick: hogeButtonClicked,
  },
)(Button);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;さらに、&lt;code&gt;mapStateToProps&lt;/code&gt;が受け取る&lt;code&gt;state&lt;/code&gt;は、&lt;code&gt;hoge&lt;/code&gt;プロパティしか興味ないので、オブジェクト分割代入をするのがいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HogeButton = connect(
  ({hoge}) =&amp;gt; ({
    clicked: hoge.clicked
  }),
  {
    onClick: hogeButtonClicked,
  },
)(Button);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;まとめると、以下のように書けるということ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/containers/HogeButton.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import Button from &#39;@material-ui/core/Button&#39;;
import { connect } from &#39;react-redux&#39;;
import { hogeButtonClicked } from &#39;../actions/actions&#39;;

const HogeButton = connect(
  ({hoge}) =&amp;gt; ({
    clicked: hoge.clicked
  }),
  {
    onClick: hogeButtonClicked,
  },
)(Button);

export default HogeButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;https://qiita.com/taneba/items/4d45d1075137a7dae10e&#34;&gt;シンプルなreact-reduxのconnectの書き方&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;reselect&#34;&gt;reselect&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;mapStateToProps&lt;/code&gt;はstateが更新されるたびに呼ばれるので、中で複雑な計算してたりするとアプリ全体のパフォーマンスに影響を与える。&lt;/p&gt;

&lt;p&gt;このような問題に対応するため、stateの特定のサブツリーが更新された時だけ&lt;code&gt;mapStateToProps&lt;/code&gt;の先の計算を実行できるようにするライブラリがある。
それが&lt;a href=&#34;https://github.com/reduxjs/reselect&#34;&gt;relesect&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;reselectは重要なライブラリだとは思うけど、とりあえずほって先に進む。&lt;/p&gt;

&lt;h1 id=&#34;hogebuttonのアプリへの組み込み&#34;&gt;HogeButtonのアプリへの組み込み&lt;/h1&gt;

&lt;p&gt;作ったHogeButtonは、普通のコンポーネントと同じように使える。&lt;/p&gt;

&lt;p&gt;components/App.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import styled from &#39;styled-components&#39;;
-import Button from &#39;@material-ui/core/Button&#39;;
+import HogeButton from &#39;../containers/HogeButton&#39;;

 const Wrapper = styled.div`
   font-size: 5rem;
 `;

 const App = () =&amp;gt; (
   &amp;lt;Wrapper&amp;gt;
-    &amp;lt;Button variant=&amp;quot;contained&amp;quot;&amp;gt;
+    &amp;lt;HogeButton variant=&amp;quot;contained&amp;quot;&amp;gt;
       HOGE
-    &amp;lt;/Button&amp;gt;
+    &amp;lt;/HogeButton&amp;gt;
   &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;provider&#34;&gt;Provider&lt;/h1&gt;

&lt;p&gt;全てのContainer ComponentsがReduxのStoreの変更をサブスクライブする必要があるので、それらに&lt;a href=&#34;https://redux.js.org/basics/usagewithreact#passing-the-store&#34;&gt;Storeを渡してやらないといけない&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Storeをpropsに渡して、子コンポーネントにバケツリレーさせたりして行きわたらせることも可能だけど面倒すぎる。
ので、React Reduxがもっと簡単にやる仕組みを提供してくれている。
それが&lt;a href=&#34;https://github.com/reduxjs/react-redux/blob/master/docs/api.md#provider&#34;&gt;Provider&lt;/a&gt;というコンポーネント。&lt;/p&gt;

&lt;p&gt;Providerの子コンポーネントはStoreにアクセスして&lt;code&gt;connect()&lt;/code&gt;を使えるようになる。
ざっくり全体をProviderで囲ってやるのがいい。&lt;/p&gt;

&lt;p&gt;src/index.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import ReactDOM from &#39;react-dom&#39;;
+import { Provider } from &#39;react-redux&#39;;
 import App from &#39;./components/App&#39;;
+import configureStore from &#39;./configureStore&#39;;
 import &#39;./fonts.css&#39;;

+const store = configureStore();
 const root = document.getElementById(&#39;root&#39;);

 if (root) {
   ReactDOM.render(
-    &amp;lt;App /&amp;gt;,
+    &amp;lt;Provider store={store}&amp;gt;
+      &amp;lt;App /&amp;gt;
+    &amp;lt;/Provider&amp;gt;,
     root,
   );
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/&#34;&gt;次回&lt;/a&gt;は、ReduxにMiddlewareを追加して、非同期処理を実装する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その6: Redux</title>
          <link>https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/</link>
          <pubDate>Wed, 26 Sep 2018 23:03:04 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/&#34;&gt;前回&lt;/a&gt;はMaterial-UIをセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reactの状態管理&#34;&gt;Reactの状態管理&lt;/h1&gt;

&lt;p&gt;Reactによるプログラミングをするとき、小さいUIコンポーネントをたくさん作って、それらを組み合わせてVirtual DOMツリーを作っておいて、そこにpropsをほうりこんでレンダリングする、という感じになる。
また、レンダリングした後はコンポーネントのstateをいじって状態を変化させる。&lt;/p&gt;

&lt;p&gt;このpropsやstateの扱いをReactの状態管理という。
propsやstateを適当にアドホックに設定してると、結局jQuery使ってるのとそんなに変わらなくなって辛くなるので、Reactの開発元であるFacebookは&lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;Flux&lt;/a&gt;というアーキテクチャを提案している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/flux/raw/master/docs/img/flux-diagram-white-background.png&#34; alt=&#34;Flux&#34; title=&#34;Flux&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Fluxでは、単一の(またはドメイン毎くらいの単位の)オブジェクトでアプリケーション全体の状態(state)を表し、これをStoreに保持する。
ReactはStoreが保持するstateを受け取り、それをもとにViewをレンダリングする。
Viewに対するユーザの操作(など)はActionというオブジェクトで表現され、Dispatcherに渡され、Dispatcherに登録されたcallbackを通してstateを変化させる。&lt;/p&gt;

&lt;p&gt;データが常に一方向に流れて見通しがよく、各コンポーネントの独立性が高いのが特徴。
各コンポーネントは、受け取ったデータをピュアに処理すればよく、リアクティブにファンクショナルに実装できる。&lt;/p&gt;

&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;

&lt;p&gt;Fluxの実装、というか発展形がRedux。&lt;/p&gt;

&lt;p&gt;ReduxではFluxのDispatcher辺りがReducerに置き換わっている。
ReducerはActionと現在のstateから次のstateを計算する純粋関数。&lt;/p&gt;

&lt;p&gt;また、ReduxからはViewが切り離されていて、Actionによってstateを更新する状態管理ライブラリの役割に徹している。
ReactコンポーネントのイベントハンドラからActionオブジェクトを生成したり、更新したstateをReactに渡したりするつなぎ目は、別途&lt;a href=&#34;https://github.com/reduxjs/react-redux&#34;&gt;React Redux&lt;/a&gt;というライブラリが担当する。&lt;/p&gt;

&lt;p&gt;ReduxとReact Reduxについては、Qiitaの「&lt;a href=&#34;https://qiita.com/mpyw/items/a816c6380219b1d5a3bf&#34;&gt;たぶんこれが一番分かりやすいと思います React + Redux のフロー図解&lt;/a&gt;」という記事が分かりやすい。&lt;/p&gt;

&lt;p&gt;今回はReduxを導入する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redux v4.0.0が入った。&lt;/p&gt;

&lt;p&gt;以降、現時点で唯一のUIコンポーネントであるHOGEボタンの状態管理を実装してみる。&lt;/p&gt;

&lt;h2 id=&#34;action&#34;&gt;Action&lt;/h2&gt;

&lt;p&gt;まず&lt;a href=&#34;https://redux.js.org/basics/actions&#34;&gt;Action&lt;/a&gt;を実装する。&lt;/p&gt;

&lt;p&gt;Actionオブジェクトはどんな形式でもいいけど、普通は&lt;a href=&#34;https://github.com/redux-utilities/flux-standard-action&#34;&gt;Flux Standard Action&lt;/a&gt;(FSA)にする。
FSAは以下のプロパティを持つプレーンオブジェクト。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type: Action種別を示す文字列定数。必須。&lt;/li&gt;
&lt;li&gt;payload: Actionの情報を示す任意の型の値。任意。&lt;/li&gt;
&lt;li&gt;error: Actionがエラーを表すものかを示す boolean プロパティ。エラーなら true にして、payload にエラーオブジェクトをセットする。任意。&lt;/li&gt;
&lt;li&gt;meta: その他の情報を入れる任意の型の値。任意。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Actionのコードは、Actionのtypeに入れる値を定義する&lt;code&gt;actionTypes.js&lt;/code&gt;と、Action Creator(i.e. Actionオブジェクトを生成する関数)を定義する&lt;code&gt;actions.js&lt;/code&gt;からなり、ともに&lt;code&gt;src/actions/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;HOGEボタンをクリックしたときのAction、&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;を定義してみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/actions/actionTypes.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const HOGE_BUTTON_CLICKED = &#39;HOGE_BUTTON_CLICKED&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/actions/actions.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {
  HOGE_BUTTON_CLICKED,
} from &#39;./actionTypes&#39;;

export function hogeButtonClicked(payload) {
  return {
    type: HOGE_BUTTON_CLICKED,
    payload,
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;h2 id=&#34;reducer&#34;&gt;Reducer&lt;/h2&gt;

&lt;p&gt;次は&lt;a href=&#34;https://redux.js.org/basics/reducers&#34;&gt;Reducer&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Reducerは、上記Action Creatorが生成するActionオブジェクトに対応して起動し、Store(後述)から現在のstateオブジェクトを受け取って、Actionオブジェクトのpayloadの値(など)に応じて新しいstateオブジェクトを作る。&lt;/p&gt;

&lt;p&gt;Reducerを書く前に、stateオブジェクトの構造を設計しておくことが推奨されている。
UIコンポーネント毎にプロパティを分けて、コンポーネント構造と同様の階層構造にしておけばだいたいよさそう。&lt;/p&gt;

&lt;p&gt;HOGEボタンに一つ、クリックしたかどうかの状態(&lt;code&gt;clicked&lt;/code&gt;)を持たせるとすると、stateオブジェクトは以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  hoge: {
    clicked: false,
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Reducerはピュアじゃないといけないので、内部で&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0&#34;&gt;副作用&lt;/a&gt;を起こしてはいけない。
副作用とは、具体的には以下のようなもの。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引数で与えられたオブジェクトを変更する。&lt;/li&gt;
&lt;li&gt;REST APIへのリクエストを送る。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(ログの出力も厳密には副作用なんだろうけど、それは許されてる気がする。)&lt;/p&gt;

&lt;p&gt;また、ピュアであるためには&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E9%80%8F%E9%81%8E%E6%80%A7&#34;&gt;参照透過性&lt;/a&gt;を持たないといけなくて、つまり同じ引数に対しては同じ戻り値を返さないといけないので、内部で&lt;code&gt;Date.now()&lt;/code&gt;とか&lt;code&gt;Math.random()&lt;/code&gt;とかを呼ぶのもダメ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Reducerのコードは&lt;code&gt;src/reducers/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;が発生したら、&lt;code&gt;hoge&lt;/code&gt;の&lt;code&gt;clicked&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にするReducer(&lt;code&gt;hoge()&lt;/code&gt;)は以下の感じに書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;

const initialState = {
  hoge: {
    clicked: false,
  },
};

export function hoge(state = initialState, action) {
  switch (action.type) {
    case HOGE_BUTTON_CLICKED:
      const newHoge = {
        hoge: {
          clicked: true,
        },
      };
      return Object.assign({}, state, newHoge);
    default:
      return state;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hoge()&lt;/code&gt;のポイントはたくさんある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt;と&lt;code&gt;action&lt;/code&gt;を引数に取る。前者が現在の状態を表すstateオブジェクトで、後者がActionオブジェクト。&lt;/li&gt;
&lt;li&gt;戻り値は新しい状態を表すstateオブジェクト。&lt;/li&gt;
&lt;li&gt;actionオブジェクトはどのActionを表すものかは分からないので、&lt;code&gt;action.type&lt;/code&gt;を見て&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;だけを処理するようにする。

&lt;ul&gt;
&lt;li&gt;知らないActionだったら(i.e. &lt;code&gt;default&lt;/code&gt;句のなかに来たら)、受け取ったstateオブジェクトをそのまま返す。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;アプリケーションの初期化時には&lt;code&gt;state&lt;/code&gt;に&lt;code&gt;undefined&lt;/code&gt;が渡されるので、それに備え、初期状態である&lt;code&gt;initialState&lt;/code&gt;をデフォルト引数に設定する。&lt;/li&gt;
&lt;li&gt;渡されたstateオブジェクトを変更してはいけないので、&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&#34;&gt;Object.assgin()&lt;/a&gt;に空オブジェクト&lt;code&gt;{}&lt;/code&gt;とともに&lt;code&gt;state&lt;/code&gt;を渡してコピーする。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assgin()&lt;/code&gt;の代わりに&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5&#34;&gt;オブジェクト分割代入&lt;/a&gt;を使う方法も&lt;a href=&#34;https://redux.js.org/recipes/usingobjectspreadoperator&#34;&gt;ある&lt;/a&gt;。この場合&lt;a href=&#34;https://babeljs.io/docs/en/babel-plugin-transform-object-rest-spread&#34;&gt;babel-plugin-transform-object-rest-spread&lt;/a&gt;が必要。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.assign()&lt;/code&gt;の第三引数に&lt;code&gt;newHoge&lt;/code&gt;で上書きするようにしている。

&lt;ul&gt;
&lt;li&gt;今はstateオブジェクトのプロパティが&lt;code&gt;hoge&lt;/code&gt;一つだけなので単に&lt;code&gt;newHoge&lt;/code&gt;をreturnしても結果は一緒。なので無駄なことをしてるようにも見えるけど、stateオブジェクトのプロパティが増えた場合に&lt;code&gt;hoge&lt;/code&gt;以外に影響を与えないための計らい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これはこれでいい感じに見えるけど、&lt;code&gt;hoge()&lt;/code&gt;が&lt;code&gt;hoge&lt;/code&gt;プロパティしか扱わないのに、stateオブジェクト全体を渡しているのがイケていない。
(まあ今はstateオブジェクトには&lt;code&gt;hoge&lt;/code&gt;プロパティしかないんだけど、他のプロパティが色々増えてくるとイケてない感が高まる。)
&lt;code&gt;hoge&lt;/code&gt;プロパティがstateオブジェクト構造のどこにあるかを&lt;code&gt;hoge()&lt;/code&gt;が気にしないといけないのもイケてない。
&lt;code&gt;hoge()&lt;/code&gt;には&lt;code&gt;hoge&lt;/code&gt;プロパティだけを見てほしい。&lt;/p&gt;

&lt;p&gt;ということで、普通はReducerは分割して書いて、それぞれのReducerにstateオブジェクトを分割して渡してやる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;

-const initialState = {
-  hoge: {
-    clicked: false,
-  },
-};

-export function hoge(state = initialState, action) {
+export function hoge(state = { clicked: false }, action) {
   switch (action.type) {
     case HOGE_BUTTON_CLICKED:
       const newHoge = {
-        hoge: {
-          clicked: true,
-        },
+        clicked: true,
       };
       return Object.assign({}, state, newHoge);
     default:
       return state;
   }
 }

+export function rootReducer(state = {}, action) {
+  return {
+    hoge: hoge(state.hoge, action),
+  }
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで、&lt;code&gt;rootReducer()&lt;/code&gt;がstateオブジェクトを分割して子Reducerを呼び出す。
孫Reducerとか曾孫Reducerとかがあってもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rootReducer()&lt;/code&gt;は別のファイルに書くと見やすくなるし、Reduxの&lt;a href=&#34;https://redux.js.org/api/combinereducers&#34;&gt;combineReducers()&lt;/a&gt;というヘルパー関数を使うともっと楽に書ける。
上記&lt;code&gt;reducers.js&lt;/code&gt;からは&lt;code&gt;rootReducer()&lt;/code&gt;を削除して、&lt;code&gt;rootReducer.js&lt;/code&gt;に以下のように書く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { combineReducers } from &#39;redux&#39;;
import hoge from &#39;./reducers&#39;;

const rootReducer = combineReducers({
  hoge,
});
export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように&lt;code&gt;combineReducers()&lt;/code&gt;で作った&lt;code&gt;rootReducer&lt;/code&gt;は、上で自前で書いた&lt;code&gt;rootReducer&lt;/code&gt;と全く同じ動きをする。&lt;/p&gt;

&lt;p&gt;さらに簡単に、以下のようにも書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { combineReducers } from &#39;redux&#39;;
import * as reducers from &#39;./reducers&#39;;

const rootReducer = combineReducers(reducers);
export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておけば、Reducerの追加は&lt;code&gt;reducers.js&lt;/code&gt;に関数を追加するだけでよくなる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redux-utilities/redux-actions&#34;&gt;redux-actions&lt;/a&gt;を使うとさらに記述を簡略化できるみたいだけど、逆に何が何だか分からなくなりそうだったので、慣れるまでは使わないでおく。&lt;/p&gt;

&lt;h2 id=&#34;store&#34;&gt;Store&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://redux.js.org/basics/store&#34;&gt;Store&lt;/a&gt;は以下のような特徴を持つオブジェクト。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState()&lt;/code&gt;でstateオブジェクトを返す。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;でActionをディスパッチできる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;でActionのディスパッチをサブスクライブできる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StoreはrootReducerを&lt;a href=&#34;https://redux.js.org/api/createstore&#34;&gt;createStore()&lt;/a&gt;に渡すことで作れる。
&lt;code&gt;createStore()&lt;/code&gt;を呼ぶコードはモジュールにしておくのがいい。
後で膨らんでくるので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore } from &#39;redux&#39;;
import rootReducer from &#39;./reducers/rootReducer&#39;;

export default function configureStore(initialState = {}) {
  const store = createStore(
    rootReducer,
    initialState,
  );
  return store;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でReduxのコンポーネントが一通りそろって、状態管理システムができた。
試しに動かしてみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/try.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { hogeButtonClicked } from &#39;./actions/actions&#39;;
import configureStore from &#39;./configureStore&#39;;

const store = configureStore();
console.log(store.getState()); // =&amp;gt; { hoge: {clicked: false} }

store.subscribe(() =&amp;gt; {
  console.log(store.getState());
});

store.dispatch(hogeButtonClicked()); // =&amp;gt; { hoge: {clicked: true} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;するとReducer(&lt;code&gt;hoge()&lt;/code&gt;)が実行され、stateオブジェクトが更新されることが分かる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/&#34;&gt;次回&lt;/a&gt;は、今回作ったStoreをReactコンポーネントにつなぐ。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
