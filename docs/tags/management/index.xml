<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>https://www.kaitoy.xyz/tags/management/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2018</rights>
    <updated>2016-02-09 00:34:41 -0700 -0700</updated>

    
      
        <item>
          <title>継続的インテグレーションは死んだ</title>
          <link>https://www.kaitoy.xyz/2016/02/09/continuous-integration-is-dead/</link>
          <pubDate>Tue, 09 Feb 2016 00:34:41 -0700</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2016/02/09/continuous-integration-is-dead/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/10/08/continuous-integration-is-dead.html&#34;&gt;Continuous Integration is Dead&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;数日前、「&lt;a href=&#34;http://devops.com/blogs/continuous-integration-doesnt-work/&#34;&gt;なぜ継続的インテグレーションは機能しないのか&lt;/a&gt;」という私の記事が&lt;a href=&#34;http://www.devops.com/&#34;&gt;DevOps.com&lt;/a&gt;に公開された。
それとほぼ同じ日に、Twitterで非常に否定的な批評が送られてきた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;継続的インテグレーションが機能しないとはどういうことだ。この人気なすばらしいアイデアが。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;その求めてもない質問への返事をここに書く。&lt;/p&gt;

&lt;p&gt;私はこの分野に関して多少の経験があるが、それに基いた論拠は挙げない。
代わりにロジックだけを頼りにする。&lt;/p&gt;

&lt;p&gt;ところで、私には50以上のオープンソースや営利プロジェクトで5年間Apache Continuum、Hudson、CruiseControl、Jenkinsを利用した経験がある。
さらに、数年前&lt;a href=&#34;http://www.fazend.com/&#34;&gt;fazend.com&lt;/a&gt;(2013年に&lt;a href=&#34;http://www.rultor.com/&#34;&gt;rultor.com&lt;/a&gt;に改名)というホスト型継続的インテグレーションサービスを開発した。
現在&lt;a href=&#34;http://www.travis-ci.org/&#34;&gt;Travis&lt;/a&gt;と&lt;a href=&#34;http://www.appveyor.com/&#34;&gt;AppVeyor&lt;/a&gt;のアクティブユーザでもある。&lt;/p&gt;

&lt;h2 id=&#34;継続的インテグレーションはどう機能すべきか&#34;&gt;継続的インテグレーションはどう機能すべきか&lt;/h2&gt;

&lt;p&gt;考え方はシンプルで明確だ。
&lt;code&gt;master&lt;/code&gt;ブランチ(Subversionなら&lt;code&gt;/trunk&lt;/code&gt;)に新しくコミットをする度に、継続的インテグレーションサーバ(またはサービス)はプロダクト全体のビルドを試みる。
「ビルド」というのはコンパイル、ユニットテスト、統合テスト、品質解析&lt;a href=&#34;http://www.yegor256.com/2014/06/21/casperjs-with-maven.html&#34;&gt;など&lt;/a&gt;を意味する。&lt;/p&gt;

&lt;p&gt;その結果は「成功」か「失敗」だ。
もし成功だったら「ビルドがクリーン」であると言う。
もし失敗だったら、「ビルドが壊れている」と言う。
通常、ビルドが壊れるのは、以前通っていたユニットテストを通らなくするような新しいコードをだれかがコミットしたからだ。&lt;/p&gt;

&lt;p&gt;これは問題の技術的な面だ。
この部分はいつも上手くいく。
まあ、依存が直書きされてるとか、ビルド環境が十分分離されていないとか、ビルドの並列性が完全じゃないとか、そういう問題はあるかもしれないが、この記事はそれらについてではない。
アプリケーションが上手く書かれていてユニットテストが安定しているなら、継続的インテグレーションは簡単だ。
技術的には。&lt;/p&gt;

&lt;p&gt;組織的な面を見てみよう。&lt;/p&gt;

&lt;p&gt;継続的インテグレーションというのは、ビルドを実行するサーバだけを指すのではなく、上手く機能すべき管理的/組織的プロセスだ。
プロセスが上手く機能するとは、Jez Humbleが「&lt;a href=&#34;http://www.amazon.com/gp/product/0321601912/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0321601912&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=GKWBKGZUJGJLFMHE&#34;&gt;継続的デリバリー: ビルド、テスト、デプロイの自動化による確実なソフトウェアリリース&lt;/a&gt;」の55ページで言っていることそのものを意味する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;もしビルドが失敗したら、開発チームは何をやっていたとしてもそれを中断して、そのビルドの問題を速やかに直す。これが重要だ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これが上手くいかず、上手くできないことだ。&lt;/p&gt;

&lt;h2 id=&#34;誰がこれを必要としているのか&#34;&gt;誰がこれを必要としているのか&lt;/h2&gt;

&lt;p&gt;既に述べた通り、継続的インテグレーションとは、開発チーム全体を止めて壊れたビルドを修正させることだ。
繰り返すが、ビルドが壊れたら直ちに、それを修正し、ビルドを安定した状態に戻すコミットを入れることに全員が集中すべきだ。&lt;/p&gt;

&lt;p&gt;ここでひとつ疑問が生じる。誰が、活動中のチーム内の誰がこれを必要としているのだろうか?&lt;/p&gt;

&lt;p&gt;一刻も早く新しい機能をリリースしたいプロダクトオーナ?
または、締め切りに責任を持つ&lt;a href=&#34;http://www.yegor256.com/2015/09/22/micromanagement.html&#34;&gt;プロジェクトマネージャ&lt;/a&gt;かもしれない。
もしくは、他の誰かが作りこんだバグをプレッシャーを受けながら修正すること嫌うプログラマかもしれない。&lt;/p&gt;

&lt;p&gt;誰がこの継続的インテグレーションを好み、誰が必要としているのか?&lt;/p&gt;

&lt;p&gt;誰でもない。&lt;/p&gt;

&lt;h2 id=&#34;実際に何が起こるのか&#34;&gt;実際に何が起こるのか&lt;/h2&gt;

&lt;p&gt;教えよう。
私は何度も見たことがある。
シナリオはいつも同じだ。
継続的インテグレーションのビルドステータスは単に無視されるようになる。
ビルドがクリーンか壊れているかにかかわらず。
そして以前のやり方が継続される。&lt;/p&gt;

&lt;p&gt;Jez Humbleが推奨するように開発を止めて問題に対応したりしない。&lt;/p&gt;

&lt;p&gt;代わりに、継続的インテグレーションサーバから来る情報を無視する。&lt;/p&gt;

&lt;p&gt;しばらくして、次の日かもしれないし月曜日かもしれないが、空いた時間を探してビルドの修正に取り組む。
これは単に、ダッシュボードの赤いボタンが嫌で緑に変えたいからだ。&lt;/p&gt;

&lt;h2 id=&#34;規律についてはどうか&#34;&gt;規律についてはどうか&lt;/h2&gt;

&lt;p&gt;そう、これには別の見方もある。
チームに規律を徹底させることもできる。
ビルドは常にクリーンで、壊した人は何らかの&lt;a href=&#34;http://www.yegor256.com/2016/01/05/how-to-punish-employees.html&#34;&gt;罰&lt;/a&gt;を受けるという厳格なルールを設けることができる。&lt;/p&gt;

&lt;p&gt;これを試すとなると、恐怖駆動型開発を実施することになる。
プログラマは、ビルドを失敗させたら少なくとも&lt;a href=&#34;http://programmers.stackexchange.com/questions/79041&#34;&gt;謝罪&lt;/a&gt;しなければならなくなるため、リポジトリへのコミットを恐れるようになる。&lt;/p&gt;

&lt;p&gt;この場合の厳格な規律(私は大好きだが)は、単に状況を悪化させる。
開発プロセス全体が遅くなり、プログラマはビルドを壊さないように自身のコードをできるだけ長い間手元に保持する。
いざコミットするとなった時、変更は巨大になっていて、マージは非常に難しいか、時に不可能になる。&lt;/p&gt;

&lt;p&gt;結果、プログラマが書いた多くのコードがコミットされること無く捨てられる。
あの恐怖因子のせいだ。&lt;/p&gt;

&lt;h2 id=&#34;ok-解決策は&#34;&gt;OK。解決策は?&lt;/h2&gt;

&lt;p&gt;それについては以前書いた。
「&lt;a href=&#34;http://www.yegor256.com/2014/07/21/read-only-master-branch.html&#34;&gt;読み取り専用マスタブランチ&lt;/a&gt;」だ。&lt;/p&gt;

&lt;p&gt;これは単純で、&lt;code&gt;master&lt;/code&gt;へのマージを一切禁止し、誰でも実行できるスクリプトを作る。
このスクリプトがマージ、テスト、コミットを実行する。
このスクリプトには例外が全く無い。
どんなブランチであっても、たった一つのユニットテストに失敗しただけでも、ブランチ全体が却下される。&lt;/p&gt;

&lt;p&gt;言い換えると、&lt;code&gt;master&lt;/code&gt;にそのコードが入る前に赤いフラグを揚げる。&lt;/p&gt;

&lt;p&gt;これで全ての問題が解決する。&lt;/p&gt;

&lt;p&gt;第一に、ビルドは常にクリーンだ。
ビルドをクリーンに保たないコードは誰もコミットできないので、単純に言ってビルドを壊すことはできない。&lt;/p&gt;

&lt;p&gt;第二に、何かを壊すという恐怖が無い。
単に技術的に壊せないのだ。
マージスクリプトから却下されることしかできない。
その場合、エラーを修正してスクリプトに再挑戦を命じる。
誰もこのやりとりを見ていないので、謝罪する必要が無い。
恐怖因子は消えた。&lt;/p&gt;

&lt;p&gt;ところで、君のプロジェクトで&lt;a href=&#34;http://www.rultor.com/&#34;&gt;rultor.com&lt;/a&gt;を利用して、この「&lt;a href=&#34;http://www.yegor256.com/2014/07/21/read-only-master-branch.html&#34;&gt;読み取り専用マスタブランチ&lt;/a&gt;」原則を徹底してみてくれ。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/3IXk5yEJMIs&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;CIは死んだというセンセーショナルなタイトルではあるが、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E7%A5%9E%E3%81%AF%E6%AD%BB%E3%82%93%E3%81%A0&#34;&gt;ニーチェ&lt;/a&gt;とは違って神なるCIを否定しているわけではない。
CIって意外と上手くいかないけど、こうすれば改善できるよという主旨の記事だ。&lt;/p&gt;

&lt;p&gt;Yegorが指摘している、ビルドステータスが無視されるようになるという一つ目の問題は、実例を多く見たことがあるわけではないが確かになんだかよく起こりそうな話だ。
そういえば私もPcap4JのTravisでのビルドエラーをもう数か月無視している。
まあこれはTravis側の問題が原因で、回避策を入れるのが気が進まないだけなんだけど。&lt;/p&gt;

&lt;p&gt;Yegorのやり方は、&lt;a href=&#34;https://gist.github.com/juno/3112343&#34;&gt;GitHub Flow&lt;/a&gt;が&lt;code&gt;master&lt;/code&gt;は常にデプロイ可能としているのを、より厳密に守るように仕組化する感じであろうか。&lt;/p&gt;

&lt;p&gt;GitHub Flowを世に広めたScott Chaconによれば、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;テストされていなかったり、ビルドを破壊するようなコードをmasterにpushした場合には、開発チーム間におけるソーシャルな取り決めを破ることになり、ちょっと気まずい思いをすることになる&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とのことで、これはまさにYegorが恐怖因子と指摘した二つ目の問題である。
慣れない内のリポジトリへのコミットの緊張感や、CIサーバからエラー通知が来た時の焦燥感は、多くの人のストレスになっているんじゃないだろうか。
&lt;code&gt;master&lt;/code&gt;の更新をスクリプトに任せてしまえば、それでなおビルドが壊れたとしてもスクリプトのせいにできるので気が楽だろう。&lt;/p&gt;

&lt;p&gt;実装が簡単そうなアイデアでもあるので、いつかCIを実装する日まで覚えておきたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ソフトウェアアーキテクトは何をするのか?</title>
          <link>https://www.kaitoy.xyz/2016/01/11/who-is-software-architect/</link>
          <pubDate>Mon, 11 Jan 2016 14:41:29 -0700</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2016/01/11/who-is-software-architect/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/10/12/who-is-software-architect.html&#34;&gt;What Does a Software Architect Do?&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;君のプロジェクトにはソフトウェアアーキテクトが居るだろうか?
必要だと思う?&lt;/p&gt;

&lt;p&gt;まあ、ほとんどの&lt;a href=&#34;http://www.yegor256.com/2015/11/21/ringelmann-effect-vs-agile.html&#34;&gt;アジャイルチーム&lt;/a&gt;はそのような役割を明確には定義せず、民主的な感じで働く。
全ての重要な技術的な意思決定はチーム全体で議論され、最多数の投票を得た解決策が採用される。
しばらくして、このようなチームが「ソフトウェアアーキテクト」バッジを誰かのTシャツに付ける事に決めたときは、もっとも評判のいいプログラマがそのバッジを手にする。&lt;/p&gt;

&lt;p&gt;このバッジが彼の責務を変えることはまれだけども。
結局、チームは同じように働き続け、全員を巻き込んだ技術的議論を楽しむ。
つまり、ソフトウェアアーキテクトは責務が明確に定義された役割というよりもステータスになる。
それは最年長で最も権限のある人へのチームメンバからの尊敬の印になる。そうだろ?&lt;/p&gt;

&lt;p&gt;全く間違っている!&lt;/p&gt;

&lt;h2 id=&#34;アーキテクトは品質の責任を負う&#34;&gt;アーキテクトは品質の責任を負う&lt;/h2&gt;

&lt;p&gt;普通はアーキテクトは最も知識、スキル、経験、権限がある人がなるということは明らかだ。
もちろん普通はアーキテクトは他の人よりもものを知っていて、必要に応じて外交的指導的手腕を発揮してその知識を伝達する。
アーキテクトは普通はチームの中で最も賢いやつだ。&lt;/p&gt;

&lt;p&gt;しかしこのことは、彼をアーキテクトたらしめているものではない。&lt;/p&gt;

&lt;p&gt;そして、チームに必要なものでもない。&lt;/p&gt;

&lt;p&gt;私のソフトウェアアーキテクトの定義こうだ。
アーキテクトは品質の責任を負う人だ。&lt;/p&gt;

&lt;p&gt;「責任 (blame)」を職責 (accountability) とか 責務 (responsibility) と言い換えてもいいが、私は「責任 (blame)」という言葉を使うのがいいと思う。
なぜなら、開発中の製品の全ての品質問題がアーキテクトの個人的な失敗であることをより強調するからだ。
もちろん、その責任の対価として、品質がよかった場合には満足した顧客からの称賛は全てアーキテクトのものだ。&lt;/p&gt;

&lt;p&gt;これがチームに必要なものだ。
開発するソフトウェアの品質に対して誰かが個人的に責任を負うのだ。&lt;/p&gt;

&lt;h2 id=&#34;プロジェクトマネージャの仕事は-アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすること&#34;&gt;プロジェクトマネージャの仕事は、アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすること&lt;/h2&gt;

&lt;p&gt;アーキテクトが他のメンバにどのように責任を委譲するかはアーキテクト自身の仕事だ。
知識やスキル、&lt;a href=&#34;http://www.yegor256.com/2014/08/13/strict-code-quality-control.html&#34;&gt;品質管理ツール&lt;/a&gt;、ユニットテストフレームワーク、権限、コーチング、&lt;a href=&#34;http://www.yegor256.com/2016/01/05/how-to-punish-employees.html&#34;&gt;体罰&lt;/a&gt;、何を使おうとも、それが彼の仕事だ。
&lt;a href=&#34;http://www.yegor256.com/2015/09/22/micromanagement.html&#34;&gt;プロジェクトマネージャ&lt;/a&gt;は品質管理をソフトウェアアーキテクトに委譲した。
それをさらにどう委譲するかはソフトウェアアーキテクト&lt;a href=&#34;http://www.yegor256.com/2015/02/23/haircut.html&#34;&gt;次第だ&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ソフトウェアアーキテクトの役割は全てのプロジェクトにおいて重大だ。
たとえたった二人のプログラマが同じデスクで働いている場合でもだ。
二人のうち一人はアーキテクトでなければならない。&lt;/p&gt;

&lt;p&gt;理想的なアーキテクトは上記の長所の全てを持つ。
彼は全員の意見を聞いて考慮に入れる。
彼はよいコーチであり先生だ。忍耐もある。
彼は効果的な伝達者であり交渉人だ。
外交官だ。
技術的な領域のエキスパートだ。&lt;/p&gt;

&lt;p&gt;しかし、たとえこうした長所全てを持たなくても、彼の決定は常に最終決定だ。&lt;/p&gt;

&lt;p&gt;そして、プロジェクトマネージャの仕事は、アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすることだ。
これが委譲というものだ。
責任には常に権力が伴う。&lt;/p&gt;

&lt;p&gt;プロジェクトマネージャは定期的にアーキテクトの成果を評価すべきだ。
チームで開発中の製品の品質はアーキテクトの個人的な(!)責任だということを思い出してほしい。
どんな問題であっても彼の問題だ。
彼を責めたり罰したりすることを恐れてはいけない。
ただし、罰を有効なものにするためには、アーキテクトの行動に対して全力で応えるべきだということをを忘れてはいけない。
繰り返すが、彼の決定は最終決定だ。&lt;/p&gt;

&lt;p&gt;もしプロジェクトマネージャが製品の品質に満足せず、またアーキテクトがその状況を改善しないなら、アーキテクトを&lt;a href=&#34;http://www.yegor256.com/2015/09/16/how-to-fire-someone-right.html&#34;&gt;交代&lt;/a&gt;させる。
彼をプログラマに降格させ、他のプログラマをアーキテクトに昇格させる。
ただし、チームにアーキテクトは常に一人だけで、彼の決定が最終的なものであることを忘れてはいけない。&lt;/p&gt;

&lt;p&gt;それが完璧な製品を作れる可能性をもつただ一つの方法だ。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/0fuEgmibJc4&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/&#34;&gt;スタンドアップミーティングに関する記事&lt;/a&gt;でも言っていた責任の委譲がこの記事でも触れられている。
プロジェクトマネージャは技術的な責任を誰かに委譲して、そいつをアーキテクトと呼べということだ。
責任には権限が伴うので、アーキテクトは技術面での最終決定権を持つ。&lt;/p&gt;

&lt;p&gt;それだけ。Yegorの他の記事に比べてシンプルな主張。
もう少し、アーキテクトが品質を確保するために何をすべきかといったことが書いてあると期待してたが。&lt;/p&gt;

&lt;p&gt;責任を委譲してそれに権限が付随するのか、権限を委譲してそれに責任が付随するのか、という細かい疑問はあるが、この記事の主な主張に対しては特に何も言うことがない。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>スタンドアップミーティングはダメマネージャーが好む手法</title>
          <link>https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</link>
          <pubDate>Tue, 11 Aug 2015 22:35:09 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2015/01/08/morning-standup-meetings.html&#34;&gt;Daily Stand-Up Meetings Are a Good Tool for a Bad Manager&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;スタンドアップミーティング (または単純にスタンドアップ)は、「チームマネージャに状況報告をするためのデイリーチームミーティング」であるとWikipediaに書かれている。
こうしたミーティングは、ソフトウェア開発チームの間でとても人気な手法ではあるが、単なる悪であり、よいマネージャは決してやらない。
以下、その理由を説明する。&lt;/p&gt;

&lt;p&gt;私は、スタンドアップのやり方が適切だったり不適切だったりする、と言いたいわけではない。それについて述べた記事は大量にある。
また、スタンドアップを上手く機能するように実施する方法についてアドバイスしようとしているわけでもない。
よいマネージャはデイリースタンドアップを決して実施すべきでないと言っているのだ。
スタンドアップは、単に「機能しない」だけでなく、非常に悪い、時に破壊的なものをマネジメントプロセスにもたらす。それがアジャイルかどうかにかかわらず。
一方、ダメなマネージャは常に、デイリースタンドアップを重要なマネジメント手法として使う。&lt;/p&gt;

&lt;p&gt;私の意図を説明するため、マネジメントをいくつかの異なった視点から見ながら、よいマネージャとダメなマネージャが仕事をどのように進めるかを比べてみよう。&lt;/p&gt;

&lt;h3 id=&#34;情報&#34;&gt;情報&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャは進捗を尋ねる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;オフィスを歩き回り進捗を訪ねて回るのは、ひどいマネージャの崇高な習慣だ。
彼は、プロセスと情報伝達フローを適切に構築できるほど賢明ではなく、チームが何をしているかを知らない。
しかし、彼は進捗を知る必要がある。彼もまた上司からちょくちょく尋ねられるからだ。
必要な情報を収集する唯一の方法は、チームに「今何の作業をしているの?」と尋ねることだ。
朝のスタンドアップは、メンバの作業内容を知らないことに気付かれずに、このうっとうしい質問を正式に尋ねる最高の場だ。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは必要なときに報告を受ける。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;プロジェクトマネージメントにはコミュニケーション管理が必要だ。
情報伝達フローが適切に構成されていれば、チームメンバはいつどのようにマネージャに報告すればいいかが分かる。
何か問題が起きたとき、そういう状況をどのように報告しなければいけないかを全員が知っている。即時、直接報告するのだ。
作業が完了したとき、必要に応じてプロジェクトマネージャにどのように知らせるかを全員が理解している。
完璧なプロジェクトマネージャは決してチームに質問しない。代わりに、チームが必要なときにマネージャに報告する。
そして、報告を怠るメンバが出たときには、その壊れたコミュニケーションチャネルを修復するのがよいプロジェクトマネージャだ。
ただし、情報収集のためにデイリーミーティングは決して実施しない。&lt;/p&gt;

&lt;p&gt;よいマネージャとして、何がゴールで何がプロジェクトマネージャ(またはスクラムマスタ)として重要かをチームに伝えるべきだ。
チームメンバは、マネージャがチームの進捗、リスク、障害、失敗について知るために何が重要であるかを知っているべきだし、チームメンバがマネージャの期待に沿えなければどんなトラブルに陥るかを理解しているべきだ。
プロジェクトやチームが取り組んでいる最も重要な課題についてをチームに伝えることは、よいマネージャとしてすべき仕事だ。
また、よいチームメンバとしては、重要な情報をつかんだら、すぐにマネージャに知らせることが重要だ。
これが完璧なマネージメントというものだ。&lt;/p&gt;

&lt;p&gt;もしそのようなチームワークを築いたなら、開発者が今日何をしてどんな問題にあったかを、明日の朝まで待ってから尋ねる必要はなくなる。
マネージャはこういった情報をもっと早く、まさに必要なタイミングで知るようになる。
オフィスの外にいるときでさえ、プロジェクトで起こっていることを知ることができるようになる。
実際には、オフィスは全く不要にさえなるが、これはまた別の機会に議論したい。&lt;/p&gt;

&lt;p&gt;デイリースタンドアップはプログラマ間で情報交換する最高の機会で、スクラムマスタに報告してフィードバックを受けるだけの場ではないと言う人がいるかもしれない。
もう一度、同じことを言うが、なぜ、その日の必要になった時点で情報交換をしないのか?
なぜ、10人のメンバを毎朝集めて、その内たった5人だけに関係することを議論する必要がある?
答えよう。ダメなマネージャは、チームメンバ間で情報交換する場を用意する他の方法を知らず、朝のスタンドアップを適切なコミュニケーションモデルの代わりとして使う。
こういったミーティングは、マネージャが熱心に働いていて、大げさな給料を受け取るに値するかのような印象を与える。
対照的に、よいマネージャは定期的な状況報告ミーティングをいっさい実施しない。
なぜなら、効果的なコミュニケーションツールの使い方を知っているからだ。
例えば、問題追跡ツール、メール、コードレビュー、意思決定ミーティング、ペアプログラミングなど。&lt;/p&gt;

&lt;h3 id=&#34;責任&#34;&gt;責任&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャはマイクロマネージメントをする。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ダメなマネージャはプロジェクトマネージメントのことをほとんど知らないので、大きな不安を抱えている。
彼はチームのコントロールを失うことを恐れていて、チームを信頼せず、いつも十分な情報を得ていないと感じ、上司から状況を尋ねられたときに動揺する。
このため、彼はチームメンバを抗うつ薬として使う。チームメンバが彼の言う通りのことをしているとき、彼はより安心と安定を感じる。
デイリースタンドアップミーティングは、彼がメンバに何をしているかを尋ね、代わりに何をすべきかを指示するためのすばらしい機会だ。
このマネージャは、メンバに個人の目標と計画を報告するよう強制し、必要だと感じればそれらを修正する。
次のようなやりとりをを何回聞いたことがある?「私はテストXをやるつもりです。…いや、それは来週だ。今日はYをやってくれ。」
これはマイクロマネージメントだ。デイリースタンドアップはマイクロマネージャのための完璧なツールだ。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは責任を委譲する。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理想的なマネージメントには4つのステップが必要だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;複雑なタスクを小さいサブタスクに分解する。&lt;/li&gt;
&lt;li&gt;それらを部下に委譲する。&lt;/li&gt;
&lt;li&gt;報酬と、ペナルティと、ルールをはっきりと伝える。&lt;/li&gt;
&lt;li&gt;報酬はちゃんと支払われること、ペナルティは免れられないこと、ルールは厳格に守られることを確実にする。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完璧なマネージャは日々何をするかをメンバに指示しないし、業務時間の使い方にも口を出さない。
彼は信頼し、コントロールする。
彼は、メンバに作業方法を指示して自尊心を削ぐようなことは決してしない。
すばらしいマネージャは次のようなことを言う。「今日はテストXをやるつもりだって? それは君の判断だ。最大限尊重するよ。ただ、Yが今週中に完了しなければ、君は約束どおりプロジェクトからはずされるということを忘れないでくれ。」
こういうマネージャにデイリースタンドアップが必要だろうか?
チームメンバに何をしているか聞く必要があるだろうか?
彼はメンバの計画によけいな干渉はしない。
代わりに、メンバを信頼し、成果をコントロールするだけだ。&lt;/p&gt;

&lt;p&gt;重ねて言うが、私は責任は委譲されるべきだと強く信じている。この委譲は3つの要素からなる。報酬、ペナルティ、ルールだ。
近代西洋文化の中では、これらを定めるのはむしろ難しいかもしれない。普通は長期の契約と月々の給料がある。
しかし、よいマネージャは方法を模索しないといけない。それぞれのタスクは委譲され、分離されないといけない。
これは、あるタスクに従事しているプログラマは、その成功または失敗に個人的な責任を持たなければいけないということだ。
また、そのタスクの結果が与える影響を知っていなければいけない。&lt;/p&gt;

&lt;p&gt;よいマネージャは、どんなチームメンバでも必ず責任逃れをしようとするということを理解している。
誰もがマネージャの両肩に&lt;a href=&#34;http://hbr.org/1999/11/management-time-whos-got-the-monkey/ar/1&#34;&gt;責任猿&lt;/a&gt;(訳注: 責任のメタファである猿)を返そうとする。
それは自然で不可避なことだ。デイリースタンドアップミーティングはこのたくらみを助長するだけだ。&lt;/p&gt;

&lt;p&gt;朝、君が私に進捗を聞くと、私はいくつか問題があって今週末までにタスクが完了できるか怪しいと言う。
それだけだ。私はもうそのタスクに責任がない。もし間に合わなくても私の失敗ではない。
私は失敗するかもしれないと伝えたよね?
今後、その責任は君がもつんだ。&lt;/p&gt;

&lt;p&gt;よいマネージャはこういう策略について知っていて、それを防ぐために報酬・ペナルティ・ルールを明確に規定する。
もし間に合わないかもしれないと言われたら、報酬を逃しペナルティを受けることを思い出させればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;- 締め切りに間に合わないかもしれない…
- それは残念だ。君は$200の週末ボーナスを逃すことになる。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロジェクトマネージャやスクラムマスタがこんなことを言っているのを見たことがあるかい?
あまりないと思う。そう、よいマネージャは珍獣なんだ。
しかし、よいマネージャだけが報酬・ペナルティ・ルールを明確に厳格に定義する能力を持つ。&lt;/p&gt;

&lt;p&gt;この3点が定義されれば、毎朝状況報告ミーティングをする必要はなくなる。
全てがありのままに明確になる。全員がゴールと目標を把握する。
全員が失敗したときに何が起こるかを知っているし、成功したときに何を得られるかも知っている。
マネージャは毎朝それをメンバに確認する必要はない。マネージャはメンバの進捗を確認する必要もない。
マネージャは既に非常に明確に各メンバの目標を定めている。それについて毎朝話す必要があるだろうか?&lt;/p&gt;

&lt;p&gt;ダメなマネージャは目標を定める能力がないので、毎朝メンバをマイクロマネージメントしようとする。
実際、ダメなマネージャは一日中マイクロマネージメントしている。
明確なゴールやルールがないので、チームが間違ったことをしたり何もできなかったりするのではないかと恐れている。
しょっちゅう状況確認するのはそのせいだ。
実際のところ、彼はチームの首根っこをつかんでいるのだ。&lt;/p&gt;

&lt;h3 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャは皆の前で恥をさらさせてモチベーションを下げさせる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ダメなマネージャはチームメンバにやる気を出させる適切な仕組みの作り方を知らないため、恥をさらすことへの生理的な恐怖を利用する。
誰も「忘れました」と皆の前で言いたくないのが当然だ。
デイリースタンドアップミーティングは全員を一列に並べて「昨日何をした?」と尋ねる場だ。
この恐怖の時間はチームにやる気を出させるだろ?
私はそうは思わないが。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは目標でモチベーションを上げさせる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理想的なマネージメントは、目標を定めて、チームメンバがスキル、リソース、知識、情熱を駆使してそれを達成できるようにする。
適切に定められた目標は常に3つの要素からなる。報酬、ペナルティ、ルールだ。
すばらしいマネージャは組織の目標を個人の目標に落とし込む方法を知っている。
「もし今週中にこの機能を納品できたら、会社はさらなる利益を出せる。サリー、君個人としては$500を得る。もし君がしくじったら、君は他の、あまり面白くないプロジェクトに異動することになる。」
これが完璧に定められた目標だ。毎朝、皆の前で、機能の実装を忘れてないかとか、熱心に作業しているかとか、サリーに尋ねる必要があるだろうか?
この尋問は彼女の手助けになるだろうか?
なるはずがない !
彼女は既に何のために作業しているか知っていて、動機付けは十分だ。
彼女が期日に作業を終えたら、ミーティングを開いて、皆の前で$500のチェックをあげよう。
これがよいマネージャによるミーティングの使い方だ。&lt;/p&gt;

&lt;p&gt;他にもある。
皆の前での日々の進捗報告は、チーム内最高のメンバを堕落させ、最悪にしてしまう。
主な理由は、彼らは突出した成果を出すことで他の人の気を損ねたくないからだ。
グループ内で他の皆と同じように振舞おうとするのは、人間の性だ。
皆が「まだ結果は出ていません」と報告しているときに、有能なプログラマが「全てのタスクを終えたので、他の仕事をください」と言うことを期待するのは奇妙だ。
いや、一回くらいはこういうことを言うかもしれないが、しばらくするとこの有能なプログラマは熱心に作業することをやめるか、チームを抜ける。
彼は、彼の成果が際立っていることを知り、それがグループから評価されていないことを知る。マネージャが何を言おうとも。&lt;/p&gt;

&lt;p&gt;よいマネージャは、プログラマそれぞれに固有の作業速度、質、給料があることを理解する。
よいマネージャは、人によって与えるタスクを変え、異なる結果が返ってくることを期待する。
明らかに、朝全員を並ばせて、皆が同じような報告をすることを期待するのは大きな間違いだ。
この間違いは、突出した成果を出して格別な評価と報酬を得たがっている有能なメンバに破壊的な効果をもたらす。&lt;/p&gt;

&lt;p&gt;ダメなマネージャは異なる人々を異なる方法でマネージメントできない。単にやり方を知らないからだ。
そのため、デイリースタンドアップという、全員が同じような、比較しやすい成果を報告する場が必要になる。
また、皆と違った報告をする人を責めたり励ましたりもしやすい。
言い換えると、ダメなマネージャはデイリースタンドアップを平等の手段として使う。この場合の平等は、チーム全体のモチベーションを破滅させるだけだ。&lt;/p&gt;

&lt;p&gt;デイリースタンドアップや、他のあらゆる状況報告ミーティングは、怠惰で愚かなマネージャを隠して守るのにはすばらしい手段だ。
マネージャの無能っぷりをチームメンバから隠すことができる。
適正のなさを隠し、問題や挑戦やリスクへの恐れを隠す。
よいマネージャになりたいなら、デイリースタンドアップで自分自身を困らせないことだ。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Yegorは、自身が経営する&lt;a href=&#34;http://www.teamed.io/&#34;&gt;Teamed.io&lt;/a&gt;という会社でのソフトウェア開発プロジェクトを、自身が考案した&lt;a href=&#34;http://www.xdsd.org/&#34;&gt;XDSD&lt;/a&gt;という手法を使ってマネジメントしている。
上の記事は、そのXDSDを念頭に、
巷で流行っている&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0_%28%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%29&#34;&gt;スクラム&lt;/a&gt;などで行われるデイリースタンドアップにはっきりと異を唱えるものだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.agilemanifesto.org/iso/ja/&#34;&gt;アジャイルソフトウェア開発宣言&lt;/a&gt;が発表されてから14年もたち、私の会社のような古い体質の組織にもアジャイルな手法や理念はさすがに浸透していて、私の周りでもデイリーミーティングをするチームが目立つ。私としては、管理される側にとっても、管理する側にとっても、いい情報交換の場だとは思うが、だらだら長くなりがちで、じわじわ煩わしくなるのが難。&lt;/p&gt;

&lt;p&gt;Yegorは、定例ミーティングなんかやめて、情報交換は必要なときに必要な人どうしでやれよと言っているわけだけど、悪いニュースは隠したくなるし、いいニュースもきっかけがないと報告するのがおっくうになるのは自然の摂理ではないか。
この摂理を乗り越え、適時情報共有するための、「適切な情報伝達フロー」の作り方は、また別の記事に書かれているんだろうか。&lt;/p&gt;

&lt;p&gt;責任の委譲についてのくだりは、以前読んだドラッカーを思い出した。もしドラだけど。
ドラッカーは「権限 (authority) を委譲しろ」と言っていたけど、Yegorは「責任 (responsibility) を委譲すべき」と言っている。
また、ドラッカーは、「権限の委譲を責任の放棄と混同してはいけない。権限を委譲したらむしろマネージャの責任は大きくなる」と言っていた。
つまり、Yegorはここでさらっとドラッカーにも異を唱えていることになる。
権威によるバイアスもあるのかもしれないが、私にはやはりドラッカーの話の方がしっくりくる。責任は猿みたいに身軽に移動できるものとは思えない。
失敗した部下のボーナスを減らして別のプロジェクトに飛ばしたところで、開発の遅れを取り戻せるわけではないし、納品が遅れたら怒られるのは結局上の人たちだ。&lt;/p&gt;

&lt;p&gt;ところで、XDSDもそうっぽいけど、アジャイルな開発手法は基本的に、意欲に満ちた優秀なメンバで構成されたチームを前提に組み立てられたものだ。
私の会社を含む、日本の大企業がやっているような、経験(ほぼ)不問、サークルやバイトでの体験談を聞いて新卒一括人柄採用なんてボランティアみたいな選考方法を刷新しない限り、上手く回るようになることはない。
こんないい加減なやり方で集められた烏合の衆で、何千万も何億も稼ぐソフトウェアを作ろうってんだから、上の人たちはさぞかし大変なんだろう。意欲に欠けた部下の尻を叩くためにデイリースタンドアップをやらざるを得ないマネージャを批判するのは、ちょっと気の毒に思える。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
