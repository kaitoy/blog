<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>atom on To Be Decided</title>
    <link>https://www.kaitoy.xyz/tags/atom/</link>
    <description>Recent content in atom on To Be Decided</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2015 Kaito Yamada</copyright>
    <lastBuildDate>Mon, 21 Dec 2015 00:07:28 -0700</lastBuildDate>
    
	<atom:link href="https://www.kaitoy.xyz/tags/atom/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ReactをAtomパッケージ開発に使ってみた</title>
      <link>https://www.kaitoy.xyz/2015/12/21/hello-react/</link>
      <pubDate>Mon, 21 Dec 2015 00:07:28 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/12/21/hello-react/</guid>
      <description>私は今HPEのFort Collinsオフィスに居候している。 HPEは最近、Reactを使ったUXフレームワークであるGrommetを開発していて、私が扱っている製品もそれを使う兆しが見えてきた。 Grommetはいずれ仕事で触ることになりそうなので、まずはReactの勉強をと思い、とあるAtomパッケージの開発に敢えて使ってみた。
このエントリには、その作業の中で得た知識などについて書いた。 ただし、Reactを使った開発のノウハウみたいなものまでは得ていないので書いていない。
(因みにGrommetはGitHubで公開されているが、ほとんど話題になっておらずスターも現時点で245しかついていない。。。)

   (adsbygoogle = window.adsbygoogle || []).push({});  Reactとは ReactはFacebookが開発しているWeb UIのフレームワークで、MVCのVだけを実装したもの。 2013年に最初のバージョンが公開され、世界中で流行ってきているらしい。
その特徴(というかほぼ全容)は仮想DOM(Virtual DOM)。 ReactのAPIを使うと、リアルDOMと一対一で対応する仮想DOMのツリーを作ることができ、UIを組み立てられる。 リアルDOMの構築や更新はReactが最適化された方法でやってくれるので、性能がいいUIができるらしい。 因みに、仮想DOM自体はReact特有の技術ではなく、別の実装もある。
もう一つの特徴はJSX。 これは、JavaScriptのコードの中で、XMLみたいな構文で仮想DOMを記述するための拡張構文。 これを使うとReactコードが見やすく簡単に書けるけど、当然普通のJavaScript実行環境では動かないので、プリコンパイルなどが必要になる。
FacebookはReactを使った開発にFluxというアーキテクチャの採用を推奨している。 FluxはMVCアーキテクチャに置き換わるもので、従来の複雑なデータフローに反発し、一方向のシンプルなデータフローを提供する。 Fluxは単なるアーキテクチャで、その全体の実装を支援するフレームワークは現時点では無い。 (多分。Relayが一部支援してくれるっぽい。)
Reactを触った感想 Reactは本当にちょっとしか触っていないので、あまりよく分かっていないんだろうけど、なんだか使いにくかった。
Reactは仮想DOMを作るところしか助けてくれないので、他のことは全部自分でやらないといけない。 FacebookはReact用のウィジェットすら提供していない。 昔仕事で全部入りのDojoを使っていたので、それとのギャップをすごい感じた。
そのうえ、他のフレームワークやライブラリと組み合わせて使おうとすると仮想DOMが壁になってくる。普通のフレームワークはリアルDOMを扱うからだ。 例えば、JavaScriptを書いているとすぐjQueryを使いたくなるが、これでリアルDOMを直接いじってしまってはReactを使う意味がない気がする。
AtomパッケージでReactを使う Reactはnpmでも提供されていて、Atomパッケージの開発に簡単に使える。 パッケージのpackage.jsonのdependenciesにreactとreact-domを入れておけば、パッケージコード中で以下の様に仮想DOMを作れるようになる。
var React = require(&amp;#39;react&amp;#39;); var ReactDOM = require(&amp;#39;react-dom&amp;#39;); class MyComponent extends React.Component { render() { return &amp;lt;div&amp;gt;Hello World&amp;lt;/div&amp;gt;; } } ReactDOM.render(&amp;lt;MyComponent /&amp;gt;, node); BabelによるJSXの手動コンパイル JSXのコンパイルにはBabelを使うのがいい。 手動コンパイルにはBabelのコマンドラインツールが必要で、これはnpmで提供されている。 npmコマンドはAtomに同梱されているので別途インストールは不要。</description>
    </item>
    
    <item>
      <title>impress.jsでのプレゼン資料作成をサポートするAtomパッケージ - impress</title>
      <link>https://www.kaitoy.xyz/2015/12/19/atom-impress/</link>
      <pubDate>Sat, 19 Dec 2015 23:37:08 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/12/19/atom-impress/</guid>
      <description>Atomのパッケージを作った話。
ついでに、パッケージプロジェクト内で別のプロジェクトを取り込んで使いたい場合に、Gitのサブモジュールを使ってはダメという話。

   (adsbygoogle = window.adsbygoogle || []).push({});  impress.js impress.jsというJavaScriptライブラリがある。 HTML5とCSS3とJavaScriptでプレゼン資料を作るためのライブラリで、これを使うと、PowerPointやKeynoteといった従来のツールによるものからは一線を画す斬新な資料を作ることができる。
公式のデモを見ればその魅力を堪能できる。
デモを見ると分かるが、Preziに触発されたライブラリだ。 Preziでも非常に新鮮な資料を作れるが、ほぼ有料で、また作成した資料をPreziのサーバに置かなければいけないので、仕事で使う資料作りには使いにくい。 その点impress.jsは、MIT(とGPLv2)で公開されていて自由に無料で使えるのがよい。
ただし、Preziがスライドという概念から大きく脱却しているのに対して、実のところimpress.jsで作れる資料はあくまでスライドベースだ。 従来のものに比べてスライドの並びに制約がなく、スライド間の遷移がダイナミックというだけだ。 impress.jsでもまあ工夫すればPreziのような資料は作れるが。 独自のオーサリングツール/ビューワに依存するPreziに対し、impress.jsは標準的なHTML/CSS/JavaScriptにだけ依存しているので、jQueryなどのWeb技術を活用してスライドを作れるという副次的なメリットはある。
impress.jsは、2012年に最初のバージョンが公開されてからもう4年近く経つが、未だにそれほど広く使われている様子はない。 PowerPointが幅を利かせているせいもあるだろうが、その使い辛さから利用をためらう人が多いのではないだろうか。 impress.jsはあまりドキュメントが充実しているとは言えない。 GitHubに公開されているREADMEには、使い方はソースを見よ、それで分からないなら使うなとある。 さらにソース中には、impress.jsを使うには、HTMLとCSSのスキルに加えてデザイナーのセンスも必要とある。 かなりハードルを上げている。
このハードルをクリアしていたとしても、実際、impress.jsで資料を作るのはPowerPointに比べて10倍は大変だ。 impress.jsはスライド(impress.js用語ではステップ)間の遷移を制御してくれるだけで、各スライドのコンテンツを作るという部分に関してはなんのサポートも提供しない。 テンプレートもなければ、表やグラフを書く機能もなく、アニメーションも作れない。 そういうことをしたければ、自分で別途ライブラリを探して使うなりしないといけない。
ちょっとした図を書くにも、テキストエディタでちまちまHTMLとCSSを書いて、ブラウザで表示して確認して、思った通りになっていなければディベロッパツールでデバッグして、Web UIでも書いていたんだっけという気になってくる。
impressパッケージ そんな負担を少しでも軽くしたいと思って作ったのがimpressパッケージ。
同じ目的のツール(i.e. オーサリングツール)は実は既にいくつかあった。 なかでも、Hovercraft!というのが高機能で便利そう。 ただ、これらはPowerPointほど自在にスライドを作れるまでには至っておらず、結局は仕上げにHTML/CSSを手でいじる作業が必要になる。(と思う。) また、jQueryのプラグイン使ってかっこいいことしたいとか言う場合にも、手でコードを書かなければいけない。
つまりテキストエディタを開かなければいけない。よってAtomを起動することになる。(私は。)
であれば、オーサリングツールもAtomに統合されていた方が便利なんじゃないの? というのがimpressパッケージを作った動機。
まだ機能は少なくて、新規資料プロジェクトの雛形生成、
ステップをリスト表示するビュー表示、
プレビューができるだけ。

ゆくゆくは、GUIでステップの配置や角度を編集する機能、GUIでステップ内の図を作成する機能を作りたい。 あとできればアニメーションを付ける機能とかも。 Hovercraft!みたいにHTML書かなくてもいいよ、というのを目指すつもりはなくて、あくまでもコーダーのための、コーディングを補助するツールを目指す。
パッケージのサブモジュール impressパッケージは、新規資料プロジェクトの雛形生成機能などのため、impress.jsプロジェクト(のフォーク)をサブモジュールとしてとりこんでいる。
最初はGitのサブモジュールコマンド(git submodule)を使って取り込んでいて、上手くいっているように見えたが、パブリッシュ後に次のような問題が発生した。 即ち、試しにimpressパッケージをインストールしてみたら、サブモジュールのフォルダの中身がからっぽだった。
これは、AtomのパッケージマネージャがパッケージをGitHub Releasesからダウンロードしてインストールするからだ。サブモジュールの中身はGitHub Releasesに登録されるアーカイブに含まれない。このGitHub Releasesの挙動は、サブモジュールを含むGitプロジェクトをクローンした場合、デフォルトではサブモジュールはクローンされないというGitサブモジュールの仕様に関係しているのかもしれない。
この問題をきっかけにGitサブモジュールについてちょっと調べてみた。 蝙蝠本によると、Git開発チームはあまりサブモジュールコマンドの開発に熱心ではなく真面目に作らなかったらしい。 また、あるブログによればサブモジュールコマンドは大分まえからオワコンらしい。このブログによれば、今は多くの場合git subtreeを使うのがいいとのこと。git subtreeは蝙蝠本にもPro Gitにも載ってないのだが。
git subtreeでプロジェクトを取り込んだ場合、親プロジェクトのクローン時にサブプロジェクトもデフォルトでクローンされる仕様だ。 (というか正しくは、サブモジュールと違って、子プロジェクトが親プロジェクトにマージされているから、一緒にクローンされるというだけ。) これを使ってimpressパッケージを構成しなおしてみたら件の問題が解決した。 因みにやりかたは、impressパッケージプロジェクトのルートにimpress.</description>
    </item>
    
    <item>
      <title>Atomパッケージをアンパブリッシュする</title>
      <link>https://www.kaitoy.xyz/2015/12/02/unpublish-atom-package/</link>
      <pubDate>Wed, 02 Dec 2015 11:23:02 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/12/02/unpublish-atom-package/</guid>
      <description>Atomのパッケージをリリースすることをパブシッシュというが、リリースを取り消すことをアンパブリッシュという。 この記事はそのアンパブリッシュのやり方などについて。
筆者の環境は以下。
 Windows 7 x64 Atom 1.2.4 Git for Windows 2.6.3  
   (adsbygoogle = window.adsbygoogle || []).push({});  アンパブリッシュのやり方 リリースしたパッケージのプロジェクトのルートフォルダ(package.jsonがあるところ)にcdして、apm unpublishを実行するだけ。
または、任意のフォルダでapm unpublish &amp;lt;パッケージ名&amp;gt;を実行する。
特定のバージョンだけアンパブリッシュしたい場合は、apm unpublish &amp;lt;パッケージ名&amp;gt;@&amp;lt;バージョン&amp;gt;。例えばapm unpublish disturb-me@0.1.0。
注意すべき点 1: Git Bashでアンパブリッシュするとエラー Git for WindowsのGit Bash上で、Windows版Atomに付属するapmでapm unpublishを実行すると以下のエラーが出る。
Error: EINVAL, invalid argument at new Socket (net.js:157:18) at process.stdin (node.js:693:19) at Unpublish.module.exports.Unpublish.promptForConfirmation (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib \unpublish.js:87:48) at Unpublish.module.exports.Unpublish.run (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\unpublish.js:126:21) at Object.module.exports.run (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\apm-cli.js:226:32) at Object.&amp;lt;anonymous&amp;gt; (C:\Users\Kaito\AppData\Local\atom\app-1.2.4\resources\app\apm\lib\cli.js:6:7) at Object.</description>
    </item>
    
    <item>
      <title>ありがとうさようならjapanese-wrap</title>
      <link>https://www.kaitoy.xyz/2015/11/16/thanks-bye-bye-japanese-wrap/</link>
      <pubDate>Mon, 16 Nov 2015 22:38:11 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/11/16/thanks-bye-bye-japanese-wrap/</guid>
      <description>テキストエディタAtomのとある有名なパッケージの話。

   (adsbygoogle = window.adsbygoogle || []).push({});  以前の記事でも触れたjapanese-wrap。 日本語が画面の端でうまく改行(softwrap)してくれない問題を解決してくれるパッケージ。 Atomで日本語を書く殆どの人がインストールしているであろうパッケージだが、先日11/12にリリースされたAtom 1.2でCJK文字 (中国語・日本語・朝鮮語・ベトナム語の文字)のsoftwrapへの対応が実装されたので、もはや不要になった。
むしろ、Atom 1.2でjapanese-wrapを有効にすると、以下のように残念なことになる。

japanese-wrapにはずっとお世話になってきたので申し訳なく名残惜しくもあるが、AtomのSettingsからDisableまたはUninstallさせてもらうしかあるまい。すると以下の様に直る。

ありがとうさようならjapanese-wrap。</description>
    </item>
    
    <item>
      <title>AtomにおけるGIF画像のキャッシュ</title>
      <link>https://www.kaitoy.xyz/2015/09/07/caching-gifs-on-atom/</link>
      <pubDate>Mon, 07 Sep 2015 20:10:31 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/09/07/caching-gifs-on-atom/</guid>
      <description>以前、disturb-meというAtomパッケージを作ったというエントリを書いた。 このエントリでは、disturb-meに見つけたバグの修正のなかで、AtomがGIF画像をキャッシュする問題に対応したという話を書く。

   (adsbygoogle = window.adsbygoogle || []).push({});  disturb-meのバグ 以前のエントリの最後にも書いた通り、disturb-me 1.0.0には、ループしないGIFアニメーション画像を設定で指定した場合、そのアニメーションが画像の初回表示時にしか再生されないというバグがある。
disturb-meは、Ctrl+Alt+d Ctrl+Alt+mと入力すると画像を表示し、もう一度それを入力すると画像を消す。 デフォルトで表示する画像はAtomのロゴで、表示を始める時と消す時にGIF画像でループしないアニメーションを再生する。

このデフォルトの状態で、一度Atomロゴを表示して消して、再度表示して消すと、消すときのアニメーションが再生されない。(表示を始める時のアニメーションはなぜか再生される。)
バグの原因 disturb-meは、imgタグをAtomウィンドウ内に追加した後、そのsrc属性に画像へのパスをセットして画像を表示させるが、どうもAtom(のChromium)が画像をキャッシュしてくれるせいで、一度表示し終わったGIFアニメーションは二度と再生されない模様。 なぜ表示開始時のアニメーションが再生されるかは不明。
バグ修正 外部リソースをロードするときにブラウザによるキャッシュを回避するには、URLにランダムな値をもつクエリストリングを付けるのが常套手段。
今回のバグも、srcにセットするGIF画像のパス(URL)にそのようなクエリストリングをつければよい。 例えば、C:\images\hoge.gifを表示したいなら、&amp;lt;img src=&amp;quot;C:\images\hoge.gif?time=1441559906660&amp;quot;&amp;gt;&amp;lt;img&amp;gt;という風にする。 ここでtimeの値にはDate.now()とかで毎回違う値を生成して使う。
Atomプロトコルの問題 ここで一つ問題が。disturb-meがデフォルトで使うAtomロゴの画像はパッケージに含まれていて、そういうリソースのURLにはAtomプロトコルを使うのが普通。 Atomプロトコルを使うと、atom://disturb-me/assets/atom/white/atom_born.gifみたいに書いて、パッケージ内の相対パスでリソースを指定できる。
このAtomプロトコルが、今の時点(Atom v1.0.11)でクエリストリングに対応していない。困った。
Atomプロトコルの問題への対応 いい機会なので、Atomのソースをfork、cloneして、Atomプロトコルを(簡易的に)クエリストリングに対応させ、ビルドして確認し、プルリクエストを送ってみた。これについてはまた別のエントリで書くかもしれない。
このプルリクエストが取り込まれるまでの暫定対策として、Atomプロトコルハンドラのソースを見て、AtomプロトコルのURLからリソースのファイルシステム上での絶対パスを導いている部分をdisturb-me内にパクって、srcにセットする値としてatom://を使わないようにした。
これでちゃんと動いた。</description>
    </item>
    
    <item>
      <title>Atomウィンドウ内で画像を動かすパッケージ - disturb-me</title>
      <link>https://www.kaitoy.xyz/2015/09/06/disturb-me/</link>
      <pubDate>Sun, 06 Sep 2015 20:18:14 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/09/06/disturb-me/</guid>
      <description>Atomのパッケージを見ていて、便利なパッケージが沢山あるなぁと思いつつ、真面目なパッケージばかりでもつまらないので、たまには不真面目で役に立たないパッケージがあってもいいかと思って作ったパッケージの話。

   (adsbygoogle = window.adsbygoogle || []).push({});  disturb-me 作ったのはdisturb-meというパッケージ。 Ctrl+Altを押しながらdとmを押すとAtomウィンドウ内に画像が表示され、その画像がランダムに動き回り作業の邪魔をするというもの。
画像はパッケージの設定から指定できる。デフォルトではAtomのロゴ。
最初はpac-m●nというパッケージ名にして、ゲーム界のミッキーことパ●クマンが動き回るパッケージにしようと思ってたけど、バンダイナムコからダメだと言われてしまった。 この構想はいつかカタログIPオープン化プロジェクトを利用して実現しようと思う。
disturb-meの作り方 以前別のエントリでAtomパッケージの作り方の基本について書いたので、ここではそこで書かなかったことを書く。
 メインスクリプト - コマンド
今回はコマンドを追加するのでCommandRegistryを使う。 CommandRegistryのインスタンスにはatom.commandsでアクセスでき、そのaddメソッドでコマンドを追加できる。
addメソッドの引数は、第一引数から順に、
 target: コマンドを有効にするDOM要素か、それを示すCSSセレクタ。 commandName: コマンドパレットに表示するコマンド名。全部小文字で、単語をハイフンでつないで、パッケージ名を先頭につけるのがルール。 callback(event): コマンドを実行したときに呼ばれるメソッド。  
disturb-meのコマンドはAtomウィンドウ内のどこでも有効にしたいので、第一引数にはAtomウィンドウを表すカスタムタグであるatom-workspaceを指定する。 コードは以下の感じ。
activate: (state) -&amp;gt; @subscriptions = new CompositeDisposable @subscriptions.add atom.commands.add &amp;#39;atom-workspace&amp;#39;, &amp;#39;disturb-me:toggle&amp;#39;: =&amp;gt; @toggle() toggle: -&amp;gt; # 画像を挿入したり削除したりするコード。 
toggleの中では画像を挿入したり削除したりするわけだけど、この処理は、その画像を表す別のクラスにまかせることにする。 のでtoggleは以下のように書く。
@disturber: null toggle: -&amp;gt; if @disturber? @disturber.stop() @disturber = null else @disturber = new Disturber() document.</description>
    </item>
    
    <item>
      <title>Atomパッケージを作る - ワード境界を日本語対応させるパッケージ: japanese-word-selection</title>
      <link>https://www.kaitoy.xyz/2015/08/21/japanese-word-selection/</link>
      <pubDate>Fri, 21 Aug 2015 15:31:41 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/08/21/japanese-word-selection/</guid>
      <description>このブログはAtomというGitHubが開発したテキストエディタを使って書いている。 このエントリは、そのAtomのパッケージを作ってみたというお話。

   (adsbygoogle = window.adsbygoogle || []).push({});  Atomとは Atomは、2015/6/25にバージョン1.0がリリースされたばかりの新しいテキストエディタで、そのせいもあってか日本語サポートはあまり充実していない。 例えば、テキストを画面の端で折り返す「Soft Wrap」という機能はマルチバイト文字に対応しておらず、日本語で横に長い文を書いたりすると画面からはみ出てしまって不便。
しかしAtomは、パッケージなる、機能を拡張できるプラグインみたいな仕組みを持っていて、例えば上記Soft Wrapの問題はjapanese-wrapというパッケージをインストールすることで解決できる。 パッケージは誰でも作って配布することができる。
日本語のワード境界 Atomでブログを書いていて不満を感じたのは、日本語のワード境界をちゃんと判定してくれないところ。
以前は(今もたまに)サクラエディタという和製テキストエディタを使っていて、日本語文の中の一語をダブルクリックで選択するという操作をよくやっていた。 例えば、「Atomのパッケージは便利」という文があったら、「パッケージ」の辺りをダブルクリックすると「パッケージ」という単語を選択できる。
Atomでも癖でこの操作をすると、妙に広い範囲が選択されてしまう。 上記例だと「Atomのパッケージは便利」全体が選択されてしまう。不便。
japanese-word-selection この問題を解決してくれそうなパッケージを探したけど見つからなかったので、いい機会と思い自分で作ったのがjapanese-word-selection。ソースはGitHubに。
インストールして有効にすると、日本語のワード境界を判定するようになる。実のところ、とりあえずは文字種の境目を見ているだけ。ひらがな、カタカナ、半角カタカナ、漢字に対応。 特殊文字の全角版の処理どうするとか、あまり深く考えて作ってないけど、使ってて変な挙動を見つけたらおいおい直すということで。
とりあえず、Edit &amp;gt; Text の Delete to Previous Word Boundary と Delete to Next Word Boundary がちゃんと動かないのは見つけた。パッケージで上書きした処理を通っていない気がする。けど、デフォルトでキーバインディングもないし、あまり使われなそうな機能なのでほっておく。
Atomのパッケージの作り方 パッケージの作り方は、Atom Flight Manualのこのあたりを参考に。 Atom Flight ManualにはAtomの使い方からパッケージの作り方まで体系的に纏められているので一度は通して読みたい。
パッケージ開発にあたって、前提として知っておくべきは、AtomはElectronという実行環境の上で動いているということ。 (Atomが先で、そこからElectronがスピンオフした。)
ElectronはざっくりNodeとChromium(Google ChromeのOSS版)でできていて、その上で動くアプリケーションは、HTMLとCSSで書いた画面をChromiumで表示して、それをNodeで動かすJavaScriptで制御する、という形で実装される。AtomはJavaScriptの代わりに、より高級なCoffeeScriptを使っているので、パッケージを作る際はCoffeeScriptのコードをがりがり書くことになる。
パッケージはnpmのパッケージっぽく書く。
AtomはMVVMな感じの設計になっていて、コアのViewModelとかをパッケージからいじることでいろんな機能を実現できる。
以下、備忘録として、japanese-word-selectionを作った時にやったことを書いておく。Atomのバージョンは1.0.7。
 パッケージテンプレート生成
Atomを起動して、Ctrl+Shift+Pでコマンドパレットを開いて、generate packageと入力してEnter。 Package Generatorが起動して、作成するパッケージの名前を聞かれるのでjapanese-word-selectionを入力。(因みに、パッケージ名にatom-というプレフィックスを付けているのをたまに見るが、これは推奨されていない。) するとパッケージのテンプレートが作成され、それを読み込んだAtomウィンドウが開く(下図)。
パッケージ構成については概ね以下の感じ。
 keymaps: キーバインディングを定義するcsonファイルをいれる。 lib: パッケージの機能を実装するCoffeeスクリプトを入れる。  デフォルトで「パッケージ名.</description>
    </item>
    
  </channel>
</rss>