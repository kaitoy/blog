<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>https://www.kaitoy.xyz/tags/yegor256/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2018</rights>
    <updated>2016-06-25 18:00:29 -0600 -0600</updated>

    
      
        <item>
          <title>ソフトウェアプロジェクトの7つの大罪</title>
          <link>https://www.kaitoy.xyz/2016/06/25/seven-deadly-sins-of-a-software-project/</link>
          <pubDate>Sat, 25 Jun 2016 18:00:29 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2016/06/25/seven-deadly-sins-of-a-software-project/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2015/06/08/deadly-sins-software-project.html&#34;&gt;Seven Deadly Sins of a Software Project&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;保守性は近代ソフトウェア開発において&lt;a href=&#34;http://www.yegor256.com/2014/10/26/hacker-vs-programmer-mentality.html&#34;&gt;最も重要な美徳だ&lt;/a&gt;。
&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BF%9D%E5%AE%88%E6%80%A7&#34;&gt;保守性&lt;/a&gt;は基本的に、新規開発者が本格的な修正を始める前に必要な学習時間で測ることができる。
学習時間が長いほど保守性は低い。
必要な学習時間が無限に近いプロジェクトもあるが、これは文字通り保守不能だ。
私はソフトウェアを保守不能にする7つの基本的で致命的な罪があると考えている。
それらについてここに書く。&lt;/p&gt;

&lt;h2 id=&#34;アンチパターン&#34;&gt;アンチパターン&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;ap.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/ap.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;不幸にも、我々が使っているプログラミング言語は柔軟すぎる。
可能なことが多過ぎ、禁止されていることは少なすぎる。
例えばJavaは、数千のメソッドを持った単一の「クラス」でアプリケーション全体を記述することに何の反抗もしない。
このアプリケーションは技術的にはコンパイルして実行できる。
しかしこれは&lt;a href=&#34;https://maku77.github.io/program/god-class.html&#34;&gt;ゴッドオブジェクト&lt;/a&gt;と呼ばれるよく知られたアンチパターンだ。&lt;/p&gt;

&lt;p&gt;つまり、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;アンチパターン&lt;/a&gt;は技術的には設計に取り入れることができるが、一般的には取り入れるべきではないとされている。
言語ごとに多くのアンチパターンがある。
プロダクトに使われているアンチパターンは、生きている有機体の中の腫瘍のようなものだ。
いったん成長し始めると止めるのは非常に難しい。
やがて体全体が死に至る。
やがてソフトウェア全体が保守不能になり、書き直さなければならなくなる。&lt;/p&gt;

&lt;p&gt;ひとたびアンチパターンを使ってしまうと、その量は次第に増え、「腫瘍」は育つばかりだ。&lt;/p&gt;

&lt;p&gt;これは特にオブジェクト指向言語(Java、C++、Ruby、Python)に当てはまる。
これらが手続き型言語(C、Fortran、COBOL)から多くを引き継いでしまっているからだ。
また、OOP開発者が手続き型で命令的な思考をする傾向にあるからだ。残念なことに。&lt;/p&gt;

&lt;p&gt;ところで、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%B3%E3%83%81%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;既存の有名なアンチパターン&lt;/a&gt;のほかに、私は以下のものもダメなコーディング法だと考えている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/&#34;&gt;NULL参照&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2016/01/03/oop-alternative-to-utility-classes/&#34;&gt;ユーティリティクラス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html&#34;&gt;可変オブジェクト&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/&#34;&gt;GetterとSetter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/&#34;&gt;オブジェクト関係マッピング(ORM)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;シングルトン&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2015/03/09/objects-end-with-er.html&#34;&gt;Controllers、Managers、Validators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2015/02/20/utility-classes-vs-functional-programming.html&#34;&gt;Public Static メソッド&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2015/04/02/class-casting-is-anti-pattern.html&#34;&gt;キャスト&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;私ができる実践的な提案は、読んで学ぶということだけだ。
&lt;a href=&#34;http://www.yegor256.com/2015/04/22/favorite-software-books.html&#34;&gt;ここ&lt;/a&gt;に挙げた本か私の著書「&lt;a href=&#34;http://www.yegor256.com/elegant-objects.html&#34;&gt;&amp;ldquo;Elegant Objects&lt;/a&gt;」が多分助けになるだろう。
常にソフトウェアの品質を疑い、「動く」ということだけで満足してはいけない。
ちょうど癌のように、診断が早ければ早いほど生き残る可能性が大きい。&lt;/p&gt;

&lt;h2 id=&#34;追跡不能な変更&#34;&gt;追跡不能な変更&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;uc.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/uc.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;コミット履歴を見るとき、全ての個々の変更に対して、何を、誰が、なぜ変更したのかがわからないといけない。
さらに、これら3つの情報を得るのにかかる時間は秒単位で計測しないといけない。
殆どのプロジェクトがこのようにできていない。
以下に実践的な提案を示す。&lt;/p&gt;

&lt;h4 id=&#34;常にチケットを使う&#34;&gt;常にチケットを使う&lt;/h4&gt;

&lt;p&gt;プロジェクトやチームがどんなに小さくても、例え一人だけでも、修正しようとしている全ての問題に対してチケット(GitHub issues)を作れ。
チケットに問題の簡単な説明とそれに対する考えを記述しろ。
このチケットをその問題に関する全ての情報の一時的なストレージとして使え。
将来、他の誰かがその「不可解なコミット」が何であるかを理解するために参照する可能性のある全ての情報をそこに書け。&lt;/p&gt;

&lt;h4 id=&#34;コミットからチケットを参照する&#34;&gt;コミットからチケットを参照する&lt;/h4&gt;

&lt;p&gt;言うまでもないが、全てのコミットにはメッセージが付いていないといけない。
メッセージのないコミットはまったくひどい悪習だ。議論の余地はない。
しかしメッセージだけでは不十分だ。
全てのメッセージはチケット番号で始まらないといけない。
GitHub(君ももちろん使っていると思うが)は自動でコミットとチケットをリンクし、変更の追跡可能性を高めてくれる。&lt;/p&gt;

&lt;h4 id=&#34;何も消さない&#34;&gt;何も消さない&lt;/h4&gt;

&lt;p&gt;Gitは「強制」push、つまりサーバに既にあるブランチ全体を上書きするpushを許している。
これは開発履歴を破壊する方法の例のひとつだ。
また、GitHubのチケットを「きれい」にするためにコメントを削除するのをよく見るが、これはまったくの間違いだ。
何であれ決して消すな。
履歴がどんなに汚く(または乱雑に)見えても、そのまま残しておくことだ。&lt;/p&gt;

&lt;h2 id=&#34;アドホックリリース&#34;&gt;アドホックリリース&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;ahr.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/ahr.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;全てのソフトウェアはエンドユーザに届けられる前にパッケージングされなければいけない。
Javaのライブラリであれば&lt;code&gt;.jar&lt;/code&gt;ファイルにパッケージングされリポジトリにリリースされないといけない。
ウェブアプリケーションであればプラットフォームにデプロイされないといけない。
プロダクトの大きさにかかわらず、テスト、パッケージング、デプロイする正規の手順は常にあるべきだ。&lt;/p&gt;

&lt;p&gt;理想的な解決策はこの手順を自動化し、コマンドラインから単一のコマンドで実行できるようにすることだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;$ ./release.sh
...
DONE (took 98.7s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほとんどのプロジェクトはこれに程遠い。
そのリリースプロセスにはマジックが含まれていて、担当者(DevOpともいう)はあちらこちらのボタンをクリックしないといけない。
どこかにログインして、いくつかの指標をチェックして、など。
このようなアドホックリリース手順は、ソフトウェアエンジニアリング業界全体でいまだに典型的な罪である。&lt;/p&gt;

&lt;p&gt;ここで私ができる実践的なアドバイスはひとつだけだ。自動化しろ。
私は自動化に&lt;a href=&#34;http://www.yegor256.com/2014/09/11/deployment-script-vs-rultor.html&#34;&gt;rultor.com&lt;/a&gt;を使っているが、好きなのを使えばよい。
重要なのは、手順全体が完全自動化されていてコマンドラインから実行できることだ。&lt;/p&gt;

&lt;h2 id=&#34;自発的静的解析&#34;&gt;自発的静的解析&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;vsa.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/vsa.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%9D%99%E7%9A%84%E3%82%B3%E3%83%BC%E3%83%89%E8%A7%A3%E6%9E%90&#34;&gt;静的解析&lt;/a&gt;はコードの見た目を良くしてくれる。
見た目がよくなると、必然的に上手く動くようになる。
しかしこれは、チームの全員が静的解析ツールに指示されたルールに従うことを強制(!)されているときだけ有効だ。
私はこれについて&lt;a href=&#34;http://www.yegor256.com/2014/08/13/strict-code-quality-control.html&#34;&gt;Strict Control of Java Code Quality&lt;/a&gt;に書いた。
私はJavaプロジェクトでは&lt;a href=&#34;http://www.qulice.com/&#34;&gt;qulice.com&lt;/a&gt;を使い、Rubyでは&lt;a href=&#34;https://github.com/bbatsov/rubocop&#34;&gt;rubocop&lt;/a&gt;を使うが、他にも似たようなツールがほとんど全ての言語にある。&lt;/p&gt;

&lt;p&gt;どんなツールを使ってもいいが、強制しなければいけない!
静的解析ツールを使っているほとんどのプロジェクトで、開発者は単に見栄えのいいレポートを生成するだけで、コードの書き方を直そうとはしない。
そのような「自発的な」アプローチはプロジェクトにとって何のメリットもない。そればかりか、品質への錯覚を生む。&lt;/p&gt;

&lt;p&gt;私が言いたいのは、静的解析は開発パイプラインの中の必須ステップでなければいけないということだ。
もし静的解析ルールがひとつでも破られたら、ビルドを成功にしてはいけない。&lt;/p&gt;

&lt;h2 id=&#34;未知のテストカバレージ&#34;&gt;未知のテストカバレージ&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;utc.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/utc.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;簡単に言うと、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B3%E3%83%BC%E3%83%89%E7%B6%B2%E7%BE%85%E7%8E%87&#34;&gt;テストカバレージ&lt;/a&gt;はソフトウェアがユニットテストや統合テストでテストされた度合いだ。
カバレージが高いほど、テスト中に実行されたコードの量が多い。
カバレージ高いのは明らかに良いことだ。&lt;/p&gt;

&lt;p&gt;しかし、多くのプロジェクトで開発者は単にカバレージを知らない。
この指標を計測しないのだ。
テストは書いているかもしれないが、それがソフトウェアのどの程度深くまで行き渡っているか、どの部分がテストされていないのか、誰も全く知らない。
このような状態よりは、カバレージが低くても、計測されて皆にレポートされている状態の方がかなり良い。、&lt;/p&gt;

&lt;p&gt;高いカバレージは高い品質を保証するものではない。
これは明らかだ。
しかし、テストカバレージが未知であることは保守性に問題があるという明確な印だ。
プロジェクトに入った新規開発者は、修正がどの程度カバレージに影響を与えるかを確認できなければいけない。
理想的には、テストカバレージは静的解析でチェックされ、事前に決められた閾値(普通80%位)を下回ったらビルドが失敗するようになっているべきだ。&lt;/p&gt;

&lt;h2 id=&#34;ノンストップ開発&#34;&gt;ノンストップ開発&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;nd.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/nd.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;ここでノンストップが意味するのは、マイルストーンもリリースも無いということだ。
書いているソフトウェアの種類によらず、頻繁に&lt;a href=&#34;http://semver.org/lang/ja/&#34;&gt;バージョニング&lt;/a&gt;とリリースをしないといけない。
明確なリリース履歴が無いプロジェクトは保守不能なガラクタだ。&lt;/p&gt;

&lt;p&gt;これは概ね、保守性とは私が君のコードを読んで君を理解できるかということだからだ。&lt;/p&gt;

&lt;p&gt;私がソースとそのコミットとリリース履歴を見るとき、開発者の意図が何で、プロジェクトが一年前に何をしていて、今どこに向かっているのか、ロードマップは何か、といったことを説明できなければいけない。
こうした情報の全ては、ソースコード中とGit履歴(こちらがより重要)に入っていなければいけない。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/en/v2/Git-Basics-Tagging&#34;&gt;Gitタグ&lt;/a&gt;と&lt;a href=&#34;https://github.com/blog/1547-release-your-software&#34;&gt;GitHubリリース&lt;/a&gt;はそうした情報を残すための強力な道具だ。
これらをめいっぱい使え。
また、それぞれのバージョンのバイナリは直接ダウンロードできるようにしておくことを忘れるな。
プロジェクトが今バージョン3.4を開発していたとしても、即座にバージョン0.1.3をダウンロードしてテストできなければいけない。&lt;/p&gt;

&lt;h2 id=&#34;ドキュメントに載っていないインターフェース&#34;&gt;ドキュメントに載っていないインターフェース&lt;/h2&gt;

&lt;p&gt;&lt;img alt=&#34;ui.gif&#34; src=&#34;https://www.kaitoy.xyz/images/seven-deadly-sins-of-a-software-project/ui.gif&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;全てのソフトウェアは、その機能を使うためのインターフェースを持っている。
RubyのGemであれば、エンドユーザが利用できるクラスとメソッドがある。
Webアプリケーションであれば、エンドユーザが参照して操作できるWebページがある。
全てのソフトウェアプロジェクトはインターフェースを持ち、そのインターフェースは入念にドキュメント化されていないといけない。&lt;/p&gt;

&lt;p&gt;これまでに挙げた全ての項目のように、これも保守性に関することだ。
プロジェクトの新規プログラマは、ソフトウェアをインターフェースから学び始める。
そのソフトウェアが何をするものなのかを理解して自分で使ってみる、ということができなければいけない。&lt;/p&gt;

&lt;p&gt;私はここでユーザに対するドキュメンテーションの話をしている。開発者に対するものではない。
一般的に、ソフトウェア内部のドキュメンテーションには反対だ。
私は&lt;a href=&#34;http://agilemanifesto.org/iso/ja/&#34;&gt;アジャイルソフトウェア開発宣言&lt;/a&gt;に完全に同意している。
動くソフトウェアは包括的なドキュメントよりもはるかに重要だ。
しかしそれは、(開発者ではなく)ユーザが読むための「外部」ドキュメントのことを指しているわけではない。&lt;/p&gt;

&lt;p&gt;要は、エンドユーザとソフトウェアとの間の相互作用はドキュメントに明記されていなければいけない。&lt;/p&gt;

&lt;p&gt;ライブラリであれば、エンドユーザはそれを使うソフトウェア開発者だ。
コントリビュータではなく、それを「ブラックボックス」として単に使うだけの開発者だ。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/ZtWmlKi3ivc&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;一般的に認知されているベストプラクティスやアジャイル感に沿った、Yegorにしては丸い内容だ。
むしろ、現在は既にアジャイルは完全に浸透して、その次のステップとしてDevOpsをめざす時代になっているので、開発サイドだけに言及したこの内容だと少々保守的で古臭く感じさえする。&lt;/p&gt;

&lt;p&gt;ただ、改めてだけど、「&lt;a href=&#34;http://localhost:1313/2016/06/25/seven-deadly-sins-of-a-software-project/#%E8%BF%BD%E8%B7%A1%E4%B8%8D%E8%83%BD%E3%81%AA%E5%A4%89%E6%9B%B4&#34;&gt;追跡不能な変更&lt;/a&gt;」に書いてあることはいいプラクティスだと思う。
GitHubで開発するときは、全てのコミットがIssuesかPull Requestsに紐付いていて、相互に導出可能であると便利そう。
面倒だからやったことないけど。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;「&lt;a href=&#34;http://localhost:1313/2016/06/25/seven-deadly-sins-of-a-software-project/#%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%81%AB%E8%BC%89%E3%81%A3%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9&#34;&gt;ドキュメントに載っていないインターフェース&lt;/a&gt;」に書いてあることはちょっと引っかかる。
アメリカ人ってのは、分厚い細かいドキュメントなんか書いても誰も読まねーよ、ってのが基本のスタンスだと思っていた。
Steve Jobsだったら、ドキュメントが必要なくなるまでUIを洗練させろとか言いそうだ。
もしくはユースケースベースのざっくりとしたマニュアルをメインにしたり。&lt;/p&gt;

&lt;p&gt;全てのインターフェースを入念にドキュメントしろっていうのはなんだかとても日本的だ。
そうしてくれた方が使う方は助かるんだけど、作る側はドキュメントの保守が大変だ。かなり頑張って気を使っても、ドキュメントと実装のずれってのは本当に簡単に頻繁に起こる。特に大きい会社の大きいプロジェクトで、開発チームとは別にマニュアルチームがあるような場合、このずれはほとんど全く避けられない。&lt;/p&gt;

&lt;p&gt;自然言語でのプログラミングへの希望が大昔からあるようだけど、そんなものより、プログラミング言語で書いたものから自然言語のマニュアルを生成してくれるもののほうがよっぽど価値があると思う。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>継続的インテグレーションは死んだ</title>
          <link>https://www.kaitoy.xyz/2016/02/09/continuous-integration-is-dead/</link>
          <pubDate>Tue, 09 Feb 2016 00:34:41 -0700</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2016/02/09/continuous-integration-is-dead/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/10/08/continuous-integration-is-dead.html&#34;&gt;Continuous Integration is Dead&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;数日前、「&lt;a href=&#34;http://devops.com/blogs/continuous-integration-doesnt-work/&#34;&gt;なぜ継続的インテグレーションは機能しないのか&lt;/a&gt;」という私の記事が&lt;a href=&#34;http://www.devops.com/&#34;&gt;DevOps.com&lt;/a&gt;に公開された。
それとほぼ同じ日に、Twitterで非常に否定的な批評が送られてきた。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;継続的インテグレーションが機能しないとはどういうことだ。この人気なすばらしいアイデアが。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;その求めてもない質問への返事をここに書く。&lt;/p&gt;

&lt;p&gt;私はこの分野に関して多少の経験があるが、それに基いた論拠は挙げない。
代わりにロジックだけを頼りにする。&lt;/p&gt;

&lt;p&gt;ところで、私には50以上のオープンソースや営利プロジェクトで5年間Apache Continuum、Hudson、CruiseControl、Jenkinsを利用した経験がある。
さらに、数年前&lt;a href=&#34;http://www.fazend.com/&#34;&gt;fazend.com&lt;/a&gt;(2013年に&lt;a href=&#34;http://www.rultor.com/&#34;&gt;rultor.com&lt;/a&gt;に改名)というホスト型継続的インテグレーションサービスを開発した。
現在&lt;a href=&#34;http://www.travis-ci.org/&#34;&gt;Travis&lt;/a&gt;と&lt;a href=&#34;http://www.appveyor.com/&#34;&gt;AppVeyor&lt;/a&gt;のアクティブユーザでもある。&lt;/p&gt;

&lt;h2 id=&#34;継続的インテグレーションはどう機能すべきか&#34;&gt;継続的インテグレーションはどう機能すべきか&lt;/h2&gt;

&lt;p&gt;考え方はシンプルで明確だ。
&lt;code&gt;master&lt;/code&gt;ブランチ(Subversionなら&lt;code&gt;/trunk&lt;/code&gt;)に新しくコミットをする度に、継続的インテグレーションサーバ(またはサービス)はプロダクト全体のビルドを試みる。
「ビルド」というのはコンパイル、ユニットテスト、統合テスト、品質解析&lt;a href=&#34;http://www.yegor256.com/2014/06/21/casperjs-with-maven.html&#34;&gt;など&lt;/a&gt;を意味する。&lt;/p&gt;

&lt;p&gt;その結果は「成功」か「失敗」だ。
もし成功だったら「ビルドがクリーン」であると言う。
もし失敗だったら、「ビルドが壊れている」と言う。
通常、ビルドが壊れるのは、以前通っていたユニットテストを通らなくするような新しいコードをだれかがコミットしたからだ。&lt;/p&gt;

&lt;p&gt;これは問題の技術的な面だ。
この部分はいつも上手くいく。
まあ、依存が直書きされてるとか、ビルド環境が十分分離されていないとか、ビルドの並列性が完全じゃないとか、そういう問題はあるかもしれないが、この記事はそれらについてではない。
アプリケーションが上手く書かれていてユニットテストが安定しているなら、継続的インテグレーションは簡単だ。
技術的には。&lt;/p&gt;

&lt;p&gt;組織的な面を見てみよう。&lt;/p&gt;

&lt;p&gt;継続的インテグレーションというのは、ビルドを実行するサーバだけを指すのではなく、上手く機能すべき管理的/組織的プロセスだ。
プロセスが上手く機能するとは、Jez Humbleが「&lt;a href=&#34;http://www.amazon.com/gp/product/0321601912/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=390957&amp;amp;creativeASIN=0321601912&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=GKWBKGZUJGJLFMHE&#34;&gt;継続的デリバリー: ビルド、テスト、デプロイの自動化による確実なソフトウェアリリース&lt;/a&gt;」の55ページで言っていることそのものを意味する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;もしビルドが失敗したら、開発チームは何をやっていたとしてもそれを中断して、そのビルドの問題を速やかに直す。これが重要だ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;これが上手くいかず、上手くできないことだ。&lt;/p&gt;

&lt;h2 id=&#34;誰がこれを必要としているのか&#34;&gt;誰がこれを必要としているのか&lt;/h2&gt;

&lt;p&gt;既に述べた通り、継続的インテグレーションとは、開発チーム全体を止めて壊れたビルドを修正させることだ。
繰り返すが、ビルドが壊れたら直ちに、それを修正し、ビルドを安定した状態に戻すコミットを入れることに全員が集中すべきだ。&lt;/p&gt;

&lt;p&gt;ここでひとつ疑問が生じる。誰が、活動中のチーム内の誰がこれを必要としているのだろうか?&lt;/p&gt;

&lt;p&gt;一刻も早く新しい機能をリリースしたいプロダクトオーナ?
または、締め切りに責任を持つ&lt;a href=&#34;http://www.yegor256.com/2015/09/22/micromanagement.html&#34;&gt;プロジェクトマネージャ&lt;/a&gt;かもしれない。
もしくは、他の誰かが作りこんだバグをプレッシャーを受けながら修正すること嫌うプログラマかもしれない。&lt;/p&gt;

&lt;p&gt;誰がこの継続的インテグレーションを好み、誰が必要としているのか?&lt;/p&gt;

&lt;p&gt;誰でもない。&lt;/p&gt;

&lt;h2 id=&#34;実際に何が起こるのか&#34;&gt;実際に何が起こるのか&lt;/h2&gt;

&lt;p&gt;教えよう。
私は何度も見たことがある。
シナリオはいつも同じだ。
継続的インテグレーションのビルドステータスは単に無視されるようになる。
ビルドがクリーンか壊れているかにかかわらず。
そして以前のやり方が継続される。&lt;/p&gt;

&lt;p&gt;Jez Humbleが推奨するように開発を止めて問題に対応したりしない。&lt;/p&gt;

&lt;p&gt;代わりに、継続的インテグレーションサーバから来る情報を無視する。&lt;/p&gt;

&lt;p&gt;しばらくして、次の日かもしれないし月曜日かもしれないが、空いた時間を探してビルドの修正に取り組む。
これは単に、ダッシュボードの赤いボタンが嫌で緑に変えたいからだ。&lt;/p&gt;

&lt;h2 id=&#34;規律についてはどうか&#34;&gt;規律についてはどうか&lt;/h2&gt;

&lt;p&gt;そう、これには別の見方もある。
チームに規律を徹底させることもできる。
ビルドは常にクリーンで、壊した人は何らかの&lt;a href=&#34;http://www.yegor256.com/2016/01/05/how-to-punish-employees.html&#34;&gt;罰&lt;/a&gt;を受けるという厳格なルールを設けることができる。&lt;/p&gt;

&lt;p&gt;これを試すとなると、恐怖駆動型開発を実施することになる。
プログラマは、ビルドを失敗させたら少なくとも&lt;a href=&#34;http://programmers.stackexchange.com/questions/79041&#34;&gt;謝罪&lt;/a&gt;しなければならなくなるため、リポジトリへのコミットを恐れるようになる。&lt;/p&gt;

&lt;p&gt;この場合の厳格な規律(私は大好きだが)は、単に状況を悪化させる。
開発プロセス全体が遅くなり、プログラマはビルドを壊さないように自身のコードをできるだけ長い間手元に保持する。
いざコミットするとなった時、変更は巨大になっていて、マージは非常に難しいか、時に不可能になる。&lt;/p&gt;

&lt;p&gt;結果、プログラマが書いた多くのコードがコミットされること無く捨てられる。
あの恐怖因子のせいだ。&lt;/p&gt;

&lt;h2 id=&#34;ok-解決策は&#34;&gt;OK。解決策は?&lt;/h2&gt;

&lt;p&gt;それについては以前書いた。
「&lt;a href=&#34;http://www.yegor256.com/2014/07/21/read-only-master-branch.html&#34;&gt;読み取り専用マスタブランチ&lt;/a&gt;」だ。&lt;/p&gt;

&lt;p&gt;これは単純で、&lt;code&gt;master&lt;/code&gt;へのマージを一切禁止し、誰でも実行できるスクリプトを作る。
このスクリプトがマージ、テスト、コミットを実行する。
このスクリプトには例外が全く無い。
どんなブランチであっても、たった一つのユニットテストに失敗しただけでも、ブランチ全体が却下される。&lt;/p&gt;

&lt;p&gt;言い換えると、&lt;code&gt;master&lt;/code&gt;にそのコードが入る前に赤いフラグを揚げる。&lt;/p&gt;

&lt;p&gt;これで全ての問題が解決する。&lt;/p&gt;

&lt;p&gt;第一に、ビルドは常にクリーンだ。
ビルドをクリーンに保たないコードは誰もコミットできないので、単純に言ってビルドを壊すことはできない。&lt;/p&gt;

&lt;p&gt;第二に、何かを壊すという恐怖が無い。
単に技術的に壊せないのだ。
マージスクリプトから却下されることしかできない。
その場合、エラーを修正してスクリプトに再挑戦を命じる。
誰もこのやりとりを見ていないので、謝罪する必要が無い。
恐怖因子は消えた。&lt;/p&gt;

&lt;p&gt;ところで、君のプロジェクトで&lt;a href=&#34;http://www.rultor.com/&#34;&gt;rultor.com&lt;/a&gt;を利用して、この「&lt;a href=&#34;http://www.yegor256.com/2014/07/21/read-only-master-branch.html&#34;&gt;読み取り専用マスタブランチ&lt;/a&gt;」原則を徹底してみてくれ。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/3IXk5yEJMIs&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;CIは死んだというセンセーショナルなタイトルではあるが、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E7%A5%9E%E3%81%AF%E6%AD%BB%E3%82%93%E3%81%A0&#34;&gt;ニーチェ&lt;/a&gt;とは違って神なるCIを否定しているわけではない。
CIって意外と上手くいかないけど、こうすれば改善できるよという主旨の記事だ。&lt;/p&gt;

&lt;p&gt;Yegorが指摘している、ビルドステータスが無視されるようになるという一つ目の問題は、実例を多く見たことがあるわけではないが確かになんだかよく起こりそうな話だ。
そういえば私もPcap4JのTravisでのビルドエラーをもう数か月無視している。
まあこれはTravis側の問題が原因で、回避策を入れるのが気が進まないだけなんだけど。&lt;/p&gt;

&lt;p&gt;Yegorのやり方は、&lt;a href=&#34;https://gist.github.com/juno/3112343&#34;&gt;GitHub Flow&lt;/a&gt;が&lt;code&gt;master&lt;/code&gt;は常にデプロイ可能としているのを、より厳密に守るように仕組化する感じであろうか。&lt;/p&gt;

&lt;p&gt;GitHub Flowを世に広めたScott Chaconによれば、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;テストされていなかったり、ビルドを破壊するようなコードをmasterにpushした場合には、開発チーム間におけるソーシャルな取り決めを破ることになり、ちょっと気まずい思いをすることになる&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;とのことで、これはまさにYegorが恐怖因子と指摘した二つ目の問題である。
慣れない内のリポジトリへのコミットの緊張感や、CIサーバからエラー通知が来た時の焦燥感は、多くの人のストレスになっているんじゃないだろうか。
&lt;code&gt;master&lt;/code&gt;の更新をスクリプトに任せてしまえば、それでなおビルドが壊れたとしてもスクリプトのせいにできるので気が楽だろう。&lt;/p&gt;

&lt;p&gt;実装が簡単そうなアイデアでもあるので、いつかCIを実装する日まで覚えておきたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ソフトウェアアーキテクトは何をするのか?</title>
          <link>https://www.kaitoy.xyz/2016/01/11/who-is-software-architect/</link>
          <pubDate>Mon, 11 Jan 2016 14:41:29 -0700</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2016/01/11/who-is-software-architect/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/10/12/who-is-software-architect.html&#34;&gt;What Does a Software Architect Do?&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;君のプロジェクトにはソフトウェアアーキテクトが居るだろうか?
必要だと思う?&lt;/p&gt;

&lt;p&gt;まあ、ほとんどの&lt;a href=&#34;http://www.yegor256.com/2015/11/21/ringelmann-effect-vs-agile.html&#34;&gt;アジャイルチーム&lt;/a&gt;はそのような役割を明確には定義せず、民主的な感じで働く。
全ての重要な技術的な意思決定はチーム全体で議論され、最多数の投票を得た解決策が採用される。
しばらくして、このようなチームが「ソフトウェアアーキテクト」バッジを誰かのTシャツに付ける事に決めたときは、もっとも評判のいいプログラマがそのバッジを手にする。&lt;/p&gt;

&lt;p&gt;このバッジが彼の責務を変えることはまれだけども。
結局、チームは同じように働き続け、全員を巻き込んだ技術的議論を楽しむ。
つまり、ソフトウェアアーキテクトは責務が明確に定義された役割というよりもステータスになる。
それは最年長で最も権限のある人へのチームメンバからの尊敬の印になる。そうだろ?&lt;/p&gt;

&lt;p&gt;全く間違っている!&lt;/p&gt;

&lt;h2 id=&#34;アーキテクトは品質の責任を負う&#34;&gt;アーキテクトは品質の責任を負う&lt;/h2&gt;

&lt;p&gt;普通はアーキテクトは最も知識、スキル、経験、権限がある人がなるということは明らかだ。
もちろん普通はアーキテクトは他の人よりもものを知っていて、必要に応じて外交的指導的手腕を発揮してその知識を伝達する。
アーキテクトは普通はチームの中で最も賢いやつだ。&lt;/p&gt;

&lt;p&gt;しかしこのことは、彼をアーキテクトたらしめているものではない。&lt;/p&gt;

&lt;p&gt;そして、チームに必要なものでもない。&lt;/p&gt;

&lt;p&gt;私のソフトウェアアーキテクトの定義こうだ。
アーキテクトは品質の責任を負う人だ。&lt;/p&gt;

&lt;p&gt;「責任 (blame)」を職責 (accountability) とか 責務 (responsibility) と言い換えてもいいが、私は「責任 (blame)」という言葉を使うのがいいと思う。
なぜなら、開発中の製品の全ての品質問題がアーキテクトの個人的な失敗であることをより強調するからだ。
もちろん、その責任の対価として、品質がよかった場合には満足した顧客からの称賛は全てアーキテクトのものだ。&lt;/p&gt;

&lt;p&gt;これがチームに必要なものだ。
開発するソフトウェアの品質に対して誰かが個人的に責任を負うのだ。&lt;/p&gt;

&lt;h2 id=&#34;プロジェクトマネージャの仕事は-アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすること&#34;&gt;プロジェクトマネージャの仕事は、アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすること&lt;/h2&gt;

&lt;p&gt;アーキテクトが他のメンバにどのように責任を委譲するかはアーキテクト自身の仕事だ。
知識やスキル、&lt;a href=&#34;http://www.yegor256.com/2014/08/13/strict-code-quality-control.html&#34;&gt;品質管理ツール&lt;/a&gt;、ユニットテストフレームワーク、権限、コーチング、&lt;a href=&#34;http://www.yegor256.com/2016/01/05/how-to-punish-employees.html&#34;&gt;体罰&lt;/a&gt;、何を使おうとも、それが彼の仕事だ。
&lt;a href=&#34;http://www.yegor256.com/2015/09/22/micromanagement.html&#34;&gt;プロジェクトマネージャ&lt;/a&gt;は品質管理をソフトウェアアーキテクトに委譲した。
それをさらにどう委譲するかはソフトウェアアーキテクト&lt;a href=&#34;http://www.yegor256.com/2015/02/23/haircut.html&#34;&gt;次第だ&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ソフトウェアアーキテクトの役割は全てのプロジェクトにおいて重大だ。
たとえたった二人のプログラマが同じデスクで働いている場合でもだ。
二人のうち一人はアーキテクトでなければならない。&lt;/p&gt;

&lt;p&gt;理想的なアーキテクトは上記の長所の全てを持つ。
彼は全員の意見を聞いて考慮に入れる。
彼はよいコーチであり先生だ。忍耐もある。
彼は効果的な伝達者であり交渉人だ。
外交官だ。
技術的な領域のエキスパートだ。&lt;/p&gt;

&lt;p&gt;しかし、たとえこうした長所全てを持たなくても、彼の決定は常に最終決定だ。&lt;/p&gt;

&lt;p&gt;そして、プロジェクトマネージャの仕事は、アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすることだ。
これが委譲というものだ。
責任には常に権力が伴う。&lt;/p&gt;

&lt;p&gt;プロジェクトマネージャは定期的にアーキテクトの成果を評価すべきだ。
チームで開発中の製品の品質はアーキテクトの個人的な(!)責任だということを思い出してほしい。
どんな問題であっても彼の問題だ。
彼を責めたり罰したりすることを恐れてはいけない。
ただし、罰を有効なものにするためには、アーキテクトの行動に対して全力で応えるべきだということをを忘れてはいけない。
繰り返すが、彼の決定は最終決定だ。&lt;/p&gt;

&lt;p&gt;もしプロジェクトマネージャが製品の品質に満足せず、またアーキテクトがその状況を改善しないなら、アーキテクトを&lt;a href=&#34;http://www.yegor256.com/2015/09/16/how-to-fire-someone-right.html&#34;&gt;交代&lt;/a&gt;させる。
彼をプログラマに降格させ、他のプログラマをアーキテクトに昇格させる。
ただし、チームにアーキテクトは常に一人だけで、彼の決定が最終的なものであることを忘れてはいけない。&lt;/p&gt;

&lt;p&gt;それが完璧な製品を作れる可能性をもつただ一つの方法だ。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/0fuEgmibJc4&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/&#34;&gt;スタンドアップミーティングに関する記事&lt;/a&gt;でも言っていた責任の委譲がこの記事でも触れられている。
プロジェクトマネージャは技術的な責任を誰かに委譲して、そいつをアーキテクトと呼べということだ。
責任には権限が伴うので、アーキテクトは技術面での最終決定権を持つ。&lt;/p&gt;

&lt;p&gt;それだけ。Yegorの他の記事に比べてシンプルな主張。
もう少し、アーキテクトが品質を確保するために何をすべきかといったことが書いてあると期待してたが。&lt;/p&gt;

&lt;p&gt;責任を委譲してそれに権限が付随するのか、権限を委譲してそれに責任が付随するのか、という細かい疑問はあるが、この記事の主な主張に対しては特に何も言うことがない。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>オブジェクト指向プログラミングにおいてユーティリティクラスに代わるもの</title>
          <link>https://www.kaitoy.xyz/2016/01/03/oop-alternative-to-utility-classes/</link>
          <pubDate>Sun, 03 Jan 2016 23:36:01 -0700</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2016/01/03/oop-alternative-to-utility-classes/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html&#34;&gt;OOP Alternative to Utility Classes&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;ユーティリティクラス(またはヘルパークラス)は、スタティックメソッドだけを持っていて、状態を内包しない「構造体」だ。
&lt;a href=&#34;http://commons.apache.org/&#34;&gt;Apache Commons&lt;/a&gt;の&lt;code&gt;StringUtils&lt;/code&gt;、&lt;code&gt;IOUtils&lt;/code&gt;、&lt;code&gt;FileUtils&lt;/code&gt;や、&lt;a href=&#34;https://code.google.com/p/guava-libraries/&#34;&gt;Guava&lt;/a&gt;の&lt;code&gt;Iterables&lt;/code&gt;、&lt;code&gt;Iterators&lt;/code&gt;、またJDK7の&lt;code&gt;Files&lt;/code&gt;はユーティリティクラスのいい例だ。&lt;/p&gt;

&lt;p&gt;ユーティリティクラスはよく使われる共通機能を提供するので、この設計手法はJava(やC#、Rubyなど)の世界でとても人気だ。&lt;/p&gt;

&lt;p&gt;要するに我々は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Don&#39;t_repeat_yourself&#34;&gt;DRY原則&lt;/a&gt;に従い、重複を避けたい。
だから、共通コードをユーティリティクラスに入れて必要に応じて再利用する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// これはひどい設計なので再利用しないように。
public class NumberUtils {
  public static int max(int a, int b) {
    return a &amp;gt; b ? a : b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;実際、これはとても便利なテクニックだ!?&lt;/p&gt;

&lt;h2 id=&#34;ユーティリティクラスは悪だ&#34;&gt;ユーティリティクラスは悪だ&lt;/h2&gt;

&lt;p&gt;しかし、オブジェクト指向の世界では、ユーティリティクラスはかなり悪い(酷いという人さえいるかもしれない)手法だ。&lt;/p&gt;

&lt;p&gt;これについては多くの議論がある。
いくつか挙げると、Nick Malikの「&lt;a href=&#34;http://blogs.msdn.com/b/nickmalik/archive/2005/09/06/461404.aspx&#34;&gt;ヘルパークラスは悪か?&lt;/a&gt;」、Simon Hartの「&lt;a href=&#34;http://smart421.wordpress.com/2011/08/31/why-helper-singletons-and-utility-classes-are-mostly-bad-2/&#34;&gt;なぜヘルパー、シングルトン、ユーティリティクラスはだいたい間違っているのか&lt;/a&gt;」、Marshal Wardの「&lt;a href=&#34;http://www.marshallward.org/avoiding-utility-classes.html&#34;&gt;ユーティリティクラスを避ける&lt;/a&gt;」、Dhaval Dalalの「&lt;a href=&#34;http://www.jroller.com/DhavalDalal/entry/kill_that_util_class&#34;&gt;ユーティルクラスを殺せ!&lt;/a&gt;」、Rob Bagbyの「&lt;a href=&#34;http://www.robbagby.com/posts/helper-classes-are-a-code-smell/&#34;&gt;ヘルパークラスは問題の兆候&lt;/a&gt;」。&lt;/p&gt;

&lt;p&gt;また、StackExchangeにはユーティリティクラスについての質問がいくつかある。
例えば、「&lt;a href=&#34;http://stackoverflow.com/questions/3339929/if-a-utilities-class-is-evil-where-do-i-put-my-generic-code&#34;&gt;ユーティリティクラスが悪なら、どこに共通コードを書けばいい?&lt;/a&gt;」とか、「&lt;a href=&#34;http://stackoverflow.com/questions/3340032/utility-classes-are-evil&#34;&gt;ユーティリティクラスは悪&lt;/a&gt;」とか。&lt;/p&gt;

&lt;p&gt;これらの主張は要するに、ユーティリティクラスは適切なオブジェクトではないということだ。
だから、オブジェクト指向の世界に適合しない。
ユーティリティクラスは、当時の人々が機能分割パラダイムに慣れていたために、手続き型言語から受け継がれた。&lt;/p&gt;

&lt;p&gt;君がこの主張に同意し、ユーティリティクラスを使うのをやめたがっていると想定し、そいつをどのように適切なオブジェクトに置き換えるかを例を挙げながら教えよう。&lt;/p&gt;

&lt;h2 id=&#34;手続き型の例&#34;&gt;手続き型の例&lt;/h2&gt;

&lt;p&gt;例えば、テキストファイルを読んで、行で分割し、各行をトリムして、その結果を別のファイルに保存したいとする。
これはApache Commonsの&lt;code&gt;FileUtils&lt;/code&gt;を使えばできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void transform(File in, File out) {
  Collection&amp;lt;String&amp;gt; src = FileUtils.readLines(in, &amp;quot;UTF-8&amp;quot;);
  Collection&amp;lt;String&amp;gt; dest = new ArrayList&amp;lt;&amp;gt;(src.size());
  for (String line : src) {
    dest.add(line.trim());
  }
  FileUtils.writeLines(out, dest, &amp;quot;UTF-8&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上のコードはきれいに見える。
しかし、これは手続き型プログラミングであって、オブジェクト指向じゃない。
コードの各行で、データ(byteとbit)を操作し、コンピューターにどこからデータを取ってどこに書き込むかを明示的に指示している。
処理の手順を定義している。&lt;/p&gt;

&lt;h2 id=&#34;オブジェクト指向な方法&#34;&gt;オブジェクト指向な方法&lt;/h2&gt;

&lt;p&gt;オブジェクト指向パラダイムでは、オブジェクトをインスタンス化して合成すべきだ。
これはオブジェクトにオブジェクト自身のやり方でデータを管理させるためだ。
補足的なスタティックメソッドを呼ぶ代わりに、求めている挙動を提供できるオブジェクトを生成するべきだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Max implements Number {
  private final int a;
  private final int b;
  public Max(int x, int y) {
    this.a = x;
    this.b = y;
  }
  @Override
  public int intValue() {
    return this.a &amp;gt; this.b ? this.a : this.b;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下の手続き型のメソッド呼び出しは、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int max = NumberUtils.max(10, 5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下の様にオブジェクト指向的になる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;int max = new Max(10, 5).intValue();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どっちでも同じ?
いや、そうでもない。
もう少し読み進めて欲しい。&lt;/p&gt;

&lt;h2 id=&#34;データ構造ではなくオブジェクト&#34;&gt;データ構造ではなくオブジェクト&lt;/h2&gt;

&lt;p&gt;私なら、上と同じファイル編集機能をオブジェクト指向なやり方で以下の様に設計する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void transform(File in, File out) {
  Collection&amp;lt;String&amp;gt; src = new Trimmed(
    new FileLines(new UnicodeFile(in))
  );
  Collection&amp;lt;String&amp;gt; dest = new FileLines(
    new UnicodeFile(out)
  );
  dest.addAll(src);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(訳注: 上のコードは以下のコードの誤記だと思われる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;void transform(File in, File out) {
  Trimmed src = new Trimmed(
    new FileLines(new UnicodeFile(in))
  );
  FileLines dest = new FileLines(
    new UnicodeFile(out)
  );
  dest.addAll(src);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FileLines&lt;/code&gt;は&lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;を実装していて、ファイルの読み込みと書き込みの処理を内包している。
&lt;code&gt;FileLines&lt;/code&gt;のインスタンスは文字列のコレクションと全く同じ挙動をし、全てのI/O処理を隠蔽している。
このインスタンスを繰り返し処理するとファイルが読み込まれる。
このインスタンスに&lt;code&gt;addAll()&lt;/code&gt;するとファイルに書き込まれる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Trimmed&lt;/code&gt;も&lt;code&gt;Collection&amp;lt;String&amp;gt;&lt;/code&gt;を実装していて、文字列のコレクションを内包している(&lt;a href=&#34;https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;Decoratorパターン&lt;/a&gt;)。
一行が取得されるたびにトリムされる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Trimmed&lt;/code&gt;も&lt;code&gt;FileLines&lt;/code&gt;も&lt;code&gt;UnicodeFile&lt;/code&gt;も、上記スニペットに出てくる全てのクラスは小さめだ。
それぞれが自身の単一の機能に責任を持ち、つまり&lt;a href=&#34;http://d.hatena.ne.jp/asakichy/20110808/1312754662&#34;&gt;単一責任原則&lt;/a&gt;に完璧に従っている。&lt;/p&gt;

&lt;p&gt;我々側、つまりライブラリのユーザから見るとこれはそれほど重要ではないかもしれないが、ライブラリの開発者から見ると肝要だ。
80以上のメソッドを持つ3000行のユーティリティクラスである&lt;code&gt;FileUtils&lt;/code&gt;の&lt;code&gt;readLines()&lt;/code&gt;よりも、&lt;code&gt;FileLines&lt;/code&gt;の方が開発やメンテナンスやユニットテストがしやすい。
真面目な話、&lt;a href=&#34;http://svn.apache.org/viewvc/commons/proper/io/trunk/src/main/java/org/apache/commons/io/FileUtils.java?view=co&#34;&gt;そのソース&lt;/a&gt;を読んでみて欲しい。&lt;/p&gt;

&lt;p&gt;オブジェクト指向のアプローチは遅延実行を可能にする。
&lt;code&gt;in&lt;/code&gt;ファイルはそのデータが必要になるまで読まれない。
I/Oエラーで開けなかったら触られすらしない。
全ては&lt;code&gt;addAll()&lt;/code&gt;を呼んだ後に始まる。&lt;/p&gt;

&lt;p&gt;二つ目のスニペットの最終行を除く全行は、小さいオブジェクトをインスタンス化して大きいオブジェクトを合成している。
このオブジェクト合成は、データ変換を起こさないのでCPUコストはむしろ低い。&lt;/p&gt;

&lt;p&gt;さらに、二つ目のスクリプトがO(1)の空間計算量で動くのに対し、一つ目のスクリプトはO(n)で動くのは明らかだ。
これが一つ目のスクリプトでデータに対して手続き型アプローチをした結果だ。&lt;/p&gt;

&lt;p&gt;オブジェクト指向の世界では、データというものはない。オブジェクトとその挙動しかないのだ！&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/psrp3TtaYYI&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;私はユーティリティクラスは結構好きで、以下の点で有用だと思う。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ライブラリ開発者視点:

&lt;ul&gt;
&lt;li&gt;少数のクラスで多くの共通処理を実装できる。&lt;/li&gt;
&lt;li&gt;ユーティリティクラスは(普通)状態を持たないので、マルチスレッドなどを意識せずに簡単に書ける。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ライブラリ利用者視点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクトを作らなくても使えるので、オーバーヘッドが少なくコードを書くのも楽。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ユーティリティクラスのメソッド呼び出しは大抵、「&amp;lt;問題領域&amp;gt;.&amp;lt;動詞&amp;gt;&amp;lt;目的語&amp;gt;()」という形になっていて、何をやっているのかわかりやすい。&lt;/p&gt;

&lt;p&gt;上で出てきた&lt;code&gt;FileUtils.readLines()&lt;/code&gt;も、ファイルを対象に(問題領域)、行を(目的語)読みこむ(動詞)メソッドであることが一目瞭然。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ユーティリティクラス反対派の主張が、それがオブジェクト真理教の教義に照らして適切なオブジェクトではなく、オブジェクト指向の世界に適合しないという哲学的なものである時点で、ユーティリティクラスをやめる動機に全くつながらない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transform()&lt;/code&gt;の実装は、Apache Commonsを使ったやつの方が自分でクラスを作らなくて済み、開発量が少なくてよい、というのが普通の感覚ではないだろうか。&lt;/p&gt;

&lt;p&gt;さらに、Yegorの&lt;code&gt;transform()&lt;/code&gt;の実装だと、I/O処理を隠蔽しすぎて何をやっているのかコードからさっぱりわからない。
&lt;code&gt;addAll()&lt;/code&gt;するとファイルへの書き込みが発生するなんて誰も想像だにしまい。
オブジェクト真理教の神のみぞ知るといった感じの挙動だ。
こんなコードで可読性、つまり保守性が「手続き型の例」のやつより高くなるとは到底思えない。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Pcap4JがSoftware Quality Award 2015で入賞</title>
          <link>https://www.kaitoy.xyz/2015/12/03/software-quality-award-2015/</link>
          <pubDate>Thu, 03 Dec 2015 12:28:24 -0700</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/12/03/software-quality-award-2015/</guid>
          <description>&lt;p&gt;&lt;a href=&#34;http://www.teamed.io/&#34;&gt;Teamed.io&lt;/a&gt;が主催の、ソフトウェアの品質とその開発プロジェクトの品質への取り組みを競うコンテスト、&lt;a href=&#34;http://www.yegor256.com/2015/04/16/award.html&#34;&gt;Software Quality Award&lt;/a&gt;の第一回が2015年4月～11月にかけて開催された。
Teamed.ioのCTOであるYegorとは、彼のブログを和訳してここに載せている関係でたまにメールしているが、そのやりとりの中で誘われたので私も&lt;a href=&#34;https://github.com/kaitoy/pcap4j&#34;&gt;Pcap4J&lt;/a&gt;をひっさげてそれに参加した。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;優勝すると$4,096もらえるということではあったが、150以上のプロジェクトがエントリーしていて、&lt;a href=&#34;http://gulpjs.com/&#34;&gt;Gulp&lt;/a&gt;とか有名なものも入っていたので、どうせ全然ダメだろと思ってエントリー以来なにも対策しなかったが、なんと &lt;strong&gt;8位&lt;/strong&gt; 入賞を果たしてしまった。
まあ講評をみるとずいぶんこき下ろされてはいるが…&lt;/p&gt;

&lt;p&gt;因みに講評は以下の感じ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;utilパッケージがあってそこにユーティリティクラスがある。クソだ。&lt;/li&gt;
&lt;li&gt;NULLが可変オブジェクトで使われている。例えば&lt;a href=&#34;https://github.com/kaitoy/pcap4j/blob/master/pcap4j-core/src/main/java/org/pcap4j/core/AbstractPcapAddress.java&#34;&gt;AbstractPcapAddress&lt;/a&gt;。クソだ。&lt;/li&gt;
&lt;li&gt;スタティックメソッドとスタティック変数が多すぎる。文字通りどこにでもある。pcap4j-packetfactory-staticという名のスタティックメソッドだらけのモジュールまである。&lt;/li&gt;
&lt;li&gt;JavaDocに一貫性がなく、未完なものもある。&lt;a href=&#34;https://github.com/kaitoy/pcap4j/blob/master/pcap4j-core/src/main/java/org/pcap4j/core/NotOpenException.java#L21-L23&#34;&gt;これ&lt;/a&gt;とか。&lt;/li&gt;
&lt;li&gt;ほんのちょっとのissuesとたった6つのプルリクエストしかない。コミットがissuesにリンクされてない。変更のトレーサビリティはほとんどゼロだ。&lt;/li&gt;
&lt;li&gt;リリース手順が自動化されていない。&lt;a href=&#34;https://github.com/kaitoy/pcap4j/releases&#34;&gt;リリース&lt;/a&gt;がドキュメントに書かれていない。&lt;/li&gt;
&lt;li&gt;静的解析してなくて、そのせいか乱雑なコードがたまにある。&lt;/li&gt;
&lt;li&gt;スコア: 3&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;静的解析くらいは導入しようかな…&lt;/p&gt;

&lt;p&gt;ユーティリティクラスとかNULLとかスタティックメソッドは使うのやめるつもりはないけど。&lt;/p&gt;

&lt;p&gt;そういえば、入賞者にはスポンサーである&lt;a href=&#34;https://www.jetbrains.com/products.html&#34;&gt;JetBrainsの製品&lt;/a&gt;の一年ライセンスがもらえることになっていたはずだが特に連絡がないな。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>よいオブジェクトの七つの美徳</title>
          <link>https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/</link>
          <pubDate>Wed, 28 Oct 2015 13:38:47 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html&#34;&gt;Seven Virtues of a Good Object&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Martin Fowler&lt;a href=&#34;http://martinfowler.com/bliki/InversionOfControl.html&#34;&gt;曰く&lt;/a&gt;、&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ライブラリは本質的には呼び出し可能な関数の集合で、最近は普通クラス内にまとめられる。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;クラス内にまとめられた関数?
失礼を承知で言わせてもらうが、これは間違っている。
そして、これはオブジェクト指向プログラミングにおいて、クラスに対する非常に一般的な誤解だ。
クラスは関数をまとめるものではないし、オブジェクトはデータ構造体ではない。&lt;/p&gt;

&lt;p&gt;では、なにが適切なオブジェクトなのか?
どれが不適切なオブジェクトなのか?
その違いは何か?
これは論争を呼ぶ主題ではあるが、とても重要だ。
オブジェクトが何かを理解しなければ、オブジェクト指向ソフトウェアをどうやって書くんだ?
まあ、JavaやRubyなどのおかげで、書けることは書ける。
しかし、はたして良いものができるだろうか?
不幸にも、これは厳密な科学ではなく、様々な意見がある。
ここに、良いオブジェクトの特性を私なりにリストアップする。&lt;/p&gt;

&lt;h1 id=&#34;クラス-vs-オブジェクト&#34;&gt;クラス vs オブジェクト&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-1.png&#34; src=&#34;https://www.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-1.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;オブジェクトについて議論を始める前に、クラスとは何かを定義しよう。
それはオブジェクトが生まれる(インスタント化される)場所だ。
クラスの主な責任は、要求に応じて新しいオブジェクトを構築し、使われなくなったオブジェクトを破壊することだ。
クラスはその子供たちがどのように見えどのように振る舞うべきかを知っている。
言い換えれば、子供たちが従うべき契約を知っている。&lt;/p&gt;

&lt;p&gt;クラスが「オブジェクトのテンプレート」であると言われることもある。(例えば&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9_%28%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%29&#34;&gt;Wikipediaにはそう書いてある&lt;/a&gt;。)
この定義はクラスを受動的なポジションに置いているので正しくない。
この定義は、だれかがテンプレートを取得してそこからオブジェクトを構築するということを想定している。
これは、技術的には正しいかもしれないが、概念的には間違っている。
クラスとその子供たちだけが居るのであって、他の誰も関係すべきではない。
あるオブジェクトがクラスに他のオブジェクトを作るように頼み、そのクラスがオブジェクトを構築する。それだけだ。
RubyはJavaやC++に比べてこの概念をかなりうまく表現している。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;photo = File.new(&#39;/tmp/photo.png&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;photo&lt;/code&gt;オブジェクトは&lt;code&gt;File&lt;/code&gt;クラスによって構築される。(&lt;code&gt;new&lt;/code&gt;はそのクラスへのエントリポイント。)
オブジェクトは、いったん構築されると、自身に基づいて行動する。
オブジェクトは、自身を誰が構築したかとか、何人兄弟姉妹がいるかとかを知っているべきではない。
そう、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%95%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3_%28%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6%29&#34;&gt;リフレクション&lt;/a&gt;は酷いアイデアだと言っている。
それについては他の記事で詳しく書くとして、ここでは、オブジェクトについてと、その最高と最悪の両面について話そう。&lt;/p&gt;

&lt;h1 id=&#34;1-彼は実世界に存在している&#34;&gt;1. 彼は実世界に存在している&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-2.png&#34; src=&#34;https://www.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-2.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;まず第一に、オブジェクトは生きた有機体だ。
もっと言えば、オブジェクトは&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%93%AC%E4%BA%BA%E5%8C%96&#34;&gt;擬人化&lt;/a&gt;されるべきだ。
つまり、人間(もしくは、君がより好むならペット)のように扱われるべきだ。
基本的にこれは、オブジェクトはデータ構造体や関数の集合ではないということを意味している。
代わりに、オブジェクトは独立したエンティティで、それ自身のライフサイクル、振る舞い、性質を持つ。&lt;/p&gt;

&lt;p&gt;従業員、部署、HTTPリクエスト、MySQLのテーブル、ファイルの行、ファイルそのもの、これらは適切なオブジェクトだ。
なぜならこれらは、ソフトウェアを停止した時でも実世界に存在しているから。
より正確には、オブジェクトは実世界のモノの表現のひとつだ。
オブジェクトは実世界のモノと他のオブジェクトとの間のプロキシだ。
そのようなモノが存在しなければ、明らかにオブジェクトは存在しない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;photo = File.new(&#39;/tmp/photo.png&#39;)
puts photo.width()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この例では、&lt;code&gt;File&lt;/code&gt;に新しいオブジェクト&lt;code&gt;photo&lt;/code&gt;を構築するよう頼んでいる。
&lt;code&gt;photo&lt;/code&gt;はディスク上の実際のファイルの表現となる。
ファイルもまた仮想のもので、コンピュータが起動している間だけ存在すると言う人がいるかもしれない。
それには私も同意し、「実世界」の定義を次のように改善しよう。
オブジェクトが住むプログラムの範囲外に存在する全てのもの。
ディスク上のファイルはプログラムの範囲外にあり、その表現をプログラム内に作成することは完全に正しいことと言える。&lt;/p&gt;

&lt;p&gt;コントローラ、パーサ、フィルタ、バリデータ、サービスロケータ、シングルトン、ファクトリー、これれは良いオブジェクトではない。(そう、ほとんどのGoFパターンはアンチパターンだ!)
これらはソフトウェアの外側、実世界に存在していない。
他のオブジェクト同士を結びつけるためだけに考案されたものだ。
人工的で偽のモノだ。何も表現していない。
真面目な話、XMLパーサ、これが表現するものはなんだ?
何もない。&lt;/p&gt;

&lt;p&gt;上記オブジェクトのいくつかは名前を変えれば良いオブジェクトになる。他のものは決して存在を許されない。
例えば、XMLパーサは「パース可能なXML」と改名でき、プログラム外に存在するXMLドキュメントを表現するようになる。&lt;/p&gt;

&lt;p&gt;常に、「このオブジェクトの背後にある実世界のエンティティは何か?」を自問しよう。
もし回答が見つからなければ、リファクタリングを考えるときだ。&lt;/p&gt;

&lt;h1 id=&#34;2-彼は契約によって働く&#34;&gt;2. 彼は契約によって働く&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-3.png&#34; src=&#34;https://www.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-3.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;良いオブジェクトは常に契約によって働く。
彼は、個人的な実力ではなく、契約に従うということを理由に雇われることを期待している。
一方、我々がオブジェクトを雇うとき、差別待遇をして、特定のクラスの特定のオブジェクトが我々のために働いてくれると期待してはいけない。
どんなオブジェクトも契約通りのことをすると考えるべきだ。
オブジェクトが期待通りの働きをしている限りは、彼の出生や性別や信仰に興味を持つべきではない。&lt;/p&gt;

&lt;p&gt;例えば、ある写真をスクリーンに表示したいとする。その写真はPNGフォーマットのファイルから読みこまれる。
私は&lt;code&gt;DataFile&lt;/code&gt;クラスのオブジェクトと契約を結び、その画像のバイナリコンテンツをくれるよう頼む。&lt;/p&gt;

&lt;p&gt;しかし待ってほしい。私はそのデータが厳密にどこから来るかを気にするだろうか?
ディスク上のファイル、HTTPリクエスト、Dropbox上のドキュメントかもしれないが、実際私は気にしない。
私が気にするのは、オブジェクトがPNGデータが入ったバイト配列をくれるということだけだ。
つまり、私が結ぶ契約は以下のようなものだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;interface Binary {
  byte[] read();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、(DataFileクラスだけでなく)どんなクラスのどんなオブジェクトでも私のもとで働くことができる。
オブジェクトが働く資格を得るためにすべきは、&lt;code&gt;Binary&lt;/code&gt;インターフェースを実装することにより、契約に従うということだけだ。&lt;/p&gt;

&lt;p&gt;この際のルールは単純で、良いオブジェクトの全てのpublicメソッドは、インターフェースのものを実装すべきだということだ。
もしオブジェクトがインターフェースから継承していないpublicメソッドを持っていたら、それはダメな設計だ。&lt;/p&gt;

&lt;p&gt;これには実用的な理由が二つある。
第一に、無契約で働いているオブジェクトは、ユニットテストで使うモックが作れない。
第二に、無契約なオブジェクトは&lt;a href=&#34;https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;デコレータ&lt;/a&gt;で拡張できない。&lt;/p&gt;

&lt;h1 id=&#34;3-彼はユニーク&#34;&gt;3. 彼はユニーク&lt;/h1&gt;

&lt;p&gt;良いオブジェクトは常に、ユニークであるために何かを内包しているべきだ。
何も内包していないと、そのオブジェクトとまったく同じクローンが存在し得ることになる。私はこれはダメなことだと考えている。
以下がクローンが存在し得る悪いオブジェクトの例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class HTTPStatus implements Status {
  private URL page = new URL(&amp;quot;http://www.google.com&amp;quot;);
  @Override
  public int read() throws IOException {
    return HttpURLConnection.class.cast(
      this.page.openConnection()
    ).getResponseCode();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;HTTPStatus&lt;/code&gt;クラスのインスタンスは複数作れ、それら全ては互いに等しい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;first = new HTTPStatus();
second = new HTTPStatus();
assert first.equals(second);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明らかにユーティリティクラスは、スタティックメソッドだけを持つので、よいオブジェクトにインスタンス化できない。
より一般的には、ユーティリティクラスはこの記事で述べられているどのメリットも持たず、「クラス」と呼ぶことさえできない。
ユーティリティクラスは単純にオブジェクトパラダイムの酷い乱用で、モダンなオブジェクト指向言語の作者がスタティックメソッドを有効にしたせいで存在している。&lt;/p&gt;

&lt;h1 id=&#34;4-彼は不変-immutable&#34;&gt;4. 彼は不変(Immutable)&lt;/h1&gt;

&lt;p&gt;良いオブジェクトは内包する状態を決して変えるべきではない。
オブジェクトは実世界のエンティティの表現であることを思い出してほしい。このエンティティは、オブジェクトが存続する間は変化しないはずだ。
言い換えれば、オブジェクトはそれが表すエンティティに決して背いてはいけない。
オブジェクトがその所有者を変化させることはないよね。&lt;/p&gt;

&lt;p&gt;不変であることが、全てのメソッドが常に同じ値を返すことを意味するわけではないことに注意してほしい。
むしろ、良い不変オブジェクトはとても動的だ。
しかし、それは内部状態を変えることはない。例えば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class HTTPStatus implements Status {
  private URL page;
  public HTTPStatus(URL url) {
    this.page = url;
  }
  @Override
  public int read() throws IOException {
    return HttpURLConnection.class.cast(
      this.page.openConnection()
    ).getResponseCode();
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;read()&lt;/code&gt;メソッドは異なる値を返す可能性があるが、このオブジェクトは不変だ。
ある一つのウェブページを指し、他のどこを指すこともない。
内包する状態を決して変えないし、表現しているURLに背くこともない。&lt;/p&gt;

&lt;p&gt;なぜこの不変性が美徳なのか?
次の記事で詳細を説明している: &lt;a href=&#34;http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html&#34;&gt;オブジェクトは不変であるべきだ&lt;/a&gt;。
要するに、不変オブジェクトが優れている理由は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不変オブジェクトは簡単に構築、テスト、使用できる。&lt;/li&gt;
&lt;li&gt;真の不変オブジェクトは常にスレッドセーフ。&lt;/li&gt;
&lt;li&gt;時間的結合(訳注: コードの実行順の暗黙的な制約)を回避するのに役立つ。&lt;/li&gt;
&lt;li&gt;不変オブジェクトを使っても副作用がおきない。(防御的コピー無)&lt;/li&gt;
&lt;li&gt;エラー発生時の原子性が保証されている。&lt;/li&gt;
&lt;li&gt;キャッシュしやすい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/&#34;&gt;NULL参照&lt;/a&gt;を防ぐ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もちろん、良いオブジェクトは&lt;a href=&#34;https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/&#34;&gt;setter&lt;/a&gt;をもたない。セッターはオブジェクトの状態を変え得るし、URLに背くことを強要する。
言い換えると、&lt;code&gt;HTTPStatus&lt;/code&gt;で&lt;code&gt;setURL()&lt;/code&gt;メソッドを実装することは酷い間違いとなる。&lt;/p&gt;

&lt;p&gt;その他にも、不変オブジェクトを使うことで、設計は必然的に凝集度の高いものになり、また密で理解しやすいものになる。
これについては&lt;a href=&#34;http://www.yegor256.com/2014/11/07/how-immutability-helps.html&#34;&gt;不変性がどう役に立つか&lt;/a&gt;という記事で説明している。&lt;/p&gt;

&lt;h1 id=&#34;5-彼のクラスはスタティックなものをいっさいもたない&#34;&gt;5. 彼のクラスはスタティックなものをいっさいもたない&lt;/h1&gt;

&lt;p&gt;スタティックメソッドは、オブジェクトではなくクラスの挙動を実装する。
&lt;code&gt;File&lt;/code&gt;クラスがあり、その子供が&lt;code&gt;size()&lt;/code&gt;メソッドを持つとする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class File implements Measurable {
  @Override
  public int size() {
    // calculate the size of the file and return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここまではよい。&lt;code&gt;size()&lt;/code&gt;メソッドは&lt;code&gt;Measurable&lt;/code&gt;契約によって存在し、&lt;code&gt;File&lt;/code&gt;クラスの全てのオブジェクトはそのサイズを測ることができる。
このクラスを、代わりにスタティックメソッドを持つように実装するのは酷い間違いだ。
(こうした設計は&lt;a href=&#34;http://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html&#34;&gt;ユーティリティクラス&lt;/a&gt;と呼ばれ、JavaやRubyなどのほぼ全てのOOP言語でとても人気だ。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// TERRIBLE DESIGN, DON&#39;T USE!
class File {
  public static int size(String file) {
    // calculate the size of the file and return
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設計はオブジェクト指向パラダイムの真逆を行く。
なぜかって?
なぜならスタティックメソッドはオブジェクト指向プログラミングを「クラス指向」プログラミングに変えてしまうからだ。
この、&lt;code&gt;size()&lt;/code&gt;メソッドは、オブジェクトではなくクラスの挙動を公開する。
これの何が間違っているかと言われるかもしれない。
なぜオブジェクトとクラス両方をコード中で第一級市民として使えないのか?
なぜ両方ともがメソッドやプロパティを持てないのか?&lt;/p&gt;

&lt;p&gt;この問題は、クラス指向プログラミングでは、分離ができなくなるというものだ。
複雑な問題をブレイクダウンできなくなる。
なぜなら、プログラム全体の中でクラスのインスタンスがたったひとつしか存在しないからだ。
OOPの力は、オブジェクトをスコープを分離するための道具として使えることだ。
あるオブジェクトをメソッド中でインスタンス化したとき、そのオブジェクトは特定のタスク専任となる。
そのオブジェクトは、メソッド周辺の他のオブジェクトから完璧に分離されている。
このオブジェクトはメソッドスコープのローカル変数だ。
スタティックメソッドを持つクラスは、どこで使うにしろ常にグローバル変数だ。
このため、この変数とのやりとりを分離することはできない。&lt;/p&gt;

&lt;p&gt;オブジェクト指向の原理に概念的に反しているということの他にも、パブリックなスタティックメソッドは実用的な欠点も持っている。&lt;/p&gt;

&lt;p&gt;第一に、モックを作れない。
(いや、&lt;a href=&#34;https://code.google.com/p/powermock/&#34;&gt;PowerMock&lt;/a&gt;を使うことはできる。が、これはJavaプロジェクトで取り得る決断の中で最悪なものとなるだろう。。。私はそれを数年前にやってしまった。)&lt;/p&gt;

&lt;p&gt;第二に、定義上スレッドセーフではない。なぜなら、常にスタティック変数とともに動くからで、スタティック変数は全てのスレッドからアクセスできるからだ。
スタティックメソッドをスレッドセーフに作ることもできるが、この場合常に明示的な同期が必要になる。&lt;/p&gt;

&lt;p&gt;パブリックなスタティックメソッドを見つけたら常に、即座に書き直すべきだ。
スタティック(グローバル)変数がどれだけ酷いかについては説明したくもない。それは明らかだ。&lt;/p&gt;

&lt;h1 id=&#34;6-彼の名前は職名ではない&#34;&gt;6. 彼の名前は職名ではない&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-4.png&#34; src=&#34;https://www.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-4.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;オブジェクト名はそのオブジェクトが何であるかを示すべきで、何をするかを示すべきではない。
実世界の物に名付けるのと同様に。
ページ集めではなく本、水入れではなくカップ、体飾りではなくTシャツ。
もちろん、プリンタやコンピュータのような例外はあるが、これらはこの記事を読まなかった人々によってごく最近発明されたものだ。&lt;/p&gt;

&lt;p&gt;例えば、次のような名前はその持ち主が何であるかを示す。
りんご、ファイル、HTTPリクエスト群、ソケット、XMLドキュメント、ユーザリスト、正規表現、整数、PostgreSQLテーブル、Jeffrey Lebowski。
適切な名前はいつも小さい絵として描ける。正規表現でさえ描ける。&lt;/p&gt;

&lt;p&gt;逆に、次に挙げる名前の例は持ち主が何をするかを示す。
ファイルリーダ、テキストパーサ、URLバリデータ、XMLプリンタ、サービスロケータ、シングルトン、スクリプトランナ、Javaプログラマ。
これらの絵を描けるか?
描けない。
こういう名前は良いオブジェクトには適さない。
これらは酷い設計につながる酷い名前だ。&lt;/p&gt;

&lt;p&gt;一般的に、「-er」で終わる名前を避けるべきだ。そのほとんどはダメなものだ。&lt;/p&gt;

&lt;p&gt;「&lt;code&gt;FileReader&lt;/code&gt;の代わりは何」と疑問に思うだろう。
よりよい名前は何?&lt;/p&gt;

&lt;p&gt;ええと、我々は既に&lt;code&gt;File&lt;/code&gt;を持っていて、それは実世界のディスク上のファイルの表現だ。
この表現は十分に強力ではない。なぜなら、それはファイルの内容を読む方法を知らないからだ。
その能力を持ったより強力なものを作りたい。
何という名前にする?
名前は、その持ち主が何をするかではなく、何であるかを示すべきであるということを思い出してほしい。
持ち主は何か?
データを持ったファイルだ。ただのファイルではなく。
&lt;code&gt;File&lt;/code&gt;っぽいけど、もっと洗練されたものだ。データを持った。
なので、&lt;code&gt;FileWithData&lt;/code&gt;、もしくは単に&lt;code&gt;DataFile&lt;/code&gt;というのはどうだろう?&lt;/p&gt;

&lt;p&gt;同様のロジックを他の全ての名前にも適用すべきだ。
常に何をするかよりも何であるかを考えよう。
オブジェクトに職名ではなく、リアルで、意味のある名前を付けよう。&lt;/p&gt;

&lt;p&gt;より詳しくは「&lt;a href=&#34;http://www.yegor256.com/2015/03/09/objects-end-with-er.html&#34;&gt;-ERで終わるオブジェクトを作るな&lt;/a&gt;」を参照。&lt;/p&gt;

&lt;h1 id=&#34;7-彼のクラスはfinalかabstractのどちらか&#34;&gt;7. 彼のクラスはFinalかAbstractのどちらか&lt;/h1&gt;

&lt;p&gt;&lt;img alt=&#34;good-object-5.png&#34; src=&#34;https://www.kaitoy.xyz/images/seven-virtues-of-good-object/good-object-5.png&#34; width=&#34;300&#34; style=&#34;margin: 0px auto; display: block;&#34;&gt;&lt;/p&gt;

&lt;p&gt;良いオブジェクトはfinalまたはabstractなクラスから生成される。
&lt;code&gt;final&lt;/code&gt;クラスは継承によって拡張できないクラスだ。
&lt;code&gt;abstract&lt;/code&gt;クラスは子供を持てないクラスだ。
簡単に言うと、クラスは、「君は僕を決して壊せない。僕はブラックボックスだ。」か、または「僕は壊れている。直してから使ってくれ。」のどちらかを言う。&lt;/p&gt;

&lt;p&gt;その間には何もない。finalクラスはブラックボックスで、あらゆる意味で変更できない。
オブジェクトは現状のままで働き、君はそれを使うか捨てるかしかしない。
そのプロパティを継承する別のクラスを作ることはできない。
これは&lt;code&gt;final&lt;/code&gt;修飾子によって禁止されている。
そのようなfinalクラスを拡張する唯一の手段は、その子供をデコレートすることだ。
例えば、(上記)&lt;code&gt;HTTPStatus&lt;/code&gt;クラスがあり、それを気に入らなかったとする。
いやまあ好きではあるけど、私にとっては十分強力ではないんだ。
HTTPステータスが400より大きい場合に例外を投げて欲しい。
&lt;code&gt;read()&lt;/code&gt;メソッドにもう少し処理をしてもらいたい。
古風なやり方は、そのクラスを拡張してメソッドを上書きすることだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class OnlyValidStatus extends HTTPStatus {
  public OnlyValidStatus(URL url) {
    super(url);
  }
  @Override
  public int read() throws IOException {
    int code = super.read();
    if (code &amp;gt; 400) {
      throw new RuntimException(&amp;quot;unsuccessful HTTP code&amp;quot;);
    }
    return code;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なぜこれではダメなのか?
メソッドのひとつをオーバーライドすることで親クラス全体のロジックを壊す危険があるので全然ダメだ。
&lt;code&gt;read()&lt;/code&gt;を子クラスでオーバーライドしたら、親クラスから来る全てのメソッドがその新しいやつを使うことになる、ということを忘れないで欲しい。
これは、文字通り新しい「実装のかけら」をクラスの内部に挿入するということだ。
哲学的に言って、これは反則だ。&lt;/p&gt;

&lt;p&gt;一方、finalクラスを拡張するためには、それをブラックボックスのように扱い、他の実装でデコレートする必要がある。(&lt;a href=&#34;https://ja.wikipedia.org/wiki/Decorator_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3&#34;&gt;デコレータパターン&lt;/a&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class OnlyValidStatus implements Status {
  private final Status origin;
  public OnlyValidStatus(Status status) {
    this.origin = status;
  }
  @Override
  public int read() throws IOException {
    int code = this.origin.read();
    if (code &amp;gt; 400) {
      throw new RuntimException(&amp;quot;unsuccessful HTTP code&amp;quot;);
    }
    return code;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このクラスがもともとと同じインターフェース、&lt;code&gt;Status&lt;/code&gt;を実装していることに注目して欲しい。
&lt;code&gt;HTTPStatus&lt;/code&gt;のインスタンスはコンストラクタを通して渡され、内包される。
そして、全てのメソッド呼び出しは割り込まれ、必要に応じて独自に実装される。
この設計だと、もとのオブジェクトをブラックボックスとして扱い、その内部のロジックには決して触らない。&lt;/p&gt;

&lt;p&gt;もし&lt;code&gt;final&lt;/code&gt;というキーワードを使わなかったら、だれでも(君自身でも)そのクラスを拡張し、損なうことができる。(よって&lt;code&gt;final&lt;/code&gt;でないクラスは悪い設計だ。)&lt;/p&gt;

&lt;p&gt;abstractクラスは真反対なケースだ。それは不完全で、そのままでは使えないことを示している。
独自の実装ロジックを挿入する必要があるが、それは許可された部分だけに限られる。
この部分は&lt;code&gt;abstract&lt;/code&gt;メソッドとして明示的に示されている。
例えば、&lt;code&gt;HTTPStatus&lt;/code&gt;は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class ValidatedHTTPStatus implements Status {
  @Override
  public final int read() throws IOException {
    int code = this.origin.read();
    if (!this.isValid()) {
      throw new RuntimException(&amp;quot;unsuccessful HTTP code&amp;quot;);
    }
    return code;
  }
  protected abstract boolean isValid();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見て分かるとおり、このクラスはHTTPコードを検証する方法を知らないので、継承して&lt;code&gt;isValid()&lt;/code&gt;をオーバーライドすることによってそのロジックを挿入することを期待している。
この継承は親クラスを損なわない。他の全メソッドが&lt;code&gt;final&lt;/code&gt;によって守られているからだ。(メソッドの修飾子に注目してくれ。)
つまり、このクラスは攻撃への備えがしてあって、完全に防御している。&lt;/p&gt;

&lt;p&gt;まとめると、クラスは&lt;code&gt;final&lt;/code&gt;か&lt;code&gt;abstract&lt;/code&gt;のどちらかであるべきで、その中間はない。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;この記事は、オブジェクト指向原理主義者であるYegorが彼のオブジェクト観の概論を書いたものだ。
彼のオブジェクトに対するとんがった信念が読み取れる。&lt;/p&gt;

&lt;p&gt;記事の内容をまとめると、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;オブジェクトは何か実体と対応していないといけない。&lt;/li&gt;
&lt;li&gt;クラスはインターフェースを実装していないといけない。&lt;/li&gt;
&lt;li&gt;オブジェクトはユニーク性を保証するフィールドを持っていないといけない。&lt;/li&gt;
&lt;li&gt;オブジェクトは不変でないといけない&lt;/li&gt;
&lt;li&gt;クラスはスタティックメソッド/フィールドを持っていてはいけない。&lt;/li&gt;
&lt;li&gt;erで終わるクラス名を使ってはいけない。&lt;/li&gt;
&lt;li&gt;クラスにはfinalかabstractが付いていないといけない。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#1と#6はだいたい同じことを主張していて、その内容は実用的というよりかは哲学的だ。
敢えて実用面について言えば、同じ哲学を共有しているチームがこの主張に従えば、そのチーム内でコードの可読性や保守性が上がるというメリットがあると考えられる。
が、オブジェクト指向原理主義よりもGoFのデザインパターンの方がはるかに広く深く浸透しているので、このメリットはあまりありがたみが無い。
私はオブジェクト真理教に入信したわけではないので、これからもControllerとかFactoryとかServiceとかいうクラスを書くだろう。&lt;/p&gt;

&lt;p&gt;#2については、言っていることは分かるしインターフェースのメリットもよく理解しているつもりだが、わんさとクラスを書かないといけないのに逐一インターフェースまで書いてられるかというのが本音だ。
実際には、モックを書いたり多態したいとき、または将来そうなると天啓があったとき、つまりは必要に応じてインターフェースを書くのであって、なんでもかんでも書いていたら書くのも読むのもいたずらに大変になってしまう。(そういう方針をとって開発者から不満が噴出したプロジェクトが身近にあったと聞いた。)
Yegorのプロジェクトでは全てのクラスがインターフェースを実装しているんだろうか。信じ難い。&lt;/p&gt;

&lt;p&gt;#3も、ちょっと実用的な雰囲気の主張だが、よくみるとこれに従うことでどんなメリットがあるかとか、従わないことでどんな問題が発生するかとかが書いてない。
哲学的な主張か。
私が開発している&lt;a href=&#34;https://github.com/kaitoy/pcap4j&#34;&gt;Pcap4J&lt;/a&gt;には、ネットワークパケットを表すクラスが多数あるが、それらからインスタンス化されるオブジェクトは必ずしもユニークではない。
例えば、Ethernetヘッダを表すクラスである&lt;a href=&#34;https://github.com/kaitoy/pcap4j/blob/master/pcap4j-core/src/main/java/org/pcap4j/packet/EthernetPacket.java&#34;&gt;EthernetHeader&lt;/a&gt;は、Ethernetパケットの送り元と送り先が同じで、且つレイヤ3のプロトコルが同じなら&lt;code&gt;equals()&lt;/code&gt;が&lt;code&gt;true&lt;/code&gt;を返す。
つまり、実世界で異なるパケットのヘッダでも、Java世界では同一とみなされることがよくある。
この実装で実用上困ることは無い気がするけど、オブジェクト指向原理主義に照らすとダメってことか?
&lt;code&gt;UUID&lt;/code&gt;みたいなフィールドでも加えればいいのか?
そんなフィールドはEthernetヘッダにはないのに?&lt;/p&gt;

&lt;p&gt;#4は好き。ただ全てに適用できるかというと疑問。不変オブジェクトで、例えば&lt;a href=&#34;http://qiita.com/disc99/items/840cf9936687f97a482b#effective-java-builder&#34;&gt;Builderパターン(GoFじゃなくてEffective Javaの方)&lt;/a&gt;が対応している問題をどう解決するんだろう?
すごく頑張ってYegorの言いつけを守りながら、Builderパターンっぽくインスタンス化できるEthernetHeader(という名のEthernetヘッダフィールドの値を保持するクラス)を書いてみたら以下のようになった。&lt;/p&gt;

&lt;p&gt;まず、一般的なヘッダを表す&lt;code&gt;Header&lt;/code&gt;クラスを作る。不変で、&lt;code&gt;id&lt;/code&gt;という適当なフィールドを持つ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.util.MacAddress;

public final class Header {
  private final int id;

  public Header(int id) {
    this.id = id;
  }

  public int getId() { return id; }

  public DstAddrSetEthernetHeader dstAddr(MacAddress dstAddr) {
    return new DstAddrSetEthernetHeader(this, dstAddr);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、&lt;code&gt;Header&lt;/code&gt;をデコレートして拡張し、&lt;code&gt;dstAddr&lt;/code&gt;というフィールドを追加したもちろん不変なクラス&lt;code&gt;DstAddrSetEthernetHeader&lt;/code&gt;(dstAddrだけがセットされたEthernetヘッダ)を作る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.util.MacAddress;

public final class DstAddrSetEthernetHeader {
  private final Header header;
  private final MacAddress dstAddr;

  DstAddrSetEthernetHeader(Header header, MacAddress dstAddr) {
    this.header = header;
    this.dstAddr = dstAddr;
  }

  public MacAddress getDstAddr() { return dstAddr; }

  public int getId() { return header.getId(); }

  public DstAddrAndSrcAddrSetEthernetHeader srcAddr(MacAddress srcAddr) {
    return new DstAddrAndSrcAddrSetEthernetHeader(this, srcAddr);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さらに&lt;code&gt;DstAddrSetEthernetHeader&lt;/code&gt;をデコレートして拡張し、&lt;code&gt;srcAddr&lt;/code&gt;というフィールドを追加したもちろん不変なクラス&lt;code&gt;DstAddrAndSrcAddrSetEthernetHeader&lt;/code&gt;(dstAddrとsrcAddrがセットされたEthernetヘッダ)を作る。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.util.MacAddress;

public final class DstAddrAndSrcAddrSetEthernetHeader {
  private final DstAddrSetEthernetHeader header;
  private final MacAddress srcAddr;

  DstAddrAndSrcAddrSetEthernetHeader(DstAddrSetEthernetHeader header, MacAddress srcAddr) {
    this.header = header;
    this.srcAddr = srcAddr;
  }

  public MacAddress getSrcAddr() { return srcAddr; }

  public int getId() { return header.getId(); }

  public MacAddress getDstAddr() { return header.getDstAddr(); }

  public EthernetHeader type(EtherType type) {
    return new EthernetHeader(this, type);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;やっとビルド対象である&lt;code&gt;EthernetHeader&lt;/code&gt;を書く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.util.MacAddress;

public final class EthernetHeader {
  private final int id;
  private final MacAddress dstAddr;
  private final MacAddress srcAddr;
  private final EtherType type;

  public EthernetHeader(DstAddrAndSrcAddrSetEthernetHeader header, EtherType type) {
    this.id = header.getId();
    this.dstAddr = header.getDstAddr();
    this.srcAddr = header.getSrcAddr();
    this.type = type;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記4つのクラスを使って、次のようにBuilderパターンっぽいことができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;package test;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.util.MacAddress;

public class ImmutableBuilderSample {
  public static void main(String[] args) {
    EthernetHeader header
      = new Header(1)
          .dstAddr(MacAddress.getByName(&amp;quot;aa:bb:cc:dd:ee:ff&amp;quot;))
          .srcAddr(MacAddress.getByName(&amp;quot;11:22:33:44:55:66&amp;quot;))
          .type(EtherType.IPV4);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パラメータの設定順を自由にしたければ、さらに&lt;code&gt;SrcAddrSetEthernetHeader&lt;/code&gt;とか&lt;code&gt;TypeSetEthernetHeader&lt;/code&gt;とか&lt;code&gt;DstAddrAndTypeSetEthernetHeader&lt;/code&gt;とか作らないといけない。これは疲れる。
沢山オブジェクトを作るのに、最後の&lt;code&gt;EthernetHeader&lt;/code&gt;以外のが使い捨てというのも辛い。
&lt;code&gt;EthernetHeader&lt;/code&gt;は3つしかフィールドがないからまだましな方なんだが。&lt;/p&gt;

&lt;p&gt;私は、不変クラスはスレッドセーフにすることを主目的として作る。
普通アプリケーションはマルチスレッドになるんだから、基本的にクラスは不変を目指して作り、どうしても可変にしたくなったときは内部で同期してスレッドセーフに保つか、外で同期してもらうか、またはシングルスレッドで使ってもらうかを考える。
上記のBuilderなんかは可変フィールドを使わないとまともに作れないし、その性質上マルチスレッドで使うことは普通ないし、無理に不変にする必要はなかろう。&lt;/p&gt;

&lt;p&gt;#5については、Yegorが問題視していることにはだいたい納得できる。(哲学的な部分以外は。。。)
しかし、Yegorが、スタティックメソッドが可変フィールドを参照することを前提に話しているところにひっかかる。
私はpublic staticなフィールドをfinal無しで書くことはないし、スタティックメソッドは殆どの場合引数だけを使うように書き、たまにfinalなフィールドを参照させるくらいだ。(ちょっとあやしいけど多分。)
世のユーティリティクラスもだいたいそんな感じで書かれているんじゃなかろうか。
この場合、スレッドセーフじゃないという問題点は出ないし、問題の分離も、スタティックフィールドでデータを共有するわけではないのでちゃんとできる。
モックはできないけど、ユーティリティクラスのモックを書きたいことなんてあるだろうか?&lt;/p&gt;

&lt;p&gt;#7は同意。abstractじゃないメソッドをオーバーライドするのって気持ち悪いし。
ところでデコレータパターンってすごい便利で汎用性高いと思うんだけど、いざというときに思いつかないようで、あんまり使ったことないな。&lt;/p&gt;

&lt;p&gt;以上ひとつひとつの主張について考えてみたけど、反感が多いな。
これはオブジェクト真理教に入信するメリットが見えてこないからだろう。
もともとOOPっていうのは、手続き型言語が隆盛な時代の関数を使った処理の分離という考え方を押し進め、処理と処理対象データを一緒にして分離するという実用的で技術的な目的のもとに生まれたもので、オブジェクトは実世界のモノを表現しなきゃいけないってのは後付けの哲学だ。
OOPはそれを共通認識として発展したわけではないので、極端な哲学に縛られていると長い歴史に揉まれた強力なノウハウの多くが使えなくなってしまう。
GoFのデザインパターンを否定するなら、GoFが解決した問題への別解を提示してくれないとなかなか受け入れがたい。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>ORMは不快なアンチパターン</title>
          <link>https://www.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/</link>
          <pubDate>Sun, 13 Sep 2015 13:52:30 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html&#34;&gt;ORM Is an Offensive Anti-Pattern&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;結論から言えば、ORMはオブジェクト指向プログラミングの原則の全てに違反するひどいアンチパターンだ。オブジェクトをバラバラに引き裂き、もの言わぬ受身なデータ入れに変えてしまう。
小さいWebアプリケーションから、数千のテーブルをCRUD操作するエンタープライズシステムまで、どんなアプリケーションにもORMが存在することはゆるせない。
代わりになるものは?
SQLを話すオブジェクトだ。&lt;/p&gt;

&lt;h1 id=&#34;ormの仕組み&#34;&gt;ORMの仕組み&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E9%96%A2%E4%BF%82%E3%83%9E%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0&#34;&gt;オブジェクト関係マッピング&lt;/a&gt; (Object-relatinal mapping、ORM)は、オブジェクト指向言語(例えばJava)からリレーショナルデータベースにアクセスする技術(またはデザインパターン)だ。
ほとんどの言語で複数のORM実装がある。
例えば、Javaの&lt;a href=&#34;http://hibernate.org/orm/&#34;&gt;Hibernate&lt;/a&gt;、Ruby on Ralsの&lt;a href=&#34;http://guides.rubyonrails.org/active_record_basics.html&#34;&gt;ActiveRecord&lt;/a&gt;、PHPの&lt;a href=&#34;http://www.doctrine-project.org/&#34;&gt;Doctrine&lt;/a&gt;、Pythonの&lt;a href=&#34;http://www.sqlalchemy.org/&#34;&gt;SQLAlchemy&lt;/a&gt;。
Javaでは、ORMデザインは&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java_Persistence_API&#34;&gt;JPA&lt;/a&gt;として標準化されてさえいる。&lt;/p&gt;

&lt;p&gt;最初に、ORMがどう動くかを見てみよう。JavaとPostgreSQLとHibernateを使い、データベースに&lt;code&gt;post&lt;/code&gt; (訳注: ブログポスト、ブログの記事)という単一のテーブルがあるとする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+-----+------------+--------------------------+
| id  | date       | title                    |
+-----+------------+--------------------------+
|   9 | 10/24/2014 | How to cook a sandwich   |
|  13 | 11/03/2014 | My favorite movies       |
|  27 | 11/17/2014 | How much I love my job   |
+-----+------------+--------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、このテーブルをJavaアプリケーションからCRUD操作したい。(CRUDはcreate、read、update、deleteの略。)
まず、&lt;code&gt;Post&lt;/code&gt;クラスを書く。(長くてごめん。けどなるべく短くしたんだ。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Entity
@Table(name = &amp;quot;post&amp;quot;)
public class Post {
  private int id;
  private Date date;
  private String title;

  @Id
  @GeneratedValue
  public int getId() {
    return this.id;
  }

  @Temporal(TemporalType.TIMESTAMP)
  public Date getDate() {
    return this.date;
  }

  public Title getTitle() {
    return this.title;
  }

  public void setDate(Date when) {
    this.date = when;
  }

  public void setTitle(String txt) {
    this.title = txt;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hibernateでの処理をする前に、セッションファクトリを作らないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;SessionFactory factory = new AnnotationConfiguration()
  .configure()
  .addAnnotatedClass(Post.class)
  .buildSessionFactory();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このファクトリは&lt;code&gt;Post&lt;/code&gt;オブジェクトを操作したいときに「セッション」を作ってくれる。
セッションを使う全ての操作は以下のようなコードブロックで囲わないといけない。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Session session = factory.openSession(); try {
  Transaction txn = session.beginTransaction();
  // your manipulations with the ORM, see below
  txn.commit();
} catch (HibernateException ex) {
  txn.rollback();
} finally {
  session.close();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;セッションが準備できたら、以下のようにしてデータベーステーブルから全てのpostのリストを取得する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List posts = session.createQuery(&amp;quot;FROM Post&amp;quot;).list();
for (Post post : (List&amp;lt;Post&amp;gt;) posts){
  System.out.println(&amp;quot;Title: &amp;quot; + post.getTitle());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで何が起こっているかは明確だと思う。
Hibernateという巨大で強力なエンジンが、データベースへの接続、SQLの&lt;code&gt;SELECT&lt;/code&gt;リクエスト発行、及びデータの取得をする。
そして、&lt;code&gt;Post&lt;/code&gt;クラスのインスタンスを作り、データをつめる。
そのオブジェクトが我々に渡されるとき、それにはデータが詰まっていて、getterでデータを取り出すことができる。上記&lt;code&gt;getTitle()&lt;/code&gt;でやっているように。&lt;/p&gt;

&lt;p&gt;逆の処理をしてオブジェクトをデータベースに送りたい場合は、同じことを逆の手順でやればいい。
&lt;code&gt;Post&lt;/code&gt;のインスタンスを作り、データを入れ、Hibernateに保存するよう頼む。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Post post = new Post();
post.setDate(new Date());
post.setTitle(&amp;quot;How to cook an omelette&amp;quot;); session.save(post);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これがほぼ全てのORMの仕組みだ。
基本的な原則はいつも同じで、ORMオブジェクトは無気力なデータの包みだ。
我々はORMフレームワークと話して、ORMフレームワークはデータベースと話す。
オブジェクトは我々のリクエストをORMフレームワークに送り、そのレスポンスを読むのを助けてくれるだけだ。
こうしたオブジェクトは、getterやsetterのほかに何のメソッドも持たない。どのデータベースから来たのかすら知らない。&lt;/p&gt;

&lt;p&gt;これがオブジェクト関係マッピングの仕組みだ。&lt;/p&gt;

&lt;p&gt;これの何が間違ってるかって? 全てだ!&lt;/p&gt;

&lt;h1 id=&#34;ormの何が悪いのか&#34;&gt;ORMの何が悪いのか&lt;/h1&gt;

&lt;p&gt;真面目な話、何が悪い?
Hibernateは既に10年以上にわたって最も人気のあるJavaライブラリの一つだ。
この世のほぼ全てのSQL集約的なアプリケーションが使っている。
Javaのチュートリアルは、データベースに接続するアプリケーションのためのものとしてHibernate(またはTopLinkやOpenJPAのような&lt;a href=&#34;https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software&#34;&gt;ほかのORM&lt;/a&gt;)を挙げる。
それはデファクトスタンダードであって、なお間違っていると言っているのか?
そうだ。&lt;/p&gt;

&lt;p&gt;私はORMの根底にあるアイデア全体が間違っていると訴えている。
この発明は多分、OOPにおいて最大の失敗である&lt;a href=&#34;https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/&#34;&gt;NULL&lt;/a&gt;に次ぐ失敗だ。&lt;/p&gt;

&lt;p&gt;実際、私だけがこんなことを言っているわけではないし、最初に言ったわけでもないことは明白だ。
この問題に関しては、既に多くの記述が尊敬すべき著者によって公開されている。例えば、Martin Fowlerによる&lt;a href=&#34;http://martinfowler.com/bliki/OrmHate.html&#34;&gt;OrmHate&lt;/a&gt;、Jeff Atwoodによる&lt;a href=&#34;http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/&#34;&gt;Object-Relational Mapping Is the Vietnam of Computer Science&lt;/a&gt;、Ted Newardによる&lt;a href=&#34;http://blogs.tedneward.com/2006/06/26/The+Vietnam+Of+Computer+Science.aspx&#34;&gt;The Vietnam of Computer Science&lt;/a&gt;、Laurie Vossによる&lt;a href=&#34;http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern&#34;&gt;ORM Is an Anti-Pattern&lt;/a&gt;などで、他にも沢山ある。&lt;/p&gt;

&lt;p&gt;しかし、私の論点はこれらの著者とは違っている。
彼らが挙げている、「ORMは遅い」とか「データベースアップグレードが難しい」といった理由は実用的で有効ではあるが、重要なポイントが欠けている。
こういう実用的な論点に対しては、Bozhidar Bozhanovが彼のブログポストの&lt;a href=&#34;http://techblog.bozho.net/orm-haters-dont-get-it/&#34;&gt;ORM Haters Don’t Get It&lt;/a&gt;の中でとてもよい実用的な回答を示している。&lt;/p&gt;

&lt;p&gt;重要なポイントとは、ORMが、データベースとのやり取りをオブジェクト内にカプセル化するのではなく、それを抜き取り、密で堅い&lt;a href=&#34;https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;生ける有機体&lt;/a&gt;を文字通りばらばらに引き裂く、ということだ。
引き裂かれたオブジェクトの欠片はデータを保持し、ほかの欠片(ORMのエンジンであるセッションファクトリ内に実装されているもの)はそのデータの扱い方を知っていて、それをリレーショナルデータベースへ転送する。
下の絵を見てくれ。これはORMがやっていることを図示している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.kaitoy.xyz/images/orm-is-offensive-anti-pattern/orm-anti-pattern.svg&#34; alt=&#34;orm-anti-pattern.svg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;ブログポストの記事を読むとき、二つのコンポーネントを扱わないといけない。一つはORMで、もう一つは手足を奪われたオブジェクト。
OOPにおいては、扱うふるまいは単一のエントリーポイント、つまり一つのオブジェクトから提供されることになっている。
しかしORMの場合、ふるまいは二つのエントリーポイント、つまりORMと「もの」から提供される。
これはもはやオブジェクトとは呼べない。&lt;/p&gt;

&lt;p&gt;この不快でひどいオブジェクト指向パラダイム違反のせいで、上記記事で述べられているような多くの実用的な問題を抱える。
私はこれにもう少しだけ付け加える。&lt;/p&gt;

&lt;h2 id=&#34;sqlが隠蔽されない&#34;&gt;SQLが隠蔽されない&lt;/h2&gt;

&lt;p&gt;ORMユーザはSQL(もしくは&lt;a href=&#34;https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html&#34;&gt;HQL&lt;/a&gt;のような方言)を書くはずだ。
前記の例を見てほしい。全てのブログポストを取得するために&lt;code&gt;session.createQuery(&amp;quot;FROM Post&amp;quot;)&lt;/code&gt;を実行している。
これはSQLではないけど、よく似たものだ。
つまり、リレーショナルモデルはオブジェクト内にカプセル化されていない。
代わりに、それはアプリケーション全体に公開されている。
オブジェクトに触る誰しもが、何かを取得したり保存したりするためにリレーショナルモデルを扱わないといけない。
つまり、ORMはSQLを隠蔽したりラップしたりしておらず、アプリケーション全体に撒き散らしている。&lt;/p&gt;

&lt;h2 id=&#34;テストが困難&#34;&gt;テストが困難&lt;/h2&gt;

&lt;p&gt;ブログポストのリストを操作するオブジェクトがある場合、それは&lt;code&gt;SessionFactory&lt;/code&gt;のインスタンスを扱わないといけない。
この依存をどうする?
モックを作らないといけない?
これはどのくらい複雑な作業だろうか?
上記コードを見てほしい。ユニットテストがどれだけ冗長でやっかいなものになるかわかるはずだ。
代わりに、統合テストを書いてアプリケーション全体をテスト用PostgreSQLに接続することもできる。
この場合、&lt;code&gt;SessionFactory&lt;/code&gt;のモックは不要だ。
しかしこういうテストは遅く、さらに注目すべきことには、データベースに対して何もしないオブジェクトがデータベースインスタンスに対してテストされることになる。最悪な設計だ。&lt;/p&gt;

&lt;p&gt;もう一度繰り返すが、ORMの実用的な問題は結果に過ぎない。
根本的な欠陥は、ORMがオブジェクトをバラバラにし、&lt;a href=&#34;https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;オブジェクト&lt;/a&gt;の真の概念にひどく違反していることだ。&lt;/p&gt;

&lt;h1 id=&#34;sqlを話すオブジェクト&#34;&gt;SQLを話すオブジェクト&lt;/h1&gt;

&lt;p&gt;他の選択肢は?
例を挙げて教えよう。
あの、&lt;code&gt;Post&lt;/code&gt;クラスを私のやり方で設計してみよう。
これは二つのクラスに分ける必要がある。&lt;code&gt;Post&lt;/code&gt;と&lt;code&gt;Posts&lt;/code&gt;だ。
単数形と複数形。
私の&lt;a href=&#34;https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;以前の記事&lt;/a&gt;ですでに述べたように、よいオブジェクトは常に現実世界のエンティティの抽象だ。
この原則が実際にどう働くかをここに示す。
我々は二つのエンティティを扱う。データベーステーブルとテーブルの行だ。
これが二つのクラスを作る理由だ。&lt;code&gt;Posts&lt;/code&gt;がテーブルを表し、&lt;code&gt;Post&lt;/code&gt;が行を表す。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://www.kaitoy.xyz/images/orm-is-offensive-anti-pattern/sql-speaking-object.svg&#34; alt=&#34;sql-speaking-object.svg&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;例の&lt;a href=&#34;https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;記事&lt;/a&gt;で既に述べたように、全てのオブジェクトは契約によって働き、インターフェースを実装すべきだ。
我々の設計も二つのインターフェースから始めよう。
もちろん、オブジェクトは不変だ。&lt;code&gt;Posts&lt;/code&gt;は以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
interface Posts {
  Iterable&amp;lt;Post&amp;gt; iterate();
  Post add(Date date, String title);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Post&lt;/code&gt;は以下だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
interface Post {
  int id();
  Date date();
  String title();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;データベーステーブル内の全てのpostを表示するには以下のようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Posts posts = // we&#39;ll discuss this right now
for (Post post : posts.iterate()){
  System.out.println(&amp;quot;Title: &amp;quot; + post.title());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新しいpostを作る場合は以下のようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Posts posts = // we&#39;ll discuss this right now
posts.add(new Date(), &amp;quot;How to cook an omelette&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにすると真のオブジェクトになる。
これらのオブジェクトは全ての処理を受け持ち、実装の詳細を完璧に隠蔽する。
トランザクションもセッションもファクトリもない。
これらのオブジェクトが実際にPostgreSQLと話しているのかテキストファイルからデータを持ってきているのかすらわからない。
&lt;code&gt;Posts&lt;/code&gt;に求められるのは、全てのブログポストを取得する機能と新しいブログポストを作る機能だけだ。
実装の詳細は完璧に内部に隠蔽されている。
これから、どのようにこれら二つのクラスを実装できるかを見ていきたい。&lt;/p&gt;

&lt;p&gt;ここではJDBCラッパに&lt;a href=&#34;http://jdbc.jcabi.com/&#34;&gt;jcabi-jdbc&lt;/a&gt;を使うが、好みに応じてほかのものやJDBCを直接使ってもよい。
それは全く重要ではない。重要なのは、データベースとのやり取りをオブジェクト内に隠蔽することだ。
&lt;code&gt;Posts&lt;/code&gt;から始めよう。&lt;code&gt;PgPosts&lt;/code&gt;クラス(「pg」はPostgreSQLのこと)に実装する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class PgPosts implements Posts {
  private final Source dbase;
  public PgPosts(DataSource data) {
    this.dbase = data;
  }
  public Iterable&amp;lt;Post&amp;gt; iterate() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT id FROM post&amp;quot;)
      .select(
        new ListOutcome&amp;lt;Post&amp;gt;(
          new ListOutcome.Mapping&amp;lt;Post&amp;gt;() {
            @Override
            public Post map(final ResultSet rset) {
              return new PgPost(rset.getInteger(1));
            }
          }
        )
      );
  }
  public Post add(Date date, String title) {
    return new PgPost(
      this.dbase,
      new JdbcSession(this.dbase)
        .sql(&amp;quot;INSERT INTO post (date, title) VALUES (?, ?)&amp;quot;)
        .set(new Utc(date))
        .set(title)
        .insert(new SingleOutcome&amp;lt;Integer&amp;gt;(Integer.class))
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に&lt;code&gt;Post&lt;/code&gt;を&lt;code&gt;PgPost&lt;/code&gt;クラスに実装する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class PgPost implements Post {
  private final Source dbase;
  private final int number;
  public PgPost(DataSource data, int id) {
    this.dbase = data;
    this.number = id;
  }
  public int id() {
    return this.number;
  }
  public Date date() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT date FROM post WHERE id = ?&amp;quot;)
      .set(this.number)
      .select(new SingleOutcome&amp;lt;Utc&amp;gt;(Utc.class));
  }
  public String title() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT title FROM post WHERE id = ?&amp;quot;)
      .set(this.number)
      .select(new SingleOutcome&amp;lt;String&amp;gt;(String.class));
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今作ったクラスを使ってデータベースとやり取りする完全なシナリオは以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Posts posts = new PgPosts(dbase);
for (Post post : posts.iterate()){
  System.out.println(&amp;quot;Title: &amp;quot; + post.title());
}
Post post = posts.add(new Date(), &amp;quot;How to cook an omelette&amp;quot;);
System.out.println(&amp;quot;Just added post #&amp;quot; + post.id());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/aintshy/hub/tree/0.7.2/src/main/java/com/aintshy/pgsql&#34;&gt;ここ&lt;/a&gt;で完全な実用的な例を見られる。
これはオープンソースのWebアプリで、上で説明したのと全く同じアプローチ、つまりSQLを話すオブジェクトを使ってPostgreSQLにアクセスする。&lt;/p&gt;

&lt;h1 id=&#34;性能は&#34;&gt;性能は?&lt;/h1&gt;

&lt;p&gt;「性能は?」と君が叫んでいるのが聞こえる。
数行上のスクリプトにはデータベースとの冗長なやりとりを書いた。
まず、&lt;code&gt;SELECT id&lt;/code&gt;でブログポストのIDを取得し、さらに、タイトルを取得するために&lt;code&gt;SELECT title&lt;/code&gt;をそれぞれのブログポストに対して実行する。
これは非効率だ。単に遅すぎると言ってもいい。&lt;/p&gt;

&lt;p&gt;心配はいらない。これはオブジェクト指向プログラミングであり、柔軟なんだ!
&lt;code&gt;PgPost&lt;/code&gt;のデコレータを作り、全てのデータをそのコンストラクタで受け取って内部で永遠にキャッシュしよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class ConstPost implements Post {
  private final Post origin;
  private final Date dte;
  private final String ttl;
  public ConstPost(Post post, Date date, String title) {
    this.origin = post;
    this.dte = date;
    this.ttl = title;
  }
  public int id() {
    return this.origin.id();
  }
  public Date date() {
    return this.dte;
  }
  public String title() {
    return this.ttl;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このデコレータはPostgreSQLやJDBCについて何も関与しないことに注目してほしい。
単に&lt;code&gt;Post&lt;/code&gt;オブジェクトをデコレートして日付(date)とタイトル(title)をキャッシュするだけだ。
例によってこのデコレータは不変だ。&lt;/p&gt;

&lt;p&gt;さて、&lt;code&gt;Posts&lt;/code&gt;の別の実装を作って、「定数」オブジェクトを返すようにしてみよう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Immutable
final class ConstPgPosts implements Posts {
  // ...
  public Iterable&amp;lt;Post&amp;gt; iterate() {
    return new JdbcSession(this.dbase)
      .sql(&amp;quot;SELECT * FROM post&amp;quot;)
      .select(
        new ListOutcome&amp;lt;Post&amp;gt;(
          new ListOutcome.Mapping&amp;lt;Post&amp;gt;() {
            @Override
            public Post map(final ResultSet rset) {
              return new ConstPost(
                new PgPost(rset.getInteger(1)),
                Utc.getTimestamp(rset, 2),
                rset.getString(3)
              );
            }
          }
        )
      );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今、この新しいクラスの&lt;code&gt;iterate()&lt;/code&gt;が返す全てのブログポストには、データベースとの一往復で取得された日付とタイトルが入っている。
デコレータやインターフェースの複数の実装を使うことで、どんな機能も望みどおりに構成することができる。
最も重要なことは、機能は拡張されたが設計は複雑になっていないことだ。クラスのサイズが大きくなっていないからね。
代わりに、小さく、それ故強度と凝集度が高い新しいクラスを導入した。&lt;/p&gt;

&lt;h1 id=&#34;トランザクションは&#34;&gt;トランザクションは?&lt;/h1&gt;

&lt;p&gt;全てのオブジェクトはそれ自身のトランザクションを扱い、それを&lt;code&gt;SELECT&lt;/code&gt;や&lt;code&gt;INSERT&lt;/code&gt;と同様にカプセル化すべきだ。
これはトランザクションのネストにつながる。
トランザクションのネストは、データベースサーバがサポートしていれば全く素晴らしいものだ。
サポートされていなければ、セッション全体に渡るトランザクションを表すオブジェクトを作り、「callable」クラスを受け取ればいい。
以下がその例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;final class Txn {
  private final DataSource dbase;
  public &amp;lt;T&amp;gt; T call(Callable&amp;lt;T&amp;gt; callable) {
    JdbcSession session = new JdbcSession(this.dbase);
    try {
      session.sql(&amp;quot;START TRANSACTION&amp;quot;).exec();
      T result = callable.call();
      session.sql(&amp;quot;COMMIT&amp;quot;).exec();
      return result;
    } catch (Exception ex) {
      session.sql(&amp;quot;ROLLBACK&amp;quot;).exec();
      throw ex;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、ひとつのトランザクションに複数のオブジェクト操作をラップしたい場合はこのようにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;new Txn(dbase).call(
  new Callable&amp;lt;Integer&amp;gt;() {
    @Override
    public Integer call() {
      Posts posts = new PgPosts(dbase);
      Post post = posts.add(new Date(), &amp;quot;How to cook an omelette&amp;quot;);
      posts.comments().post(&amp;quot;This is my first comment!&amp;quot;);
      return post.id();
    }
  }
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードは新しいブログポストを作ってコメントを加える。
もし処理に失敗したら、トランザクション全体がロールバックされる。&lt;/p&gt;

&lt;p&gt;私にはこのアプローチがオブジェクト指向に見える。
私はこれを「SQLを話すオブジェクト」と呼んでいる。
なぜなら、このオブジェクトはデータベースサーバとSQLを話す方法を知っているからだ。
それはオブジェクトのスキルで、完璧に内部にカプセル化されている。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/DEqcn4-freM&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;ORMはHibernateをちょっと使ったことがあるくらい。
IPAのデータベーススペシャリストの試験を申し込んだものの参考書が理解できなくてあきらめた過去もあり、この分野には苦手意識があって、あまり大きい声は出せない。&lt;/p&gt;

&lt;p&gt;Hibernateについてちょっと言えば、使い始めはすばらしいものに見えて興奮するが、だんだんとその融通の利かなさにうんざりしてきて、結局DAOとかにSQLを書きまくったり、自分でデータをキャッシュする仕組みを書いたりする羽目になる、というイメージ。
Hibernateを初歩的に使うと一行もSQL(やHQL)を書かずにRDBを使うアプリケーションを書けるので、ORMはSQLを学ぶコストをカットするためのツールであると勘違いしてしまうが、実際にはインピーダンスミスマッチの解決が主目的であって、実用に際してはRDBとSQLへの深い知識が必要になる。&lt;/p&gt;

&lt;p&gt;もちろんこれはORMの「実用的な問題」であって、Yegorが書いていることとは違う。&lt;/p&gt;

&lt;p&gt;日本では、Yegorも挙げているLaurie Vossの&lt;a href=&#34;http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern&#34;&gt;2011年半ばのブログポスト&lt;/a&gt;がきっかけでORMの問題が話題になったようだ。
これは&lt;a href=&#34;https://ja.wikipedia.org/wiki/NoSQL&#34;&gt;NoSQL&lt;/a&gt;が日本で大きく取り上げられ始めた時期ともかぶっている気がする。
もっと前から本当に性能にシビアなWebサービス界ではNoSQLを使うのが主流になっていたみたいだけど。
これはGoogle、Amazon、FacebookといったWebサービス企業のカリスマがNoSQLを押したのもあるか。
ホリエモンもエンジニアだったころ自社のサービスを作った時に使ったとか。これは15年以上前の話だから、かなり先見性があったんだな。&lt;/p&gt;

&lt;p&gt;今RDBをもっとも使っている分野であろうエンタープライズ向けのシステムやパッケージソフトも、サービス化が大きなトレンドであり、それに加えてマルチテナント化が進めば扱うデータ量が増え、性能に対してどんどんシビアになり、NoSQLを取り入れる動きが増えるんだろう。
&lt;a href=&#34;http://japan.zdnet.com/article/35061140/&#34;&gt;2015年はNoSQL元年&lt;/a&gt;なんて記事もある。この記事によれば、NoSQLは大量の非構造化データを扱うIoTやM2Mの分野に有効だそうな。&lt;/p&gt;

&lt;p&gt;まあこれもYegorが書いていることとは関係ないけど。&lt;/p&gt;

&lt;p&gt;Yegorが言っていること、ORMは本来オブジェクトの仕事であるものを取り上げてしまうのでだめだという理屈は、オブジェクト原理主義者から見ればそうなのかもしれないが、一般の開発者から見ればそれがいいんじゃないかという話になって、議論はかみ合わない。
Yegor自身が前半で書いているORMを使ったコードより、後半のOOP原理的コードの方がかなり長い。
それってORMを使った方がやっぱりいいんじゃないのという感想を持つ人が多いのでは。(少なくとも「実用的な問題」を抜きにすれば。)&lt;/p&gt;

&lt;p&gt;オブジェクト原理主義をしっかり理解し、そのメリットを知らなければYegorの説教も馬の耳にだ。というわけで、次は&lt;a href=&#34;http://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html&#34;&gt;Seven Virtues of a Good Object&lt;/a&gt;を読むか。(&lt;a href=&#34;https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;訳した。&lt;/a&gt;)&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>スタンドアップミーティングはダメマネージャーが好む手法</title>
          <link>https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</link>
          <pubDate>Tue, 11 Aug 2015 22:35:09 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2015/01/08/morning-standup-meetings.html&#34;&gt;Daily Stand-Up Meetings Are a Good Tool for a Bad Manager&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;スタンドアップミーティング (または単純にスタンドアップ)は、「チームマネージャに状況報告をするためのデイリーチームミーティング」であるとWikipediaに書かれている。
こうしたミーティングは、ソフトウェア開発チームの間でとても人気な手法ではあるが、単なる悪であり、よいマネージャは決してやらない。
以下、その理由を説明する。&lt;/p&gt;

&lt;p&gt;私は、スタンドアップのやり方が適切だったり不適切だったりする、と言いたいわけではない。それについて述べた記事は大量にある。
また、スタンドアップを上手く機能するように実施する方法についてアドバイスしようとしているわけでもない。
よいマネージャはデイリースタンドアップを決して実施すべきでないと言っているのだ。
スタンドアップは、単に「機能しない」だけでなく、非常に悪い、時に破壊的なものをマネジメントプロセスにもたらす。それがアジャイルかどうかにかかわらず。
一方、ダメなマネージャは常に、デイリースタンドアップを重要なマネジメント手法として使う。&lt;/p&gt;

&lt;p&gt;私の意図を説明するため、マネジメントをいくつかの異なった視点から見ながら、よいマネージャとダメなマネージャが仕事をどのように進めるかを比べてみよう。&lt;/p&gt;

&lt;h3 id=&#34;情報&#34;&gt;情報&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャは進捗を尋ねる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;オフィスを歩き回り進捗を訪ねて回るのは、ひどいマネージャの崇高な習慣だ。
彼は、プロセスと情報伝達フローを適切に構築できるほど賢明ではなく、チームが何をしているかを知らない。
しかし、彼は進捗を知る必要がある。彼もまた上司からちょくちょく尋ねられるからだ。
必要な情報を収集する唯一の方法は、チームに「今何の作業をしているの?」と尋ねることだ。
朝のスタンドアップは、メンバの作業内容を知らないことに気付かれずに、このうっとうしい質問を正式に尋ねる最高の場だ。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは必要なときに報告を受ける。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;プロジェクトマネージメントにはコミュニケーション管理が必要だ。
情報伝達フローが適切に構成されていれば、チームメンバはいつどのようにマネージャに報告すればいいかが分かる。
何か問題が起きたとき、そういう状況をどのように報告しなければいけないかを全員が知っている。即時、直接報告するのだ。
作業が完了したとき、必要に応じてプロジェクトマネージャにどのように知らせるかを全員が理解している。
完璧なプロジェクトマネージャは決してチームに質問しない。代わりに、チームが必要なときにマネージャに報告する。
そして、報告を怠るメンバが出たときには、その壊れたコミュニケーションチャネルを修復するのがよいプロジェクトマネージャだ。
ただし、情報収集のためにデイリーミーティングは決して実施しない。&lt;/p&gt;

&lt;p&gt;よいマネージャとして、何がゴールで何がプロジェクトマネージャ(またはスクラムマスタ)として重要かをチームに伝えるべきだ。
チームメンバは、マネージャがチームの進捗、リスク、障害、失敗について知るために何が重要であるかを知っているべきだし、チームメンバがマネージャの期待に沿えなければどんなトラブルに陥るかを理解しているべきだ。
プロジェクトやチームが取り組んでいる最も重要な課題についてをチームに伝えることは、よいマネージャとしてすべき仕事だ。
また、よいチームメンバとしては、重要な情報をつかんだら、すぐにマネージャに知らせることが重要だ。
これが完璧なマネージメントというものだ。&lt;/p&gt;

&lt;p&gt;もしそのようなチームワークを築いたなら、開発者が今日何をしてどんな問題にあったかを、明日の朝まで待ってから尋ねる必要はなくなる。
マネージャはこういった情報をもっと早く、まさに必要なタイミングで知るようになる。
オフィスの外にいるときでさえ、プロジェクトで起こっていることを知ることができるようになる。
実際には、オフィスは全く不要にさえなるが、これはまた別の機会に議論したい。&lt;/p&gt;

&lt;p&gt;デイリースタンドアップはプログラマ間で情報交換する最高の機会で、スクラムマスタに報告してフィードバックを受けるだけの場ではないと言う人がいるかもしれない。
もう一度、同じことを言うが、なぜ、その日の必要になった時点で情報交換をしないのか?
なぜ、10人のメンバを毎朝集めて、その内たった5人だけに関係することを議論する必要がある?
答えよう。ダメなマネージャは、チームメンバ間で情報交換する場を用意する他の方法を知らず、朝のスタンドアップを適切なコミュニケーションモデルの代わりとして使う。
こういったミーティングは、マネージャが熱心に働いていて、大げさな給料を受け取るに値するかのような印象を与える。
対照的に、よいマネージャは定期的な状況報告ミーティングをいっさい実施しない。
なぜなら、効果的なコミュニケーションツールの使い方を知っているからだ。
例えば、問題追跡ツール、メール、コードレビュー、意思決定ミーティング、ペアプログラミングなど。&lt;/p&gt;

&lt;h3 id=&#34;責任&#34;&gt;責任&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャはマイクロマネージメントをする。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ダメなマネージャはプロジェクトマネージメントのことをほとんど知らないので、大きな不安を抱えている。
彼はチームのコントロールを失うことを恐れていて、チームを信頼せず、いつも十分な情報を得ていないと感じ、上司から状況を尋ねられたときに動揺する。
このため、彼はチームメンバを抗うつ薬として使う。チームメンバが彼の言う通りのことをしているとき、彼はより安心と安定を感じる。
デイリースタンドアップミーティングは、彼がメンバに何をしているかを尋ね、代わりに何をすべきかを指示するためのすばらしい機会だ。
このマネージャは、メンバに個人の目標と計画を報告するよう強制し、必要だと感じればそれらを修正する。
次のようなやりとりをを何回聞いたことがある?「私はテストXをやるつもりです。…いや、それは来週だ。今日はYをやってくれ。」
これはマイクロマネージメントだ。デイリースタンドアップはマイクロマネージャのための完璧なツールだ。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは責任を委譲する。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理想的なマネージメントには4つのステップが必要だ。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;複雑なタスクを小さいサブタスクに分解する。&lt;/li&gt;
&lt;li&gt;それらを部下に委譲する。&lt;/li&gt;
&lt;li&gt;報酬と、ペナルティと、ルールをはっきりと伝える。&lt;/li&gt;
&lt;li&gt;報酬はちゃんと支払われること、ペナルティは免れられないこと、ルールは厳格に守られることを確実にする。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;完璧なマネージャは日々何をするかをメンバに指示しないし、業務時間の使い方にも口を出さない。
彼は信頼し、コントロールする。
彼は、メンバに作業方法を指示して自尊心を削ぐようなことは決してしない。
すばらしいマネージャは次のようなことを言う。「今日はテストXをやるつもりだって? それは君の判断だ。最大限尊重するよ。ただ、Yが今週中に完了しなければ、君は約束どおりプロジェクトからはずされるということを忘れないでくれ。」
こういうマネージャにデイリースタンドアップが必要だろうか?
チームメンバに何をしているか聞く必要があるだろうか?
彼はメンバの計画によけいな干渉はしない。
代わりに、メンバを信頼し、成果をコントロールするだけだ。&lt;/p&gt;

&lt;p&gt;重ねて言うが、私は責任は委譲されるべきだと強く信じている。この委譲は3つの要素からなる。報酬、ペナルティ、ルールだ。
近代西洋文化の中では、これらを定めるのはむしろ難しいかもしれない。普通は長期の契約と月々の給料がある。
しかし、よいマネージャは方法を模索しないといけない。それぞれのタスクは委譲され、分離されないといけない。
これは、あるタスクに従事しているプログラマは、その成功または失敗に個人的な責任を持たなければいけないということだ。
また、そのタスクの結果が与える影響を知っていなければいけない。&lt;/p&gt;

&lt;p&gt;よいマネージャは、どんなチームメンバでも必ず責任逃れをしようとするということを理解している。
誰もがマネージャの両肩に&lt;a href=&#34;http://hbr.org/1999/11/management-time-whos-got-the-monkey/ar/1&#34;&gt;責任猿&lt;/a&gt;(訳注: 責任のメタファである猿)を返そうとする。
それは自然で不可避なことだ。デイリースタンドアップミーティングはこのたくらみを助長するだけだ。&lt;/p&gt;

&lt;p&gt;朝、君が私に進捗を聞くと、私はいくつか問題があって今週末までにタスクが完了できるか怪しいと言う。
それだけだ。私はもうそのタスクに責任がない。もし間に合わなくても私の失敗ではない。
私は失敗するかもしれないと伝えたよね?
今後、その責任は君がもつんだ。&lt;/p&gt;

&lt;p&gt;よいマネージャはこういう策略について知っていて、それを防ぐために報酬・ペナルティ・ルールを明確に規定する。
もし間に合わないかもしれないと言われたら、報酬を逃しペナルティを受けることを思い出させればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- 締め切りに間に合わないかもしれない…
- それは残念だ。君は$200の週末ボーナスを逃すことになる。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロジェクトマネージャやスクラムマスタがこんなことを言っているのを見たことがあるかい?
あまりないと思う。そう、よいマネージャは珍獣なんだ。
しかし、よいマネージャだけが報酬・ペナルティ・ルールを明確に厳格に定義する能力を持つ。&lt;/p&gt;

&lt;p&gt;この3点が定義されれば、毎朝状況報告ミーティングをする必要はなくなる。
全てがありのままに明確になる。全員がゴールと目標を把握する。
全員が失敗したときに何が起こるかを知っているし、成功したときに何を得られるかも知っている。
マネージャは毎朝それをメンバに確認する必要はない。マネージャはメンバの進捗を確認する必要もない。
マネージャは既に非常に明確に各メンバの目標を定めている。それについて毎朝話す必要があるだろうか?&lt;/p&gt;

&lt;p&gt;ダメなマネージャは目標を定める能力がないので、毎朝メンバをマイクロマネージメントしようとする。
実際、ダメなマネージャは一日中マイクロマネージメントしている。
明確なゴールやルールがないので、チームが間違ったことをしたり何もできなかったりするのではないかと恐れている。
しょっちゅう状況確認するのはそのせいだ。
実際のところ、彼はチームの首根っこをつかんでいるのだ。&lt;/p&gt;

&lt;h3 id=&#34;モチベーション&#34;&gt;モチベーション&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ダメなマネージャは皆の前で恥をさらさせてモチベーションを下げさせる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ダメなマネージャはチームメンバにやる気を出させる適切な仕組みの作り方を知らないため、恥をさらすことへの生理的な恐怖を利用する。
誰も「忘れました」と皆の前で言いたくないのが当然だ。
デイリースタンドアップミーティングは全員を一列に並べて「昨日何をした?」と尋ねる場だ。
この恐怖の時間はチームにやる気を出させるだろ?
私はそうは思わないが。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;よいマネージャは目標でモチベーションを上げさせる。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;理想的なマネージメントは、目標を定めて、チームメンバがスキル、リソース、知識、情熱を駆使してそれを達成できるようにする。
適切に定められた目標は常に3つの要素からなる。報酬、ペナルティ、ルールだ。
すばらしいマネージャは組織の目標を個人の目標に落とし込む方法を知っている。
「もし今週中にこの機能を納品できたら、会社はさらなる利益を出せる。サリー、君個人としては$500を得る。もし君がしくじったら、君は他の、あまり面白くないプロジェクトに異動することになる。」
これが完璧に定められた目標だ。毎朝、皆の前で、機能の実装を忘れてないかとか、熱心に作業しているかとか、サリーに尋ねる必要があるだろうか?
この尋問は彼女の手助けになるだろうか?
なるはずがない !
彼女は既に何のために作業しているか知っていて、動機付けは十分だ。
彼女が期日に作業を終えたら、ミーティングを開いて、皆の前で$500のチェックをあげよう。
これがよいマネージャによるミーティングの使い方だ。&lt;/p&gt;

&lt;p&gt;他にもある。
皆の前での日々の進捗報告は、チーム内最高のメンバを堕落させ、最悪にしてしまう。
主な理由は、彼らは突出した成果を出すことで他の人の気を損ねたくないからだ。
グループ内で他の皆と同じように振舞おうとするのは、人間の性だ。
皆が「まだ結果は出ていません」と報告しているときに、有能なプログラマが「全てのタスクを終えたので、他の仕事をください」と言うことを期待するのは奇妙だ。
いや、一回くらいはこういうことを言うかもしれないが、しばらくするとこの有能なプログラマは熱心に作業することをやめるか、チームを抜ける。
彼は、彼の成果が際立っていることを知り、それがグループから評価されていないことを知る。マネージャが何を言おうとも。&lt;/p&gt;

&lt;p&gt;よいマネージャは、プログラマそれぞれに固有の作業速度、質、給料があることを理解する。
よいマネージャは、人によって与えるタスクを変え、異なる結果が返ってくることを期待する。
明らかに、朝全員を並ばせて、皆が同じような報告をすることを期待するのは大きな間違いだ。
この間違いは、突出した成果を出して格別な評価と報酬を得たがっている有能なメンバに破壊的な効果をもたらす。&lt;/p&gt;

&lt;p&gt;ダメなマネージャは異なる人々を異なる方法でマネージメントできない。単にやり方を知らないからだ。
そのため、デイリースタンドアップという、全員が同じような、比較しやすい成果を報告する場が必要になる。
また、皆と違った報告をする人を責めたり励ましたりもしやすい。
言い換えると、ダメなマネージャはデイリースタンドアップを平等の手段として使う。この場合の平等は、チーム全体のモチベーションを破滅させるだけだ。&lt;/p&gt;

&lt;p&gt;デイリースタンドアップや、他のあらゆる状況報告ミーティングは、怠惰で愚かなマネージャを隠して守るのにはすばらしい手段だ。
マネージャの無能っぷりをチームメンバから隠すことができる。
適正のなさを隠し、問題や挑戦やリスクへの恐れを隠す。
よいマネージャになりたいなら、デイリースタンドアップで自分自身を困らせないことだ。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Yegorは、自身が経営する&lt;a href=&#34;http://www.teamed.io/&#34;&gt;Teamed.io&lt;/a&gt;という会社でのソフトウェア開発プロジェクトを、自身が考案した&lt;a href=&#34;http://www.xdsd.org/&#34;&gt;XDSD&lt;/a&gt;という手法を使ってマネジメントしている。
上の記事は、そのXDSDを念頭に、
巷で流行っている&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%A0_%28%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA%29&#34;&gt;スクラム&lt;/a&gt;などで行われるデイリースタンドアップにはっきりと異を唱えるものだ。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.agilemanifesto.org/iso/ja/&#34;&gt;アジャイルソフトウェア開発宣言&lt;/a&gt;が発表されてから14年もたち、私の会社のような古い体質の組織にもアジャイルな手法や理念はさすがに浸透していて、私の周りでもデイリーミーティングをするチームが目立つ。私としては、管理される側にとっても、管理する側にとっても、いい情報交換の場だとは思うが、だらだら長くなりがちで、じわじわ煩わしくなるのが難。&lt;/p&gt;

&lt;p&gt;Yegorは、定例ミーティングなんかやめて、情報交換は必要なときに必要な人どうしでやれよと言っているわけだけど、悪いニュースは隠したくなるし、いいニュースもきっかけがないと報告するのがおっくうになるのは自然の摂理ではないか。
この摂理を乗り越え、適時情報共有するための、「適切な情報伝達フロー」の作り方は、また別の記事に書かれているんだろうか。&lt;/p&gt;

&lt;p&gt;責任の委譲についてのくだりは、以前読んだドラッカーを思い出した。もしドラだけど。
ドラッカーは「権限 (authority) を委譲しろ」と言っていたけど、Yegorは「責任 (responsibility) を委譲すべき」と言っている。
また、ドラッカーは、「権限の委譲を責任の放棄と混同してはいけない。権限を委譲したらむしろマネージャの責任は大きくなる」と言っていた。
つまり、Yegorはここでさらっとドラッカーにも異を唱えていることになる。
権威によるバイアスもあるのかもしれないが、私にはやはりドラッカーの話の方がしっくりくる。責任は猿みたいに身軽に移動できるものとは思えない。
失敗した部下のボーナスを減らして別のプロジェクトに飛ばしたところで、開発の遅れを取り戻せるわけではないし、納品が遅れたら怒られるのは結局上の人たちだ。&lt;/p&gt;

&lt;p&gt;ところで、XDSDもそうっぽいけど、アジャイルな開発手法は基本的に、意欲に満ちた優秀なメンバで構成されたチームを前提に組み立てられたものだ。
私の会社を含む、日本の大企業がやっているような、経験(ほぼ)不問、サークルやバイトでの体験談を聞いて新卒一括人柄採用なんてボランティアみたいな選考方法を刷新しない限り、上手く回るようになることはない。
こんないい加減なやり方で集められた烏合の衆で、何千万も何億も稼ぐソフトウェアを作ろうってんだから、上の人たちはさぞかし大変なんだろう。意欲に欠けた部下の尻を叩くためにデイリースタンドアップをやらざるを得ないマネージャを批判するのは、ちょっと気の毒に思える。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>なぜNullはダメか</title>
          <link>https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/</link>
          <pubDate>Sun, 26 Jul 2015 19:07:20 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;Why NULL is Bad?&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Javaで&lt;code&gt;NULL&lt;/code&gt;を使う単純な例を以下に示す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    return null;
  }
  return new Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このメソッドの何が間違っているのか? オブジェクトの代わりに&lt;code&gt;NULL&lt;/code&gt;を返す可能性がある、というのが間違っているところだ。
&lt;code&gt;NULL&lt;/code&gt;はオブジェクト指向パラダイムにおけるひどい慣習で、全力で避けるべきものだ。
これについては多くの意見が既に発表されている。
たとえば、Tony Hoareによるプレゼン&lt;a href=&#34;http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare&#34;&gt;Null References, The Billion Dollar Mistake&lt;/a&gt;や、David Westの著書&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;の全体に渡って述べられている。&lt;/p&gt;

&lt;p&gt;ここで、その論拠のすべてをまとめ、&lt;code&gt;NULL&lt;/code&gt;の使用を回避して適切なオブジェクト指向構造に置き換える方法の例を紹介したいと思う。&lt;/p&gt;

&lt;p&gt;基本的に、&lt;code&gt;NULL&lt;/code&gt;の代わりになり得るものはふたつある。&lt;/p&gt;

&lt;p&gt;ひとつは&lt;a href=&#34;https://en.wikipedia.org/wiki/Null_Object_pattern&#34;&gt;Nullオブジェクト&lt;/a&gt;デザインパターンだ。(それをひとつの不変オブジェクトにするのが最善。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    return Employee.NOBODY;
  }
  return Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もうひとつは、オブジェクトを返せないときに例外を投げて&lt;a href=&#34;http://martinfowler.com/ieeeSoftware/failFast.pdf&#34;&gt;フェイルファスト&lt;/a&gt;することだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  if (id == 0) {
    throw new EmployeeNotFoundException(name);
  }
  return Employee(id);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;さて、&lt;code&gt;NULL&lt;/code&gt;に反対する論拠を見てみよう。&lt;/p&gt;

&lt;p&gt;因みに、上記Tony HoareのプレゼンやDavid Westの著書に加えて、私はこの記事を書く前に以下の本や記事を読んだ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Robert Martinの&lt;a href=&#34;http://www.amazon.com/dp/0132350882/&#34;&gt;Clean Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Steve McConnellの&lt;a href=&#34;http://www.amazon.com/dp/0735619670/&#34;&gt;Code Complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;John Sonmezの&lt;a href=&#34;http://elegantcode.com/2010/05/01/say-no-to-null/&#34;&gt;Say &amp;ldquo;No&amp;rdquo; to &amp;ldquo;Null&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;StackOverflowの&lt;a href=&#34;http://stackoverflow.com/questions/1274792/is-returning-null-bad-design&#34;&gt;Is returning null bad design?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;アドホック-場当たりな-エラー処理&#34;&gt;アドホック(場当たりな)エラー処理&lt;/h3&gt;

&lt;p&gt;インプットとしてオブジェクトを受け取った場合は常に、それが&lt;code&gt;NULL&lt;/code&gt;でないか、また有効なオブジェクト参照かどうかを確認しないといけない。
その確認を忘れると、&lt;code&gt;NullPointerException&lt;/code&gt; (NPE)が実行時に処理を止めてしまう恐れがある。
このため、ロジックが複数の確認処理やif/then/else分岐に汚染されてしまう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// this is a terrible design, don&#39;t reuse
Employee employee = dept.getByName(&amp;quot;Jeffrey&amp;quot;);
if (employee == null) {
  System.out.println(&amp;quot;can&#39;t find an employee&amp;quot;);
  System.exit(-1);
} else {
  employee.transferTo(dept2);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/C%E8%A8%80%E8%AA%9E&#34;&gt;C&lt;/a&gt;などの命令文を並べる手続き型言語において、例外的な状況に対応する手法だ。
OOPは、主にこういったアドホックエラー処理のブロックを排除する目的で、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E4%BE%8B%E5%A4%96%E5%87%A6%E7%90%86&#34;&gt;例外処理&lt;/a&gt;を導入した。
OOPでは、例外処理をアプリケーションレベルのエラーハンドラにまかせることで、コードをかなりきれいで短いものにできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;dept.getByName(&amp;quot;Jeffrey&amp;quot;).transferTo(dept2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;参照は手続き型言語から受け継がれたものだと認識し、Nullオブジェクトか例外を変わりに使うべきだ。&lt;/p&gt;

&lt;h3 id=&#34;あいまいな意図&#34;&gt;あいまいな意図&lt;/h3&gt;

&lt;p&gt;上記メソッドの目的を明確に伝えるためには、&lt;code&gt;getByName()&lt;/code&gt;は&lt;code&gt;getByNameOrNullIfNotFound()&lt;/code&gt;という名前でなければいけない。
これと同様の名前を、オブジェクトか&lt;code&gt;NULL&lt;/code&gt;を返す全ての関数が持たなければいけない。
さもなくば、だれかがあいまいなコードを読むはめになる。だから、コードの意図を明確にするために、関数に長い名前をつけるべきだ。&lt;/p&gt;

&lt;p&gt;このあいまいさを排除するために、関数は、実オブジェクトを返すか、Nullオブジェクトを返すか、例外を投げる、しかしてはいけない。&lt;/p&gt;

&lt;p&gt;性能を考慮すると&lt;code&gt;NULL&lt;/code&gt;を返さざるを得ない場合もあるだろうと主張する人がいるかもしれない。
たとえば、Javaの&lt;code&gt;&lt;a href=&#34;http://docs.oracle.com/javase/jp/7/api/java/util/Map.html&#34;&gt;Map&lt;/a&gt;&lt;/code&gt;インターフェースの&lt;code&gt;get()&lt;/code&gt;メソッドは、指定された要素がないときに&lt;code&gt;NULL&lt;/code&gt;を返す。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Employee employee = employees.get(&amp;quot;Jeffrey&amp;quot;);
if (employee == null) {
  throw new EmployeeNotFoundException();
}
return employee;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このコードでは、&lt;code&gt;Map&lt;/code&gt;が&lt;code&gt;NULL&lt;/code&gt;を使っているおかげで、mapを一回しか検索しない。
もし、&lt;code&gt;Map&lt;/code&gt;の&lt;code&gt;get()&lt;/code&gt;を、要素が見つからないときに例外を投げるように修正したら、以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;if (!employees.containsKey(&amp;quot;Jeffrey&amp;quot;)) { // first search
  throw new EmployeeNotFoundException();
}
return employees.get(&amp;quot;Jeffrey&amp;quot;); // second search
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明らかに、この方法は最初のものより2倍遅い。さて、どうする?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;インターフェースは、(作者を攻めるわけではないが、)設計に問題がある。
その&lt;code&gt;get()&lt;/code&gt;メソッドは&lt;code&gt;Iterator&lt;/code&gt;を返すべきで、その場合以下のようなコードになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Iterator found = Map.search(&amp;quot;Jeffrey&amp;quot;);
if (!found.hasNext()) {
  throw new EmployeeNotFoundException();
}
return found.next();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに、C++の標準ライブラリの&lt;a href=&#34;http://www.cppll.jp/cppreference/cppmap_details.html&#34;&gt;map::find()&lt;/a&gt;はまさにこのように設計されている。&lt;/p&gt;

&lt;h3 id=&#34;コンピュータ思考-vs-オブジェクト思考&#34;&gt;コンピュータ思考 vs. オブジェクト思考&lt;/h3&gt;

&lt;p&gt;Javaのオブジェクトはデータ構造を指すポインタで、&lt;code&gt;NULL&lt;/code&gt;は何も指さないポインタ(Intel x86プロセッサでは0x00000000)であることを知っている人にとっては、&lt;code&gt;if (employee == null)&lt;/code&gt;という文は理解できる。&lt;/p&gt;

&lt;p&gt;しかし、もし君がオブジェクトになって考えたとすると、この文はかなり意味のないものになる。オブジェクト視点で上記コードは以下のように見える。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- もしもし、ソフトウェア部ですか?
- はい。
- Jeffreyと話したいのですが。
- 少々お待ちください。。。
- もしもし。
- あなたはNULLですか?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会話の最後の質問が変だろ?&lt;/p&gt;

&lt;p&gt;代わりに、もしJeffreyへの取り次ぎをお願いした後で電話が切れたら、自分に問題(例外)が発生した、ということにする。
この時点で、もう一度電話してみるか、Jeffreyにつながらないので仕事が進みませんと上司に報告する。&lt;/p&gt;

&lt;p&gt;あるいは、ソフトウェア部の人が、Jeffreyではないがだいたいの質問に答えられる人に取り次いでくれるかもしれないし、
Jeffreyにしかわからない用事だから無理、と拒否してくるかもしれない(Nullオブジェクト)。&lt;/p&gt;

&lt;h3 id=&#34;遅いエラー&#34;&gt;遅いエラー&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://martinfowler.com/ieeeSoftware/failFast.pdf&#34;&gt;フェイルファスト&lt;/a&gt;な&lt;code&gt;getByName()&lt;/code&gt;に対して、Nullオブジェクトを使った方はゆっくり死のうとしている。途中で他のものを殺しながら。
問題が発生したので例外処理をすぐに始めるべきだと周りに知らせる代わりに、クライアントからエラーを隠している。&lt;/p&gt;

&lt;p&gt;この議論は、前述した「アドホックエラー処理」に近い。&lt;/p&gt;

&lt;p&gt;コードはできるだけもろい方がいい。必要なときに壊れるように。&lt;/p&gt;

&lt;p&gt;メソッドを、それが扱うデータに対してできるだけ厳しくさせ、与えられたデータに不備があったりメソッドの使用方法に反していたら、例外を投げるようにすべきだ。&lt;/p&gt;

&lt;p&gt;もしくは、共通的な挙動をする他は常に例外を投げるNullオブジェクトを返すべきだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public Employee getByName(String name) {
  int id = database.find(name);
  Employee employee;
  if (id == 0) {
    employee = new Employee() {
      @Override
      public String name() {
        return &amp;quot;anonymous&amp;quot;;
      }
      @Override
      public void transferTo(Department dept) {
        throw new AnonymousEmployeeException(
          &amp;quot;I can&#39;t be transferred, I&#39;m anonymous&amp;quot;
        );
      }
    };
  } else {
    employee = Employee(id);
  }
  return employee;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;可変で不完全なオブジェクト&#34;&gt;可変で不完全なオブジェクト&lt;/h3&gt;

&lt;p&gt;一般的に、オブジェクトは&lt;a href=&#34;http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html&#34;&gt;不変的&lt;/a&gt;に設計することが望ましい。
これはつまり、オブジェクトはインスタンス化の際に必要な情報を全て受け取り、その後そのライフサイクル全体に渡ってその状態を変えないということだ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;NULL&lt;/code&gt;は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E9%81%85%E5%BB%B6%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF&#34;&gt;遅延読み込み&lt;/a&gt;をする際によく使われ、オブジェクトを不完全で可変にしてしまう。以下が例だ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Department {
  private Employee found = null;
  public synchronized Employee manager() {
    if (this.found == null) {
      this.found = new Employee(&amp;quot;Jeffrey&amp;quot;);
    }
    return this.found;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この手法は、広く使われてはいるが、OOPにおけるアンチパターンだ。
主な理由は、実行環境の性能問題の責任をオブジェクトに負わせているからだ。本来それは&lt;code&gt;Employee&lt;/code&gt;オブジェクトが気にすべきことではない。&lt;/p&gt;

&lt;p&gt;オブジェクトが、自身の状態を管理して、自身の役割に関するふるまいを公開する代わりに、戻り値のキャッシュの面倒を見なければいけない。これが遅延読み込みというものだ。&lt;/p&gt;

&lt;p&gt;キャッシュはemployee(従業員)がオフィスでするようなことじゃないだろ?&lt;/p&gt;

&lt;p&gt;解決策?
遅延読み込みを上記の例みたいな原始的な方法でやらないことだ。代わりに、キャッシュ処理をアプリケーションの他のレイヤに移せばいい。&lt;/p&gt;

&lt;p&gt;たとえば、Javaなら、アスペクト指向プログラミングのアスペクトが使える。
たとえば、&lt;a href=&#34;http://aspects.jcabi.com/&#34;&gt;jcabi-aspects&lt;/a&gt;には&lt;code&gt;&lt;a href=&#34;http://aspects.jcabi.com/annotation-cacheable.html&#34;&gt;@Cacheable&lt;/a&gt;&lt;/code&gt;というアノテーションがあり、メソッドの戻り値をキャッシュできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import com.jcabi.aspects.Cacheable;
public class Department {
  @Cacheable(forever = true)
  public Employee manager() {
    return new Employee(&amp;quot;Jacky Brown&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;君がこの分析に納得して&lt;code&gt;NULL&lt;/code&gt;を使うのをやめることを願う。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/o3aNJX7AP3M&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Nullを使っちゃだめという意見はめずらしくないが、その根拠をコードの信頼性、可読性といった技術的な側面からだけでなく、
オブジェクト界に降り立って見たときに感じる違和感というオブジェクト哲学的な側面からも説明する辺りが面白い。&lt;/p&gt;

&lt;p&gt;まあNullを完全に使わないという境地には、少なくともJavaのコードでは一生たどり着ける気がしないが。
メソッドの先頭で引数のNullチェックをするとかもダメなんだろうか。それがダメだとフェイルファストができなかったり、メッセージのないNullPointerExceptionが発生したりして微妙。
あ、フルスクラッチで完全に自己完結したアプリケーションを作る場合の話か。それならそもそもNullを渡すなという話にしかならないか。&lt;/p&gt;

&lt;p&gt;自分で書くクラスやライブラリについて、Nullは内部的には使うけど、APIには一切Nullを返させない、くらいなら実現するのは難しくなさそうだし、やったほうがいい気もする。(この場合遅延読み込みで一時的にNullをセットしておくのはあり。)
ただ、性能を考えた場合は、例えばエラー処理はアドホックが一番軽くて、次にNullオブジェクトパターンで、例外はちょっと重めという風になるだろうから、Nullを返したくなることもありそう。&lt;/p&gt;

&lt;p&gt;ことあるごとに例外を投げてくるAPIは使う側にとってはうっとうしいしなぁ。
多彩な例外を投げ分けるJavaのリフレクションみたいなのは、使うとコードが散らかってかなわん。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Getter/Setterは悪だ。以上。</title>
          <link>https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/</link>
          <pubDate>Wed, 22 Jul 2015 00:21:15 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/</guid>
          <description>

&lt;p&gt;このエントリでは、Yegor Bugayenkoによる記事、&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt;を紹介する。
(Yegorから和訳と転載の許可は得た。)
以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2003年にAllen Holubが書いた&lt;a href=&#34;http://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html&#34;&gt;Why getter and setter methods are evil&lt;/a&gt;という有名な記事に端を発する古い議論がある。それは、getter/setterはアンチパターンで避けるべきものなのか、
もしくはオブジェクト指向プログラミングに必須なものなのかというもの。
この議論に少しだけ私の意見を加えたいと思う。&lt;/p&gt;

&lt;p&gt;上記記事の要旨はこうだ。
getterやsetterはひどい慣習で、これらを使うやつらはゆるせん。誤解の無いようもう一度言うが、
私はget/setを可能な限り避けるべきだと言っているのではない。それらは君のコードに決して現れてはいけないのだ。&lt;/p&gt;

&lt;p&gt;横柄で目につく物言いだろう?
君は15年来get/setパターンを使い続けている尊敬を集めるJavaアーキテクトなんだろう?
どこぞの馬の骨にこんなデタラメを言われたくはないだろう?
ああ、その気持ちはわかる。私がDavid Westの&lt;a href=&#34;http://www.amazon.com/gp/product/0735619654/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0735619654&amp;amp;linkCode=as2&amp;amp;tag=yegor256com-20&amp;amp;linkId=NQQHJZPHOKM6BTCT&#34;&gt;Object Thinking&lt;/a&gt;という本に出会ったとき、
私もほとんど同じことを感じた。
Object Thinkingは、私が今まで読んだオブジェクト指向プログラミングについての本の中で最高のものだ。
だからお願いだ。ひとまず落ち着いて。私に説明させてほしい。&lt;/p&gt;

&lt;h3 id=&#34;既存の論拠&#34;&gt;既存の論拠&lt;/h3&gt;

&lt;p&gt;オブジェクト指向の世界で、アクセッサ(getterやsetterの別名)に反対する論拠はいくつかあるが、
私にはそれら全てが十分に有力であるとは思えない。ひとつひとつ簡単に見ていこう。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;頼め、尋ねるな&lt;/p&gt;

&lt;p&gt;Allen Holub曰く、「ある処理をする際、その処理のために君が欲しい情報をオブジェクトに尋ねてはいけない。
その情報を持ったオブジェクトにその処理をするよう頼みなさい。」&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;カプセル化原則違反&lt;/p&gt;

&lt;p&gt;setterを通してどんな新たなデータも入力できるので、
一つのオブジェクトをその他の様々なオブジェクトが様々に扱うことができてしまう。
また、だれでもオブジェクトを変更できるので、
オブジェクトが単純に自身の状態を安全にカプセル化できない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;実装の詳細の暴露&lt;/p&gt;

&lt;p&gt;あるオブジェクトから他のオブジェクトを取得できる場合、前者のオブジェクトの実装の詳細に過度に依存してしまう。
もし明日その実装、例えば返すオブジェクトの型が変わったら、周辺のコードも書き換えないといけない。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これらの全ての論拠は正当だが、重要なポイントが抜けている。&lt;/p&gt;

&lt;h3 id=&#34;根本的な誤解&#34;&gt;根本的な誤解&lt;/h3&gt;

&lt;p&gt;ほとんどのプログラマはオブジェクトはメソッドを持ったデータ構造だと考えている。
ここでBozhidar Bozhanovによる記事、&lt;a href=&#34;https://dzone.com/articles/getters-and-setters-are-not&#34;&gt;Getters and Setters Are Not Evil&lt;/a&gt;から引用する。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;しかし、人々がgetterやsetterをつけるオブジェクトのほとんどが、単純なデータホルダだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;この思い違いが巨大な誤解の結果だ!
オブジェクトは単純なデータホルダではない。オブジェクトはメソッド付きのデータ構造ではない。
このデータホルダというコンセプトは、CやCOBOLといった手続き型言語からオブジェクト指向プログラミングに持ち込まれたものだ。
もう一度言う。オブジェクトはデータとそれを操作する関数をセットにしたものではない。
オブジェクトはデータエンティティではない。では何か?&lt;/p&gt;

&lt;h3 id=&#34;ボールと犬&#34;&gt;ボールと犬&lt;/h3&gt;

&lt;p&gt;真のオブジェクト指向プログラミングでは、
オブジェクトは&lt;a href=&#34;https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/&#34;&gt;生きている生物&lt;/a&gt;だ。私や君と同じように。
オブジェクトは生きている有機体で、それ自身の挙動や、特性や、ライフサイクルを持っている。&lt;/p&gt;

&lt;p&gt;生きている有機体はsetterを持てるだろうか? 犬にボールを&amp;rdquo;set&amp;rdquo;できるだろうか? 無理だろう。
だが、以下のコードはまさにそれをしている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setBall(new Ball());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどう感じる?&lt;/p&gt;

&lt;p&gt;また、ボールを犬から取得できるだろうか?
まあ、できるかもしれない、もしその犬がボールを食べて、君が手術をするのであれば。
この場合、確かに、犬からボールを&amp;rdquo;get&amp;rdquo;できる。以下のコードが今話したようなことをやっている。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
Ball ball = dog.getBall();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;またさらにばかげた例がこれだ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.setWeight(&amp;quot;23kg&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現実世界でこの処理がどんなか想像できるかな?&lt;/p&gt;

&lt;p&gt;君が毎日書いているコードはこれに似ているかい?
もしそうなら、君は手続き型プログラマだ。認めなさい。
David Westが彼の本の30ページでそれについて以下のように言っている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;成功した手続き型開発者が成功するオブジェクト開発者に移行するための最初のステップは、ロボトミーだ。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;君はロボトミーが必要か？
因みに、WestのObject Thinkingを読んでいた時、私には明らかに必要だったので受けた。&lt;/p&gt;

&lt;h3 id=&#34;オブジェクト思考&#34;&gt;オブジェクト思考&lt;/h3&gt;

&lt;p&gt;オブジェクト思考を開始すると、君は即座にメソッド名を変更し、多分以下のコードに辿り着く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog();
dog.take(new Ball());
Ball ball = dog.give();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今、私たちは犬を実際の動物として扱っている。この犬は、ボールを私たちから受け取り、頼めば返してくれる。
ここで特筆すべきは、この犬は &lt;code&gt;NULL&lt;/code&gt; を返すことはできない。犬は &lt;code&gt;NULL&lt;/code&gt; が何なのかなんて知らないからね。オブジェクト思考は即座に&lt;a href=&#34;http://www.yegor256.com/2014/05/13/why-null-is-bad.html&#34;&gt;NULL参照&lt;/a&gt;をコードから排除する。&lt;/p&gt;

&lt;p&gt;さらに、オブジェクト思考はオブジェクト不変性につながる。
犬の体重の例を、君は以下のように書き換えるだろう。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Dog dog = new Dog(&amp;quot;23kg&amp;quot;);
int weight = dog.weight();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この犬は不変な生きた有機体であり、だれも外からその体重やサイズや名前などを変更することはできない。
この犬は要求に応じて体重や名前を教えてくれる。
オブジェクトの中身を要求するパブリックメソッドには何の問題もないが、
こういったメソッドは&amp;rdquo;getter&amp;rdquo;ではなく、&amp;rdquo;get&amp;rdquo;というプレフィックスは決して付かない。
私たちは犬から何かを取ろうというのではない。犬から名前を取るのではなく、犬に名前を教えてくれるよう頼むのだ。
この違いが分かるかな?&lt;/p&gt;

&lt;p&gt;語義論の話をしているというわけでもない。
手続き型プログラミング思考とオブジェクト指向プログラミング思考とを区別しようというのだ。
手続き型プログラミングでは、私たちはデータを扱い、必要に応じてそれを操作したり取得したりセットしたり消したりする。
私たちはデータの責任者で、そのデータは単なる受動的なコンポーネントだ。
犬は私たちとは何の関係もなく、ただのデータホルダだ。それは生命を持っていない。
私たちはそれから必要なものを何でも自由に取得できるし、どんなデータでもセットすることができる。
これがCやCOBOLやPascalなどの手続き型言語のやりかただ。&lt;/p&gt;

&lt;p&gt;それに対して、真のオブジェクト指向の世界では、オブジェクトを生きた有機体のように扱い、
オブジェクトには生まれた日と死ぬ瞬間がある。また、君が望むなら、アイデンティティや性質を持たせてもいい。
犬にはデータの一部(例えば体重)をくれるよう頼むことができるし、犬はその情報を返してもよい。
ただ、この犬は能動的なコンポーネントであることを忘れてはいけない。
こちらの要求に対し、何をするかは犬が決めるのだ。&lt;/p&gt;

&lt;p&gt;以上が、getやsetで始まるメソッドをオブジェクトに持たせることが概念的に間違っている理由だ。
それは、多くの人々が主張するように、カプセル化を崩すということではない。
それは、君がオブジェクト的な思考をしているか、もしくは今だCOBOLをJavaのシンタックスで書いているかということだ。&lt;/p&gt;

&lt;p&gt;追伸: そうだ、君はこう尋ねるかもしれない。JavaBeans、JPA、JAXBなどのget/set表記に頼るJava APIはどうなんだ?
Rubyに付属するアクセッサ生成を簡易化する機能は?
ああ、それらは全て私たちにとっての不幸だ。
手続き型COBOLの原始的な世界に留まることは、真のオブジェクトからなる美しい世界を正しく理解し感謝するのに比べてはるかに簡単だ。&lt;/p&gt;

&lt;p&gt;追追伸: 言い忘れたが、setterを使った依存性注入もひどいアンチパターンだ。
それについてはいずれ書く。&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;embed video-player&#34; style=&#34;text-align: center&#34;&gt;
  &lt;iframe class=&#34;youtube-player&#34; type=&#34;text/html&#34; width=&#34;320&#34; height=&#34;193&#34; src=&#34;https://www.youtube.com/embed/WSgP85kr6eU&#34; allowfullscreen frameborder=&#34;0&#34;&gt;
  &lt;/iframe&gt;
&lt;/div&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上がYegorの記事。&lt;/p&gt;

&lt;p&gt;Javaを始めた当初から今まで、Getter/Setterは絶対正義だと信じ、クラスを作れば無心でIDEの言いなりにそれを生成していたので、
この記事はなかなかに刺激的だった。(まあfinalなフィールドが好きなのでsetterの方はあまり作らなかったが。)&lt;/p&gt;

&lt;p&gt;ただ、記事の本質としては、Getter/Setterパターン、つまり、
オブジェクトのフィールドをprivateにし、メソッドを介してアクセスさせるようにすることで、実装の詳細を隠蔽し、
APIと分離させることを図るデザインパターンの技術的役割や目的を否定しているわけではなく、
オブジェクト指向の哲学的な部分にも則り、Getter/Setterパターンを真のオブジェクト界に向けて昇華させましょうと言っているように読める。&lt;/p&gt;

&lt;p&gt;犬とボールのやり取りをするコードのビフォーアフターはsetBall/getBallがtake/giveになっただけで、
これだけ見れば処理が変わるわけでもないし、コンパイラに言わせればどっちでもいいだろとなる。
ただ、プログラマにボールを無下につっこまれるビフォーの犬よりも、
自ら能動的にボールを受け取り返してくれるアフターの犬の方が幸せそうで愛らしいのは確かだ。
真のオブジェクト界を垣間見た気がする。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>First Post</title>
          <link>https://www.kaitoy.xyz/2015/07/18/first-post/</link>
          <pubDate>Sat, 18 Jul 2015 13:10:37 -0600</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2015/07/18/first-post/</guid>
          <description>&lt;p&gt;初投稿。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;p&gt;ブログを立ち上げようと思ったきっかけは、&lt;a href=&#34;http://www.teamed.io/&#34;&gt;Teamed.io&lt;/a&gt;というCaliforniaのソフトウェアアウトソーシング(?)をやってる会社のCTO、
Yegor Bugayenko (yegor256)のブログのエントリ、&lt;a href=&#34;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html&#34;&gt;How Much Do You Cost?&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;これは、Teamed.ioがエンジニアに払うfeeを決める際の指標についてのエントリで、その指標の一つとして &lt;em&gt;Talks and Publications&lt;/em&gt; を挙げている。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Both blog articles and conference presentations make you much more valuable as a specialist.
Mostly because these things demonstrate that some people already reviewed your work and your talent.
And it was not just a single employer, but a group of other programmers and engineers.
This means that we also can rely on your opinions.&lt;/p&gt;

&lt;div style=&#34;font-size: 0.5em; text-align: right;&#34;&gt;&lt;cite&gt;引用元: &lt;a href=&#34;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html#talks-and-publications&#34;&gt;http://www.yegor256.com/2014/10/29/how-much-do-you-cost.html#talks-and-publications&lt;/a&gt;&lt;/cite&gt;&lt;/div&gt;
&lt;/blockquote&gt;

&lt;p&gt;つまり、カンファレンスで発表したりブログで意見を発信すると、それらを見た様々な人たちによってレビューされフィードバックを受けることになるので、
そういった経験が多いエンジニアは、より洗練された考えや技術を持っているとみなせるということ。&lt;/p&gt;

&lt;p&gt;確かに、普段会社の同僚としか接しないので、自分の意見を広く発信してフィードバックを受けるのは刺激になりおもしろそうだしためになりそう。
ただそのためにはこのブログが広く読まれコメントをもらえるまでになる必要があるが、それはさておき、
文筆の練習として、また物事に対する理解を深めるためにも、書くということは有益であろう。備忘録にもなるし。&lt;/p&gt;

&lt;p&gt;因みに、Yegorはオブジェクト指向プログラミングの原理主義者で、ソフトウェア開発に対して非常に厳格で斬新な(異端な?)考え方を持っている。
それは例えば彼の以下のブログエントリに見られる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2015/01/08/morning-standup-meetings.html&#34;&gt;Daily Stand-Up Meetings Are a Good Tool for a Bad Manager&lt;/a&gt; (スタンドアップミーティングはダメマネージャーが好む手法)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html&#34;&gt;ORM Is an Offensive Anti-Pattern&lt;/a&gt; (ORMはけしからんアンチパターン)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html&#34;&gt;Getters/Setters. Evil. Period.&lt;/a&gt; (GetterやSetterは悪だ。以上。)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下で働くと苦労しそうなタイプな気はするが、言っていることは面白いし説得力もあるので、いくつかのエントリを和訳しておいおいここで紹介していこうかと思う。&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
