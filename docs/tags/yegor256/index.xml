<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yegor256  on To Be Decided</title>
    <link>https://www.kaitoy.xyz/tags/yegor256/</link>
    <description>Recent content in yegor256  on To Be Decided</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© 2015 Kaito Yamada</copyright>
    <lastBuildDate>Sat, 25 Jun 2016 18:00:29 -0600</lastBuildDate>
    
	<atom:link href="https://www.kaitoy.xyz/tags/yegor256/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>ソフトウェアプロジェクトの7つの大罪</title>
      <link>https://www.kaitoy.xyz/2016/06/25/seven-deadly-sins-of-a-software-project/</link>
      <pubDate>Sat, 25 Jun 2016 18:00:29 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2016/06/25/seven-deadly-sins-of-a-software-project/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、Seven Deadly Sins of a Software Projectを紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  保守性は近代ソフトウェア開発において最も重要な美徳だ。 保守性は基本的に、新規開発者が本格的な修正を始める前に必要な学習時間で測ることができる。 学習時間が長いほど保守性は低い。 必要な学習時間が無限に近いプロジェクトもあるが、これは文字通り保守不能だ。 私はソフトウェアを保守不能にする7つの基本的で致命的な罪があると考えている。 それらについてここに書く。
アンチパターン 不幸にも、我々が使っているプログラミング言語は柔軟すぎる。 可能なことが多過ぎ、禁止されていることは少なすぎる。 例えばJavaは、数千のメソッドを持った単一の「クラス」でアプリケーション全体を記述することに何の反抗もしない。 このアプリケーションは技術的にはコンパイルして実行できる。 しかしこれはゴッドオブジェクトと呼ばれるよく知られたアンチパターンだ。
つまり、アンチパターンは技術的には設計に取り入れることができるが、一般的には取り入れるべきではないとされている。 言語ごとに多くのアンチパターンがある。 プロダクトに使われているアンチパターンは、生きている有機体の中の腫瘍のようなものだ。 いったん成長し始めると止めるのは非常に難しい。 やがて体全体が死に至る。 やがてソフトウェア全体が保守不能になり、書き直さなければならなくなる。
ひとたびアンチパターンを使ってしまうと、その量は次第に増え、「腫瘍」は育つばかりだ。
これは特にオブジェクト指向言語(Java、C++、Ruby、Python)に当てはまる。 これらが手続き型言語(C、Fortran、COBOL)から多くを引き継いでしまっているからだ。 また、OOP開発者が手続き型で命令的な思考をする傾向にあるからだ。残念なことに。
ところで、既存の有名なアンチパターンのほかに、私は以下のものもダメなコーディング法だと考えている。
 NULL参照 ユーティリティクラス 可変オブジェクト GetterとSetter オブジェクト関係マッピング(ORM) シングルトン Controllers、Managers、Validators Public Static メソッド キャスト  私ができる実践的な提案は、読んで学ぶということだけだ。 ここに挙げた本か私の著書「&amp;ldquo;Elegant Objects」が多分助けになるだろう。 常にソフトウェアの品質を疑い、「動く」ということだけで満足してはいけない。 ちょうど癌のように、診断が早ければ早いほど生き残る可能性が大きい。
追跡不能な変更 コミット履歴を見るとき、全ての個々の変更に対して、何を、誰が、なぜ変更したのかがわからないといけない。 さらに、これら3つの情報を得るのにかかる時間は秒単位で計測しないといけない。 殆どのプロジェクトがこのようにできていない。 以下に実践的な提案を示す。
常にチケットを使う プロジェクトやチームがどんなに小さくても、例え一人だけでも、修正しようとしている全ての問題に対してチケット(GitHub issues)を作れ。 チケットに問題の簡単な説明とそれに対する考えを記述しろ。 このチケットをその問題に関する全ての情報の一時的なストレージとして使え。 将来、他の誰かがその「不可解なコミット」が何であるかを理解するために参照する可能性のある全ての情報をそこに書け。</description>
    </item>
    
    <item>
      <title>継続的インテグレーションは死んだ</title>
      <link>https://www.kaitoy.xyz/2016/02/09/continuous-integration-is-dead/</link>
      <pubDate>Tue, 09 Feb 2016 00:34:41 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2016/02/09/continuous-integration-is-dead/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、Continuous Integration is Deadを紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  数日前、「なぜ継続的インテグレーションは機能しないのか」という私の記事がDevOps.comに公開された。 それとほぼ同じ日に、Twitterで非常に否定的な批評が送られてきた。
 継続的インテグレーションが機能しないとはどういうことだ。この人気なすばらしいアイデアが。
 その求めてもない質問への返事をここに書く。
私はこの分野に関して多少の経験があるが、それに基いた論拠は挙げない。 代わりにロジックだけを頼りにする。
ところで、私には50以上のオープンソースや営利プロジェクトで5年間Apache Continuum、Hudson、CruiseControl、Jenkinsを利用した経験がある。 さらに、数年前fazend.com(2013年にrultor.comに改名)というホスト型継続的インテグレーションサービスを開発した。 現在TravisとAppVeyorのアクティブユーザでもある。
継続的インテグレーションはどう機能すべきか 考え方はシンプルで明確だ。 masterブランチ(Subversionなら/trunk)に新しくコミットをする度に、継続的インテグレーションサーバ(またはサービス)はプロダクト全体のビルドを試みる。 「ビルド」というのはコンパイル、ユニットテスト、統合テスト、品質解析などを意味する。
その結果は「成功」か「失敗」だ。 もし成功だったら「ビルドがクリーン」であると言う。 もし失敗だったら、「ビルドが壊れている」と言う。 通常、ビルドが壊れるのは、以前通っていたユニットテストを通らなくするような新しいコードをだれかがコミットしたからだ。
これは問題の技術的な面だ。 この部分はいつも上手くいく。 まあ、依存が直書きされてるとか、ビルド環境が十分分離されていないとか、ビルドの並列性が完全じゃないとか、そういう問題はあるかもしれないが、この記事はそれらについてではない。 アプリケーションが上手く書かれていてユニットテストが安定しているなら、継続的インテグレーションは簡単だ。 技術的には。
組織的な面を見てみよう。
継続的インテグレーションというのは、ビルドを実行するサーバだけを指すのではなく、上手く機能すべき管理的/組織的プロセスだ。 プロセスが上手く機能するとは、Jez Humbleが「継続的デリバリー: ビルド、テスト、デプロイの自動化による確実なソフトウェアリリース」の55ページで言っていることそのものを意味する。
 もしビルドが失敗したら、開発チームは何をやっていたとしてもそれを中断して、そのビルドの問題を速やかに直す。これが重要だ。
 これが上手くいかず、上手くできないことだ。
誰がこれを必要としているのか 既に述べた通り、継続的インテグレーションとは、開発チーム全体を止めて壊れたビルドを修正させることだ。 繰り返すが、ビルドが壊れたら直ちに、それを修正し、ビルドを安定した状態に戻すコミットを入れることに全員が集中すべきだ。
ここでひとつ疑問が生じる。誰が、活動中のチーム内の誰がこれを必要としているのだろうか?
一刻も早く新しい機能をリリースしたいプロダクトオーナ? または、締め切りに責任を持つプロジェクトマネージャかもしれない。 もしくは、他の誰かが作りこんだバグをプレッシャーを受けながら修正すること嫌うプログラマかもしれない。
誰がこの継続的インテグレーションを好み、誰が必要としているのか?
誰でもない。
実際に何が起こるのか 教えよう。 私は何度も見たことがある。 シナリオはいつも同じだ。 継続的インテグレーションのビルドステータスは単に無視されるようになる。 ビルドがクリーンか壊れているかにかかわらず。 そして以前のやり方が継続される。
Jez Humbleが推奨するように開発を止めて問題に対応したりしない。</description>
    </item>
    
    <item>
      <title>ソフトウェアアーキテクトは何をするのか?</title>
      <link>https://www.kaitoy.xyz/2016/01/11/who-is-software-architect/</link>
      <pubDate>Mon, 11 Jan 2016 14:41:29 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2016/01/11/who-is-software-architect/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、What Does a Software Architect Do?を紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  君のプロジェクトにはソフトウェアアーキテクトが居るだろうか? 必要だと思う?
まあ、ほとんどのアジャイルチームはそのような役割を明確には定義せず、民主的な感じで働く。 全ての重要な技術的な意思決定はチーム全体で議論され、最多数の投票を得た解決策が採用される。 しばらくして、このようなチームが「ソフトウェアアーキテクト」バッジを誰かのTシャツに付ける事に決めたときは、もっとも評判のいいプログラマがそのバッジを手にする。
このバッジが彼の責務を変えることはまれだけども。 結局、チームは同じように働き続け、全員を巻き込んだ技術的議論を楽しむ。 つまり、ソフトウェアアーキテクトは責務が明確に定義された役割というよりもステータスになる。 それは最年長で最も権限のある人へのチームメンバからの尊敬の印になる。そうだろ?
全く間違っている!
アーキテクトは品質の責任を負う 普通はアーキテクトは最も知識、スキル、経験、権限がある人がなるということは明らかだ。 もちろん普通はアーキテクトは他の人よりもものを知っていて、必要に応じて外交的指導的手腕を発揮してその知識を伝達する。 アーキテクトは普通はチームの中で最も賢いやつだ。
しかしこのことは、彼をアーキテクトたらしめているものではない。
そして、チームに必要なものでもない。
私のソフトウェアアーキテクトの定義こうだ。 アーキテクトは品質の責任を負う人だ。
「責任 (blame)」を職責 (accountability) とか 責務 (responsibility) と言い換えてもいいが、私は「責任 (blame)」という言葉を使うのがいいと思う。 なぜなら、開発中の製品の全ての品質問題がアーキテクトの個人的な失敗であることをより強調するからだ。 もちろん、その責任の対価として、品質がよかった場合には満足した顧客からの称賛は全てアーキテクトのものだ。
これがチームに必要なものだ。 開発するソフトウェアの品質に対して誰かが個人的に責任を負うのだ。
プロジェクトマネージャの仕事は、アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすること アーキテクトが他のメンバにどのように責任を委譲するかはアーキテクト自身の仕事だ。 知識やスキル、品質管理ツール、ユニットテストフレームワーク、権限、コーチング、体罰、何を使おうとも、それが彼の仕事だ。 プロジェクトマネージャは品質管理をソフトウェアアーキテクトに委譲した。 それをさらにどう委譲するかはソフトウェアアーキテクト次第だ。
ソフトウェアアーキテクトの役割は全てのプロジェクトにおいて重大だ。 たとえたった二人のプログラマが同じデスクで働いている場合でもだ。 二人のうち一人はアーキテクトでなければならない。
理想的なアーキテクトは上記の長所の全てを持つ。 彼は全員の意見を聞いて考慮に入れる。 彼はよいコーチであり先生だ。忍耐もある。 彼は効果的な伝達者であり交渉人だ。 外交官だ。 技術的な領域のエキスパートだ。
しかし、たとえこうした長所全てを持たなくても、彼の決定は常に最終決定だ。
そして、プロジェクトマネージャの仕事は、アーキテクトによる全ての技術的決定に対して誰にも不信を抱かせないようにすることだ。 これが委譲というものだ。 責任には常に権力が伴う。
プロジェクトマネージャは定期的にアーキテクトの成果を評価すべきだ。 チームで開発中の製品の品質はアーキテクトの個人的な(!)責任だということを思い出してほしい。 どんな問題であっても彼の問題だ。 彼を責めたり罰したりすることを恐れてはいけない。 ただし、罰を有効なものにするためには、アーキテクトの行動に対して全力で応えるべきだということをを忘れてはいけない。 繰り返すが、彼の決定は最終決定だ。</description>
    </item>
    
    <item>
      <title>オブジェクト指向プログラミングにおいてユーティリティクラスに代わるもの</title>
      <link>https://www.kaitoy.xyz/2016/01/03/oop-alternative-to-utility-classes/</link>
      <pubDate>Sun, 03 Jan 2016 23:36:01 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2016/01/03/oop-alternative-to-utility-classes/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、OOP Alternative to Utility Classesを紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  ユーティリティクラス(またはヘルパークラス)は、スタティックメソッドだけを持っていて、状態を内包しない「構造体」だ。 Apache CommonsのStringUtils、IOUtils、FileUtilsや、GuavaのIterables、Iterators、またJDK7のFilesはユーティリティクラスのいい例だ。
ユーティリティクラスはよく使われる共通機能を提供するので、この設計手法はJava(やC#、Rubyなど)の世界でとても人気だ。
要するに我々は、DRY原則に従い、重複を避けたい。 だから、共通コードをユーティリティクラスに入れて必要に応じて再利用する。
// これはひどい設計なので再利用しないように。 public class NumberUtils { public static int max(int a, int b) { return a &amp;gt; b ? a : b; } } 実際、これはとても便利なテクニックだ!?
ユーティリティクラスは悪だ しかし、オブジェクト指向の世界では、ユーティリティクラスはかなり悪い(酷いという人さえいるかもしれない)手法だ。
これについては多くの議論がある。 いくつか挙げると、Nick Malikの「ヘルパークラスは悪か?」、Simon Hartの「なぜヘルパー、シングルトン、ユーティリティクラスはだいたい間違っているのか」、Marshal Wardの「ユーティリティクラスを避ける」、Dhaval Dalalの「ユーティルクラスを殺せ!」、Rob Bagbyの「ヘルパークラスは問題の兆候」。
また、StackExchangeにはユーティリティクラスについての質問がいくつかある。 例えば、「ユーティリティクラスが悪なら、どこに共通コードを書けばいい?」とか、「ユーティリティクラスは悪」とか。
これらの主張は要するに、ユーティリティクラスは適切なオブジェクトではないということだ。 だから、オブジェクト指向の世界に適合しない。 ユーティリティクラスは、当時の人々が機能分割パラダイムに慣れていたために、手続き型言語から受け継がれた。
君がこの主張に同意し、ユーティリティクラスを使うのをやめたがっていると想定し、そいつをどのように適切なオブジェクトに置き換えるかを例を挙げながら教えよう。
手続き型の例 例えば、テキストファイルを読んで、行で分割し、各行をトリムして、その結果を別のファイルに保存したいとする。 これはApache CommonsのFileUtilsを使えばできる。
void transform(File in, File out) { Collection&amp;lt;String&amp;gt; src = FileUtils.</description>
    </item>
    
    <item>
      <title>Pcap4JがSoftware Quality Award 2015で入賞</title>
      <link>https://www.kaitoy.xyz/2015/12/03/software-quality-award-2015/</link>
      <pubDate>Thu, 03 Dec 2015 12:28:24 -0700</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/12/03/software-quality-award-2015/</guid>
      <description>Teamed.ioが主催の、ソフトウェアの品質とその開発プロジェクトの品質への取り組みを競うコンテスト、Software Quality Awardの第一回が2015年4月～11月にかけて開催された。 Teamed.ioのCTOであるYegorとは、彼のブログを和訳してここに載せている関係でたまにメールしているが、そのやりとりの中で誘われたので私もPcap4Jをひっさげてそれに参加した。

   (adsbygoogle = window.adsbygoogle || []).push({});  優勝すると$4,096もらえるということではあったが、150以上のプロジェクトがエントリーしていて、Gulpとか有名なものも入っていたので、どうせ全然ダメだろと思ってエントリー以来なにも対策しなかったが、なんと 8位 入賞を果たしてしまった。 まあ講評をみるとずいぶんこき下ろされてはいるが…
因みに講評は以下の感じ。
 utilパッケージがあってそこにユーティリティクラスがある。クソだ。 NULLが可変オブジェクトで使われている。例えばAbstractPcapAddress。クソだ。 スタティックメソッドとスタティック変数が多すぎる。文字通りどこにでもある。pcap4j-packetfactory-staticという名のスタティックメソッドだらけのモジュールまである。 JavaDocに一貫性がなく、未完なものもある。これとか。 ほんのちょっとのissuesとたった6つのプルリクエストしかない。コミットがissuesにリンクされてない。変更のトレーサビリティはほとんどゼロだ。 リリース手順が自動化されていない。リリースがドキュメントに書かれていない。 静的解析してなくて、そのせいか乱雑なコードがたまにある。 スコア: 3  静的解析くらいは導入しようかな…
ユーティリティクラスとかNULLとかスタティックメソッドは使うのやめるつもりはないけど。
そういえば、入賞者にはスポンサーであるJetBrainsの製品の一年ライセンスがもらえることになっていたはずだが特に連絡がないな。</description>
    </item>
    
    <item>
      <title>よいオブジェクトの七つの美徳</title>
      <link>https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/</link>
      <pubDate>Wed, 28 Oct 2015 13:38:47 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/10/28/seven-virtues-of-good-object/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、Seven Virtues of a Good Objectを紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  Martin Fowler曰く、
 ライブラリは本質的には呼び出し可能な関数の集合で、最近は普通クラス内にまとめられる。
 クラス内にまとめられた関数? 失礼を承知で言わせてもらうが、これは間違っている。 そして、これはオブジェクト指向プログラミングにおいて、クラスに対する非常に一般的な誤解だ。 クラスは関数をまとめるものではないし、オブジェクトはデータ構造体ではない。
では、なにが適切なオブジェクトなのか? どれが不適切なオブジェクトなのか? その違いは何か? これは論争を呼ぶ主題ではあるが、とても重要だ。 オブジェクトが何かを理解しなければ、オブジェクト指向ソフトウェアをどうやって書くんだ? まあ、JavaやRubyなどのおかげで、書けることは書ける。 しかし、はたして良いものができるだろうか? 不幸にも、これは厳密な科学ではなく、様々な意見がある。 ここに、良いオブジェクトの特性を私なりにリストアップする。
クラス vs オブジェクト オブジェクトについて議論を始める前に、クラスとは何かを定義しよう。 それはオブジェクトが生まれる(インスタント化される)場所だ。 クラスの主な責任は、要求に応じて新しいオブジェクトを構築し、使われなくなったオブジェクトを破壊することだ。 クラスはその子供たちがどのように見えどのように振る舞うべきかを知っている。 言い換えれば、子供たちが従うべき契約を知っている。
クラスが「オブジェクトのテンプレート」であると言われることもある。(例えばWikipediaにはそう書いてある。) この定義はクラスを受動的なポジションに置いているので正しくない。 この定義は、だれかがテンプレートを取得してそこからオブジェクトを構築するということを想定している。 これは、技術的には正しいかもしれないが、概念的には間違っている。 クラスとその子供たちだけが居るのであって、他の誰も関係すべきではない。 あるオブジェクトがクラスに他のオブジェクトを作るように頼み、そのクラスがオブジェクトを構築する。それだけだ。 RubyはJavaやC++に比べてこの概念をかなりうまく表現している。
photo = File.new(&amp;#39;/tmp/photo.png&amp;#39;) photoオブジェクトはFileクラスによって構築される。(newはそのクラスへのエントリポイント。) オブジェクトは、いったん構築されると、自身に基づいて行動する。 オブジェクトは、自身を誰が構築したかとか、何人兄弟姉妹がいるかとかを知っているべきではない。 そう、リフレクションは酷いアイデアだと言っている。 それについては他の記事で詳しく書くとして、ここでは、オブジェクトについてと、その最高と最悪の両面について話そう。
1. 彼は実世界に存在している まず第一に、オブジェクトは生きた有機体だ。 もっと言えば、オブジェクトは擬人化されるべきだ。 つまり、人間(もしくは、君がより好むならペット)のように扱われるべきだ。 基本的にこれは、オブジェクトはデータ構造体や関数の集合ではないということを意味している。 代わりに、オブジェクトは独立したエンティティで、それ自身のライフサイクル、振る舞い、性質を持つ。
従業員、部署、HTTPリクエスト、MySQLのテーブル、ファイルの行、ファイルそのもの、これらは適切なオブジェクトだ。 なぜならこれらは、ソフトウェアを停止した時でも実世界に存在しているから。 より正確には、オブジェクトは実世界のモノの表現のひとつだ。 オブジェクトは実世界のモノと他のオブジェクトとの間のプロキシだ。 そのようなモノが存在しなければ、明らかにオブジェクトは存在しない。</description>
    </item>
    
    <item>
      <title>ORMは不快なアンチパターン</title>
      <link>https://www.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/</link>
      <pubDate>Sun, 13 Sep 2015 13:52:30 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/09/13/orm-is-offensive-anti-pattern/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、ORM Is an Offensive Anti-Patternを紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  結論から言えば、ORMはオブジェクト指向プログラミングの原則の全てに違反するひどいアンチパターンだ。オブジェクトをバラバラに引き裂き、もの言わぬ受身なデータ入れに変えてしまう。 小さいWebアプリケーションから、数千のテーブルをCRUD操作するエンタープライズシステムまで、どんなアプリケーションにもORMが存在することはゆるせない。 代わりになるものは? SQLを話すオブジェクトだ。
ORMの仕組み オブジェクト関係マッピング (Object-relatinal mapping、ORM)は、オブジェクト指向言語(例えばJava)からリレーショナルデータベースにアクセスする技術(またはデザインパターン)だ。 ほとんどの言語で複数のORM実装がある。 例えば、JavaのHibernate、Ruby on RalsのActiveRecord、PHPのDoctrine、PythonのSQLAlchemy。 Javaでは、ORMデザインはJPAとして標準化されてさえいる。
最初に、ORMがどう動くかを見てみよう。JavaとPostgreSQLとHibernateを使い、データベースにpost (訳注: ブログポスト、ブログの記事)という単一のテーブルがあるとする。
+-----+------------+--------------------------+ | id | date | title | +-----+------------+--------------------------+ | 9 | 10/24/2014 | How to cook a sandwich | | 13 | 11/03/2014 | My favorite movies | | 27 | 11/17/2014 | How much I love my job | +-----+------------+--------------------------+ で、このテーブルをJavaアプリケーションからCRUD操作したい。(CRUDはcreate、read、update、deleteの略。) まず、Postクラスを書く。(長くてごめん。けどなるべく短くしたんだ。)</description>
    </item>
    
    <item>
      <title>スタンドアップミーティングはダメマネージャーが好む手法</title>
      <link>https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</link>
      <pubDate>Tue, 11 Aug 2015 22:35:09 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/08/11/daily-stand-up-meetings-are-a-good-tool-for-a-bad-manager/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、Daily Stand-Up Meetings Are a Good Tool for a Bad Managerを紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  スタンドアップミーティング (または単純にスタンドアップ)は、「チームマネージャに状況報告をするためのデイリーチームミーティング」であるとWikipediaに書かれている。 こうしたミーティングは、ソフトウェア開発チームの間でとても人気な手法ではあるが、単なる悪であり、よいマネージャは決してやらない。 以下、その理由を説明する。
私は、スタンドアップのやり方が適切だったり不適切だったりする、と言いたいわけではない。それについて述べた記事は大量にある。 また、スタンドアップを上手く機能するように実施する方法についてアドバイスしようとしているわけでもない。 よいマネージャはデイリースタンドアップを決して実施すべきでないと言っているのだ。 スタンドアップは、単に「機能しない」だけでなく、非常に悪い、時に破壊的なものをマネジメントプロセスにもたらす。それがアジャイルかどうかにかかわらず。 一方、ダメなマネージャは常に、デイリースタンドアップを重要なマネジメント手法として使う。
私の意図を説明するため、マネジメントをいくつかの異なった視点から見ながら、よいマネージャとダメなマネージャが仕事をどのように進めるかを比べてみよう。
情報 ダメなマネージャは進捗を尋ねる。
オフィスを歩き回り進捗を訪ねて回るのは、ひどいマネージャの崇高な習慣だ。 彼は、プロセスと情報伝達フローを適切に構築できるほど賢明ではなく、チームが何をしているかを知らない。 しかし、彼は進捗を知る必要がある。彼もまた上司からちょくちょく尋ねられるからだ。 必要な情報を収集する唯一の方法は、チームに「今何の作業をしているの?」と尋ねることだ。 朝のスタンドアップは、メンバの作業内容を知らないことに気付かれずに、このうっとうしい質問を正式に尋ねる最高の場だ。
よいマネージャは必要なときに報告を受ける。
プロジェクトマネージメントにはコミュニケーション管理が必要だ。 情報伝達フローが適切に構成されていれば、チームメンバはいつどのようにマネージャに報告すればいいかが分かる。 何か問題が起きたとき、そういう状況をどのように報告しなければいけないかを全員が知っている。即時、直接報告するのだ。 作業が完了したとき、必要に応じてプロジェクトマネージャにどのように知らせるかを全員が理解している。 完璧なプロジェクトマネージャは決してチームに質問しない。代わりに、チームが必要なときにマネージャに報告する。 そして、報告を怠るメンバが出たときには、その壊れたコミュニケーションチャネルを修復するのがよいプロジェクトマネージャだ。 ただし、情報収集のためにデイリーミーティングは決して実施しない。
よいマネージャとして、何がゴールで何がプロジェクトマネージャ(またはスクラムマスタ)として重要かをチームに伝えるべきだ。 チームメンバは、マネージャがチームの進捗、リスク、障害、失敗について知るために何が重要であるかを知っているべきだし、チームメンバがマネージャの期待に沿えなければどんなトラブルに陥るかを理解しているべきだ。 プロジェクトやチームが取り組んでいる最も重要な課題についてをチームに伝えることは、よいマネージャとしてすべき仕事だ。 また、よいチームメンバとしては、重要な情報をつかんだら、すぐにマネージャに知らせることが重要だ。 これが完璧なマネージメントというものだ。
もしそのようなチームワークを築いたなら、開発者が今日何をしてどんな問題にあったかを、明日の朝まで待ってから尋ねる必要はなくなる。 マネージャはこういった情報をもっと早く、まさに必要なタイミングで知るようになる。 オフィスの外にいるときでさえ、プロジェクトで起こっていることを知ることができるようになる。 実際には、オフィスは全く不要にさえなるが、これはまた別の機会に議論したい。
デイリースタンドアップはプログラマ間で情報交換する最高の機会で、スクラムマスタに報告してフィードバックを受けるだけの場ではないと言う人がいるかもしれない。 もう一度、同じことを言うが、なぜ、その日の必要になった時点で情報交換をしないのか? なぜ、10人のメンバを毎朝集めて、その内たった5人だけに関係することを議論する必要がある? 答えよう。ダメなマネージャは、チームメンバ間で情報交換する場を用意する他の方法を知らず、朝のスタンドアップを適切なコミュニケーションモデルの代わりとして使う。 こういったミーティングは、マネージャが熱心に働いていて、大げさな給料を受け取るに値するかのような印象を与える。 対照的に、よいマネージャは定期的な状況報告ミーティングをいっさい実施しない。 なぜなら、効果的なコミュニケーションツールの使い方を知っているからだ。 例えば、問題追跡ツール、メール、コードレビュー、意思決定ミーティング、ペアプログラミングなど。
責任 ダメなマネージャはマイクロマネージメントをする。
ダメなマネージャはプロジェクトマネージメントのことをほとんど知らないので、大きな不安を抱えている。 彼はチームのコントロールを失うことを恐れていて、チームを信頼せず、いつも十分な情報を得ていないと感じ、上司から状況を尋ねられたときに動揺する。 このため、彼はチームメンバを抗うつ薬として使う。チームメンバが彼の言う通りのことをしているとき、彼はより安心と安定を感じる。 デイリースタンドアップミーティングは、彼がメンバに何をしているかを尋ね、代わりに何をすべきかを指示するためのすばらしい機会だ。 このマネージャは、メンバに個人の目標と計画を報告するよう強制し、必要だと感じればそれらを修正する。 次のようなやりとりをを何回聞いたことがある?</description>
    </item>
    
    <item>
      <title>なぜNullはダメか</title>
      <link>https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/</link>
      <pubDate>Sun, 26 Jul 2015 19:07:20 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/07/26/why-null-is-bad/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、Why NULL is Bad?を紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  JavaでNULLを使う単純な例を以下に示す。
public Employee getByName(String name) { int id = database.find(name); if (id == 0) { return null; } return new Employee(id); } このメソッドの何が間違っているのか? オブジェクトの代わりにNULLを返す可能性がある、というのが間違っているところだ。 NULLはオブジェクト指向パラダイムにおけるひどい慣習で、全力で避けるべきものだ。 これについては多くの意見が既に発表されている。 たとえば、Tony HoareによるプレゼンNull References, The Billion Dollar Mistakeや、David Westの著書Object Thinkingの全体に渡って述べられている。
ここで、その論拠のすべてをまとめ、NULLの使用を回避して適切なオブジェクト指向構造に置き換える方法の例を紹介したいと思う。
基本的に、NULLの代わりになり得るものはふたつある。
ひとつはNullオブジェクトデザインパターンだ。(それをひとつの不変オブジェクトにするのが最善。)
public Employee getByName(String name) { int id = database.find(name); if (id == 0) { return Employee.</description>
    </item>
    
    <item>
      <title>Getter/Setterは悪だ。以上。</title>
      <link>https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/</link>
      <pubDate>Wed, 22 Jul 2015 00:21:15 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/07/22/getters-setters-evil/</guid>
      <description>このエントリでは、Yegor Bugayenkoによる記事、Getters/Setters. Evil. Period.を紹介する。 (Yegorから和訳と転載の許可は得た。) 以下はその全文の和訳だが、意訳超訳が混じっているので、もとのニュアンスを知りたければ元記事を読んでもいいし、読まなくてもいい。

   (adsbygoogle = window.adsbygoogle || []).push({});  2003年にAllen Holubが書いたWhy getter and setter methods are evilという有名な記事に端を発する古い議論がある。それは、getter/setterはアンチパターンで避けるべきものなのか、 もしくはオブジェクト指向プログラミングに必須なものなのかというもの。 この議論に少しだけ私の意見を加えたいと思う。
上記記事の要旨はこうだ。 getterやsetterはひどい慣習で、これらを使うやつらはゆるせん。誤解の無いようもう一度言うが、 私はget/setを可能な限り避けるべきだと言っているのではない。それらは君のコードに決して現れてはいけないのだ。
横柄で目につく物言いだろう? 君は15年来get/setパターンを使い続けている尊敬を集めるJavaアーキテクトなんだろう? どこぞの馬の骨にこんなデタラメを言われたくはないだろう? ああ、その気持ちはわかる。私がDavid WestのObject Thinkingという本に出会ったとき、 私もほとんど同じことを感じた。 Object Thinkingは、私が今まで読んだオブジェクト指向プログラミングについての本の中で最高のものだ。 だからお願いだ。ひとまず落ち着いて。私に説明させてほしい。
既存の論拠 オブジェクト指向の世界で、アクセッサ(getterやsetterの別名)に反対する論拠はいくつかあるが、 私にはそれら全てが十分に有力であるとは思えない。ひとつひとつ簡単に見ていこう。

 頼め、尋ねるな
Allen Holub曰く、「ある処理をする際、その処理のために君が欲しい情報をオブジェクトに尋ねてはいけない。 その情報を持ったオブジェクトにその処理をするよう頼みなさい。」
  
 カプセル化原則違反
setterを通してどんな新たなデータも入力できるので、 一つのオブジェクトをその他の様々なオブジェクトが様々に扱うことができてしまう。 また、だれでもオブジェクトを変更できるので、 オブジェクトが単純に自身の状態を安全にカプセル化できない。
  
 実装の詳細の暴露
あるオブジェクトから他のオブジェクトを取得できる場合、前者のオブジェクトの実装の詳細に過度に依存してしまう。 もし明日その実装、例えば返すオブジェクトの型が変わったら、周辺のコードも書き換えないといけない。
  
これらの全ての論拠は正当だが、重要なポイントが抜けている。
根本的な誤解 ほとんどのプログラマはオブジェクトはメソッドを持ったデータ構造だと考えている。 ここでBozhidar Bozhanovによる記事、Getters and Setters Are Not Evilから引用する。</description>
    </item>
    
    <item>
      <title>First Post</title>
      <link>https://www.kaitoy.xyz/2015/07/18/first-post/</link>
      <pubDate>Sat, 18 Jul 2015 13:10:37 -0600</pubDate>
      
      <guid>https://www.kaitoy.xyz/2015/07/18/first-post/</guid>
      <description>初投稿。

   (adsbygoogle = window.adsbygoogle || []).push({});  ブログを立ち上げようと思ったきっかけは、Teamed.ioというCaliforniaのソフトウェアアウトソーシング(?)をやってる会社のCTO、 Yegor Bugayenko (yegor256)のブログのエントリ、How Much Do You Cost?。
これは、Teamed.ioがエンジニアに払うfeeを決める際の指標についてのエントリで、その指標の一つとして Talks and Publications を挙げている。
 Both blog articles and conference presentations make you much more valuable as a specialist. Mostly because these things demonstrate that some people already reviewed your work and your talent. And it was not just a single employer, but a group of other programmers and engineers. This means that we also can rely on your opinions.</description>
    </item>
    
  </channel>
</rss>