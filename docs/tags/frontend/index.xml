<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>https://www.kaitoy.xyz/tags/frontend/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2018</rights>
    <updated>2018-08-16 23:44:39 &#43;0900 JST</updated>

    
      
        <item>
          <title>Webアプリケーションフロントエンド年代記 - 2018年夏編</title>
          <link>https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/</link>
          <pubDate>Thu, 16 Aug 2018 23:44:39 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/</guid>
          <description>

&lt;p&gt;Webアプリケーションの、主にフロントエンド周りに関連する歴史をまとめた。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;静的サイト&#34;&gt;静的サイト&lt;/h1&gt;

&lt;p&gt;まずは原初の話から。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1990年代前半&lt;/strong&gt;、まだWebアプリケーションという言葉が無かった時代。
静的にHTMLファイルを配信するだけのWebサイト(静的サイト)だけがあった。
静的サイトでは、HTTPサーバーに複数のHTMLファイルを置いておいて、クライアントのHTTPリクエストのURLのパスによって配信するHTMLファイルを変える。&lt;/p&gt;

&lt;p&gt;例えば、HTTPサーバーを&lt;a href=&#34;https://httpd.apache.org/&#34;&gt;httpd&lt;/a&gt;で立てて、ドキュメントルートを&lt;code&gt;/var/www/html&lt;/code&gt;に設定して、以下のようにファイルを配置したとする。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/var/www/html/
    |
    +-- index.html
    |
    +-- sub/
          |
          +-- hoge.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この場合、ブラウザで&lt;code&gt;http://&amp;lt;HTTPサーバアドレス&amp;gt;/index.html&lt;/code&gt;にアクセスすれば&lt;code&gt;/var/www/html/index.html&lt;/code&gt;が配信されてレンダリングされて表示される。
&lt;code&gt;http://&amp;lt;HTTPサーバアドレス&amp;gt;/sub/hoge.html&lt;/code&gt;にアクセスすれば&lt;code&gt;/var/www/html/sub/hoge.html&lt;/code&gt;が配信される。&lt;/p&gt;

&lt;p&gt;古のWebサイトは、こんな感じにコンテンツごとにHTMLファイルを書いてサーバに置いておいて、その間にリンクを張って辿れるようにすることで構成されていた。&lt;/p&gt;

&lt;p&gt;まあ今も大体そんな感じだけど。&lt;/p&gt;

&lt;h1 id=&#34;dhtml&#34;&gt;DHTML&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1990年代後半&lt;/strong&gt;、クライアントサイドのJavaScriptでHTMLドキュメントをいじって、多少の動的感・インタラクティブ感をだす技術は既に一応あって、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%83%8A%E3%83%9F%E3%83%83%E3%82%AFHTML&#34;&gt;DHTML&lt;/a&gt;と呼ばれていた。&lt;/p&gt;

&lt;p&gt;DHTMLの肝はJavaScriptの&lt;a href=&#34;https://ja.wikipedia.org/wiki/Document_Object_Model&#34;&gt;DOM&lt;/a&gt; APIだ。
このAPIでは、HTML文書が各要素(タグなど)をノードとするツリー構造(DOMツリー)で表され、任意の要素を検索して取得したり、属性などを書き換えたり、要素の追加・削除ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;hogehoge&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
      // idがhogehogeの要素の子要素として「&amp;lt;p&amp;gt;HOGEEEEEEE&amp;lt;/p&amp;gt;」を追加。
      document.getElementById(&amp;quot;hogehoge&amp;quot;).innerHTML = &amp;quot;&amp;lt;p&amp;gt;HOGEEEEEEE&amp;lt;/p&amp;gt;&amp;quot;
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、このころのJavaScriptは、仕様・機能が貧弱だった上、ブラウザ間で挙動に差があったり、標準メソッドがブラウザ固有のメソッドで代替されていたりして開発体験が最悪だったためか、今日のようにWeb UIの中心的役割を果たすことはなく、補助的・装飾的機能の実装に使われることが多かったように思う。&lt;/p&gt;

&lt;p&gt;アクセスした日付を表示したり、背景に雪を降らせたり、マウスカーソルを目玉に追いかけさせたり。&lt;/p&gt;

&lt;h1 id=&#34;動的html生成-プログラムでhtmlを書き出す&#34;&gt;動的HTML生成 (プログラムでHTMLを書き出す)&lt;/h1&gt;

&lt;p&gt;静的サイトだと表現できることが非常に限られるので、クライアントからのリクエストの内容をサーバが解釈し、DBの情報やなんかをもとにサーバ側でHTMLドキュメントを動的に生成し、クライアントに返す、ということをするようになった。&lt;/p&gt;

&lt;p&gt;原始的には、プログラム中で一連のHTMLドキュメントを出力する方法がとられた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void doGet(
  HttpServletRequest request, HttpServletResponse response
) throws IOException, ServletException {

  response.setContentType(&amp;quot;text/html;&amp;quot;);
  PrintWriter out = response.getWriter();

  out.println(&amp;quot;&amp;lt;html&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;head&amp;gt;&amp;quot;);
  out.println(&amp;quot;    &amp;lt;title&amp;gt;Hoge&amp;lt;/title&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;/head&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;body&amp;gt;&amp;quot;);
  out.println(new java.util.Date());
  out.println(&amp;quot;  &amp;lt;/body&amp;gt;&amp;quot;);
  out.println(&amp;quot;&amp;lt;/html&amp;gt;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使われた技術は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Common_Gateway_Interface&#34;&gt;CGI&lt;/a&gt; (Perl)とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java_Servlet&#34;&gt;Java Servlet&lt;/a&gt;とか。
&lt;a href=&#34;http://jakarta.apache.org/ecs/index.html&#34;&gt;Jakarta ECS&lt;/a&gt;なんてのもあった。&lt;/p&gt;

&lt;h1 id=&#34;動的html生成-htmlにプログラムを埋め込む&#34;&gt;動的HTML生成 (HTMLにプログラムを埋め込む)&lt;/h1&gt;

&lt;p&gt;プログラムでHTMLを書き出すことにより、かなり動的な感じにはなったが、書き出す処理を書くのがめんどくさすぎるし、読みにくい。
そのため、HTMLを主体にして、そのなかの動的な部分だけにプログラムを埋め込む方式が生まれた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html %&amp;gt;

&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hoge&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%
    out.println(new java.util.Date());
    %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTMLドキュメントのひな型を作っておいて、その中にプログラムの処理結果を埋め込んでクライアントに返すため、テンプレートエンジンとか、テンプレートシステムとか呼ばれる。&lt;/p&gt;

&lt;p&gt;該当する技術は、&lt;a href=&#34;http://www.php.net/&#34;&gt;PHP&lt;/a&gt;とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/JavaServer_Pages&#34;&gt;JSP&lt;/a&gt;とか、&lt;a href=&#34;http://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/ERuby&#34;&gt;eRuby&lt;/a&gt;とか。&lt;/p&gt;

&lt;h1 id=&#34;mvcアーキテクチャ&#34;&gt;MVCアーキテクチャ&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2000年初頭&lt;/strong&gt;、&lt;a href=&#34;http://struts.apache.org/&#34;&gt;Struts&lt;/a&gt; (Struts1)というJavaのWebアプリケーションフレームワークが流行り、Controller (Java Servlet)がクライアントからリクエストを受け取り、Model (JavaBeans)がそれを処理して、View (JSP)がHTMLをレンダリングしてクライアントに返す、という、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_Controller&#34;&gt;MVCアーキテクチャ&lt;/a&gt;が流行った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/500px-MVC-Process.svg.png&#34; alt=&#34;MVC&#34; title=&#34;MVC&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Strutsに続いて&lt;a href=&#34;https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html&#34;&gt;Spring MVC&lt;/a&gt;、&lt;a href=&#34;https://rubyonrails.org/&#34;&gt;Ruby on Rails&lt;/a&gt;、&lt;a href=&#34;https://cakephp.org/jp&#34;&gt;CakePHP&lt;/a&gt;といったフレームワークが出てきて、MVCアーキテクチャによる開発効率や開発体験は洗練されていった。&lt;/p&gt;

&lt;h1 id=&#34;ajax&#34;&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Strutsが全盛期の&lt;strong&gt;2005年&lt;/strong&gt;ころ、JavaScriptで非同期にサーバからデータを取得し、それをもとにクライアントサイドでHTMLを動的に編集するような技術に、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Ajax&#34;&gt;Ajax&lt;/a&gt;という名前が付いた。&lt;/p&gt;

&lt;p&gt;Ajaxは「Asynchronous JavaScript + XML」の略で、&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest&#34;&gt;XMLHttpRequest&lt;/a&gt; (略してXHR)というJavaScriptのAPIで
、サーバにHTTPリクエストを送り、そのレスポンスを非同期に処理する技術。
レスポンスは、当時XMLが流行っていたので、その形式で送ることが想定されていたが、実際にはどんな形式でもいい。はず。
最近はJSONで送られることがほとんど。&lt;/p&gt;

&lt;p&gt;JavaScriptはシングルスレッドで動くわけだけど、XMLHttpRequestはレスポンスを非同期に処理するため、リクエスト送信からレスポンス受信までの間、クライアントがスタックせずに済む。
また、通常のHTTPリクエストは、完全なHTMLドキュメントを受信して画面全体をレンダリングしなおす(i.e. 画面遷移する)のに対して、Ajaxは受信したデータをもとに画面の一部だけを更新するので、ネイティブアプリケーションに近めなユーザエクスペリエンスを実現できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var xhr = new XMLHttpRequest();
xhr.open(&#39;GET&#39;, &#39;https://httpbin.org/get&#39;, true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 &amp;amp;&amp;amp; xhr.status === 200) {
    console.log(xhr.responseText);
    // DOMをいじる処理
    // …
  }
};
xhr.send(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ajaxは、GoogleがGoogle Mapsで活用して一気に注目を集めた。
地図データをサーバから非同期に先読みするなどして、マウスのドラッグによって地図を滑らかにスクロールして見せるそのUIは当時画期的で、それまでの、画面遷移中心のUIからの飛躍を感じさせた。&lt;/p&gt;

&lt;h1 id=&#34;prototypeとjquery&#34;&gt;PrototypeとjQuery&lt;/h1&gt;

&lt;p&gt;Ajaxの普及を後押ししたのが、&lt;a href=&#34;http://prototypejs.org/&#34;&gt;Prototype&lt;/a&gt;と&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;というJavaScriptライブラリの登場だった。&lt;/p&gt;

&lt;p&gt;PrototypeはRubyにインスパイアされて開発され、Ruby on Railsに採用されたことで&lt;strong&gt;2005年&lt;/strong&gt;ころから普及したライブラリで、JavaScriptの標準グローバルオブジェクトであるArrayとかElementに便利メソッドを生やしたり、独自のグローバルユーティリティオブジェクトを追加したりして、Ajax処理をしやすくしたり、JavaScriptの機能を拡張してくれたりする。&lt;/p&gt;

&lt;p&gt;特に、当時のプロトタイプベースで使いにくかったJavaScriptのオブジェクト指向を扱いやすくしてくれる&lt;a href=&#34;http://prototypejs.org/learn/class-inheritance&#34;&gt;Class&lt;/a&gt;や、配列の処理に便利なeachとかmapとかincludeとかのメソッドを追加する&lt;a href=&#34;http://api.prototypejs.org/language/Enumerable/&#34;&gt;Enumerable&lt;/a&gt;なんかが熱かったように思う。&lt;/p&gt;

&lt;p&gt;一方jQueryは、ファーストバージョンが&lt;strong&gt;2006年8月&lt;/strong&gt;にリリースされ、ブラウザ間の非互換性をほとんど気にすることなく、簡潔なコードでDOM操作やAjax通信ができるAPIを提供した。
Prototypeと比べて、標準オブジェクトやグローバル名前空間を汚さない点がよかったのか、&lt;strong&gt;2007年&lt;/strong&gt; ころにはPrototypeを抜いて猛烈に普及した。&lt;/p&gt;

&lt;p&gt;この頃からWebアプリケーションは、UIはクライアントサイドのJavaScriptでインタラクティブな感じに書いて、サーバサイドはXMLHttpRequestに対してJSONデータを返すAPIサーバとして働く、という感じのものが増えていったように思う。
またこの頃から、クライアントサイドの開発が量質ともに上がったために独立した仕事になり、サーバサイドと対比して、前者をフロントエンド、後者をバックエンドと呼ぶようになってきた。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;因みに、PrototypeやjQueryと同様というかもう少し高機能な&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo Toolkit&lt;/a&gt;というライブラリが&lt;strong&gt;2004年&lt;/strong&gt;ころからあったんだけど、あまり流行らなかった。
カスタムビルドという、モジュールを結合してminifyする&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;みたいな機能を、&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js&lt;/a&gt;もない時代に実現していた先進的なライブラリだったんだけど、時代がついてこれなかったのかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;ria-flashとか&#34;&gt;RIA (Flashとか)&lt;/h1&gt;

&lt;p&gt;WebアプリケーションにはAjaxと別の世界線もあった。&lt;/p&gt;

&lt;p&gt;そこでは&lt;strong&gt;1997年&lt;/strong&gt;ころに&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%83%E3%83%81%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;RIA (Rich Internet Application)&lt;/a&gt;という言葉が生まれた。
これは、クライアントサイドの技術を駆使した、表現力やユーザビリティが高いWebアプリケーションのこと。&lt;/p&gt;

&lt;p&gt;(実際にはAjaxなアプリもこのくくりに入るが、ここでは非Web標準なクライアントサイド技術を使ったものの話を書く。)&lt;/p&gt;

&lt;p&gt;RIA技術の代表格である&lt;a href=&#34;https://ja.wikipedia.org/wiki/Adobe_Flash&#34;&gt;Flash&lt;/a&gt;は&lt;strong&gt;1996年&lt;/strong&gt;に生まれた。
このころはShockwave FlashとかMacromedia Flashとか呼ばれたが、開発元が&lt;strong&gt;2005年&lt;/strong&gt;にAdobeに買収されてAdobe Flashになり、そのあたりから&lt;strong&gt;2010年代前半&lt;/strong&gt;辺りまで最先端のWeb UI技術として甚だしく流行った。&lt;/p&gt;

&lt;p&gt;Flashは、&lt;a href=&#34;https://www.adobe.com/jp/products/flex.html&#34;&gt;Flex&lt;/a&gt;というフレームワーク(ツール?)のもと、&lt;a href=&#34;https://ja.wikipedia.org/wiki/ActionScript&#34;&gt;ActionScript&lt;/a&gt;というJavaScriptっぽいプログラミング言語と、&lt;a href=&#34;https://ja.wikipedia.org/wiki/MXML&#34;&gt;MXML&lt;/a&gt;というXMLなUI記述言語を駆使してWeb UIを開発できる技術。
WebブラウザにAdobe Flash PlayerとかAdobe AIRのプラグインを入れると表示できる。&lt;/p&gt;

&lt;p&gt;Flashの人気に触発されたのか、Microsoftが&lt;strong&gt;2007年&lt;/strong&gt;に&lt;a href=&#34;https://www.microsoft.com/silverlight/&#34;&gt;Silverlight&lt;/a&gt;というのをリリースした。
これは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/.NET_Framework&#34;&gt;.NET Framework&lt;/a&gt;な言語(&lt;a href=&#34;https://docs.microsoft.com/ja-jp/dotnet/csharp/&#34;&gt;C#&lt;/a&gt;とか&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/cc427807.aspx&#34;&gt;JScript&lt;/a&gt;とか)と、&lt;a href=&#34;https://docs.microsoft.com/ja-jp/dotnet/framework/wpf/advanced/xaml-overview-wpf&#34;&gt;XAML&lt;/a&gt;というHTMLっぽいUI記述言語を駆使してWeb UIを開発できる技術。
WebブラウザにMicrosoft Silverlightプラグインを入れると表示できる。&lt;/p&gt;

&lt;p&gt;また、Flashの誕生とほぼ同時期に、JavaでWebアプリケーションのUIを書く&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java%E3%82%A2%E3%83%97%E3%83%AC%E3%83%83%E3%83%88&#34;&gt;Java Applet&lt;/a&gt;というのも生まれていた。が、初期のバージョンでロードに時間がかかったり動作が重かったりする問題があり、嫌厭されてFlashほど流行らなかった。
WebブラウザにJavaプラグインを入れると表示できる。
なぜか最近になって、&lt;strong&gt;2017年&lt;/strong&gt; 公開のマイナンバーのポータルサイトで採用されて話題になった。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;こうした非Web標準技術を使ったRIAは、Ajaxに比べてリッチな表現ができたり、ブラウザ間の非互換性に悩まされないところに優位性があったが、以下のような問題があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;プロプライエタリな技術をベースにしていて、実装がブラックボックスだったり、仕様の方向性がベンダの都合に左右されたり、ベンダロックインされやすかったりする。&lt;/li&gt;
&lt;li&gt;ユーザがブラウザにプラグインをいれてないと表示されない。&lt;/li&gt;
&lt;li&gt;セキュリティ問題が見つかった場合、オープンな技術のものに比べて対策が遅い傾向があるし、ベンダによる実装しかないので替えが利かない。&lt;/li&gt;
&lt;li&gt;他ベンダの技術や標準技術との親和性が無かったり、連携が弱かったりする。&lt;/li&gt;
&lt;li&gt;ブラウザ内で文字列検索ができなかったり、検索エンジンにまともにクローリングしてもらえない。&lt;/li&gt;
&lt;li&gt;動作が重い。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;このような問題のためか、Web標準周辺技術の発展に伴い、一時期は隆盛を誇ったFlashなども次第に廃れていった。&lt;/p&gt;

&lt;p&gt;Flashは&lt;strong&gt;2020年&lt;/strong&gt;に、Silverlightは&lt;strong&gt;2021年&lt;/strong&gt;にサポート終了になり、Java Appletは&lt;strong&gt;2018年9月&lt;/strong&gt;に出るJava 11で廃止されることが決まっている。&lt;/p&gt;

&lt;h1 id=&#34;html-5とcss-3とecmascript-5&#34;&gt;HTML 5とCSS 3とECMAScript 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2000年代中盤&lt;/strong&gt; から非Web標準なRIAが流行ったのは、そもそもWeb標準技術であるHTML、CSS、JavaScript(というかその標準仕様を定める&lt;a href=&#34;https://ja.wikipedia.org/wiki/ECMAScript&#34;&gt;ECMAScript&lt;/a&gt;)が、アプリケーションのUIを作るという目的で設計されているわけではなく、それらを使ってWeb UIを作ることに限界があったのが一因だったと思う。&lt;/p&gt;

&lt;p&gt;RIAの流行を受け、Web標準業界に危機感が募ったのか、&lt;strong&gt;2000年代後半&lt;/strong&gt; くらいからWeb標準技術にWeb UIを意識したバージョンアップの動きが始まった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/html/html5_intro.asp&#34;&gt;HTML 5&lt;/a&gt;の勧告 (&lt;strong&gt;2014年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるHTML 4.01の勧告が&lt;strong&gt;1999年&lt;/strong&gt;だったので、&lt;strong&gt;15年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;文書構造を表すタグの追加: &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;とか&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;図を表現するためのタグの追加: &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;inputタイプの追加: &lt;code&gt;date&lt;/code&gt;、&lt;code&gt;range&lt;/code&gt;、&lt;code&gt;email&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;inputタグの属性の追加: &lt;code&gt;autocomplete&lt;/code&gt;、&lt;code&gt;pattern&lt;/code&gt;、&lt;code&gt;placeholder&lt;/code&gt;、&lt;code&gt;required&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;マルチメディアのためのタグの追加:&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Webアプリケーション向けAPI追加: Drag and Drop、Local Storage、Web Workerとか。&lt;/li&gt;
&lt;li&gt;冗長だったり見た目に関するタグ・属性の削除: &lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;とか&lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt;とか&lt;code&gt;border&lt;/code&gt;とか&lt;code&gt;color&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data-*&lt;/code&gt;属性のサポート。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/CSS3&#34;&gt;CSS 3&lt;/a&gt;の勧告 (&lt;strong&gt;2011年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるCSS 2の勧告が&lt;strong&gt;1998年&lt;/strong&gt;だったので、&lt;strong&gt;13年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;角丸、シャドウ、グラデーションのサポート。&lt;/li&gt;
&lt;li&gt;セレクタの機能追加: 属性値の部分マッチ、nth-childなど。&lt;/li&gt;
&lt;li&gt;メディアクエリ。&lt;/li&gt;
&lt;li&gt;Flexboxレイアウト、Gridレイアウト。&lt;/li&gt;
&lt;li&gt;Webフォント。&lt;/li&gt;
&lt;li&gt;トランジション、トランスフォーム、アニメーション。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/js/js_es5.asp&#34;&gt;ECMAScript 5&lt;/a&gt;の発行 (&lt;strong&gt;2009年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるECMAScript 3の勧告が&lt;strong&gt;1999年&lt;/strong&gt;だったので、&lt;strong&gt;10年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;strictモード。&lt;/li&gt;
&lt;li&gt;Arrayのメソッド追加: forEach、map、filterなど。&lt;/li&gt;
&lt;li&gt;Objectのメソッド追加: keys、freezeなど。&lt;/li&gt;
&lt;li&gt;グローバルオブジェクトにJSONが追加。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第1世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第1世代)&lt;/h1&gt;

&lt;p&gt;Web標準技術が進化して表現力が上がり、ECMAScript 5やjQueryによってロジックを書きやすくなり、人々がWeb UIをバリバリ書けるようになり、RIAの影響もあってUIの複雑化が進んだ。&lt;/p&gt;

&lt;p&gt;UIが複雑化すると、ユーザ入力の処理、Ajaxによるサーバとのデータ通信、UIの状態の取得、DOMの操作なんかを、何の秩序も構造化もレイヤー分けもなくナイーブにコーディングするのが辛くなってきた。&lt;/p&gt;

&lt;p&gt;この辛みに対処すべく誕生してきたのが数多のJavaScriptフロントエンドフレームワーク。
&lt;strong&gt;2018年現在&lt;/strong&gt; まで続くフロントエンドフレームワーク戦国時代の幕開けである。&lt;/p&gt;

&lt;p&gt;フロントエンドフレームワークは大抵以下のような機能を提供してくれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UI(View)の記述を楽にする何か。テンプレートエンジンとか。&lt;/li&gt;
&lt;li&gt;Viewに表示しているデータとJavaScriptプログラムで保持しているデータを紐づける仕組み。(i.e. &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0&#34;&gt;データバインディング&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ajaxユーティリティ。&lt;/li&gt;
&lt;li&gt;URLをViewやロジックと紐づける仕組み。(i.e. URLルーティング)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;フロントエンドフレームワーク戦国時代初期に生まれた主要なフロントエンドフレームワークを列挙する。&lt;/p&gt;

&lt;p&gt;(この記事では便宜上第1世代と呼ぶ。)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://knockoutjs.com/&#34;&gt;Knockout&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVMアーキテクチャ&lt;/a&gt;。

&lt;ul&gt;
&lt;li&gt;ModelがUIと独立してデータ(Ajaxでサーバから取ったものなど)を保持する。&lt;/li&gt;
&lt;li&gt;ViewModelがUIに紐づくデータとその操作を表現する。&lt;/li&gt;
&lt;li&gt;ViewはDOMツリー。ViewModelへの変更は自動でViewに反映されるし、その逆もしかり。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://backbonejs.org/&#34;&gt;Backbone.js&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;主にModelとViewからなるMVC的アーキテクチャ。

&lt;ul&gt;
&lt;li&gt;Modelはデータとビジネスロジックを表現する。

&lt;ul&gt;
&lt;li&gt;サーバから取ってきたデータを保持。&lt;/li&gt;
&lt;li&gt;ビジネスロジックによってデータが変わると、イベントを生成。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewがModelをDOMに反映する。

&lt;ul&gt;
&lt;li&gt;ModelからのイベントをlistenしてDOMに反映。&lt;/li&gt;
&lt;li&gt;ユーザからの入力を取得して、Modelに渡す。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.emberjs.com/&#34;&gt;Ember.js&lt;/a&gt; v1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2011年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;URLルーティングをコアとするコンセプトが特徴的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2012年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Google製。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;DIやテストなどのサポートまであるフルスタックフレームワーク。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第1世代は、フロントエンドの世界にMVCアーキテクチャ(とその派生)をもたらした。&lt;/p&gt;

&lt;p&gt;このMVCは、Struts時代のMVCとは違い、完全にクライアントサイドに閉じたアーキテクチャだ。
サーバ側はエントリーポイントとしてHTML(とCSSとJavaScript)をサーブするほかは、JSONを返すAPIサーバとしての役割に徹する。
このようなWebアプリケーションは、ページ遷移が発生せず、単一ページだけでUIが構成されるので、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%AB%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;Single Page Application (SPA)&lt;/a&gt;と呼ばれる。&lt;/p&gt;

&lt;p&gt;ModelとViewとの間でのデータの同期の仕方には以下のように2方向がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;M⇒V: Modelを更新すると対応するViewが自動で更新される。&lt;/li&gt;
&lt;li&gt;V⇒M: Viewがユーザ入力などによって変更されるとModelが自動で更新される。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者だけをするのが1-wayバインディングで、両方するのが2-wayバインディング。
上に挙げた中では、Backbone.js以外が2-wayバインディング推しで、このころは2-wayバインディングが正義だったっぽい。&lt;/p&gt;

&lt;h1 id=&#34;commonjs-node-js-パッケージマネージャ-モジュールバンドラ-altjs-altcss-トランスパイラ-タスクランナー&#34;&gt;CommonJS、Node.js、パッケージマネージャ、モジュールバンドラ、AltJS、AltCSS、トランスパイラ、タスクランナー&lt;/h1&gt;

&lt;p&gt;第1世代のフロントエンドフレームワークが出始めたころ、JavaScriptの言語周りの環境にも大きな変化があった。
正直書くの辛くなってきたので、一気に片付ける。&lt;/p&gt;

&lt;h3 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h3&gt;

&lt;p&gt;クライアントサイドでJavaScriptが盛り上がっているのを見て、もっとJavaScriptいろんなところで活用できるんじゃね?
となって、ブラウザの外でも普通のプログラミング言語としてJavaScriptを使うためには、どんな機能を追加すべきか、みたいな議論をするプロジェクトが&lt;strong&gt;2009年&lt;/strong&gt;に立ち上がった。
&lt;a href=&#34;http://www.commonjs.org/&#34;&gt;CommonJS&lt;/a&gt;である。&lt;/p&gt;

&lt;p&gt;CommonJSの最大の功績は多分、モジュールシステムを言語仕様でちゃんとサポートしよう、と言ったこと。
モジュールシステムは、Cでいうincludeとか、JavaやPythonのimportとか、そういう機能。
JavaScriptにはもともとそういうのが無くて、単にファイルを分割して個別にロードしていただけだったので、名前空間がコンフリクトしたりしなかったりしてた。&lt;/p&gt;

&lt;p&gt;因みに、JavaScriptのモジュールシステムには、CommonJSのやつ以外にも&lt;a href=&#34;https://en.wikipedia.org/wiki/Asynchronous_module_definition&#34;&gt;AMD&lt;/a&gt;というのがあったけど、そっちは盛り上がらなかった。&lt;/p&gt;

&lt;h3 id=&#34;node-js&#34;&gt;Node.js&lt;/h3&gt;

&lt;p&gt;CommonJSの流れを汲んで、サーバサイドのJavaScriptランタイムとして&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt;が&lt;strong&gt;2009年&lt;/strong&gt;にリリースされた。
これにより、ブラウザ外でJavaScriptを実行できるようになり、以降のJavaScript開発体験の劇的な改善につながった。&lt;/p&gt;

&lt;h3 id=&#34;パッケージマネージャ&#34;&gt;パッケージマネージャ&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2010年&lt;/strong&gt; には、Node.jsにパッケージマネージャとして&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;が同梱されるようになった。
これにより、モジュールを公開してシェアして再利用する文化が定着し、JavaScriptプログラムの開発効率や品質がかなり向上したはず。&lt;/p&gt;

&lt;p&gt;パッケージマネージャとしてはもうひとつ、&lt;a href=&#34;https://bower.io/&#34;&gt;Bower&lt;/a&gt;というのが&lt;strong&gt;2012年&lt;/strong&gt;に出た。
npmはサーバサイドのパッケージ、Bowerはクライアントサイドのパッケージ、みたいな住みわけが当初はあったが、最近は全部npmになってBower使ってるプロジェクトは見なくなった。&lt;/p&gt;

&lt;h3 id=&#34;モジュールバンドラ&#34;&gt;モジュールバンドラ&lt;/h3&gt;

&lt;p&gt;サーバサイドでモジュールシステムができたのはよかったけど、その仕様がブラウザでサポートされることは終ぞなかった。
ので、モジュールバンドラというものが生まれた。
これは、ソース中のモジュールインポート(requireとかimport)をたどって、モジュール分割されたソースをブラウザが読めるように一つに結合してくれるツール。&lt;/p&gt;

&lt;p&gt;モジュールバンドラのパイオニアが、&lt;strong&gt;2011年&lt;/strong&gt; にリリースされた&lt;a href=&#34;http://browserify.org/&#34;&gt;Browserify&lt;/a&gt;。
Browserifyは、モジュールの結合だけでなく、Node.js特有のAPIをある程度ブラウザでも動くようにしてくれるなど、魔法のようなツールだった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2012年&lt;/strong&gt; には&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;というモジュールバンドラが出て、後述のトランスパイラと上手く連携したり、JavaScriptだけでなくCSSもHTMLもフォントも画像ファイルもなんでもバンドルできる高機能により、Browserifyを食った。&lt;/p&gt;

&lt;p&gt;モジュールバンドルすると、ファイルサイズが大きくなって、ブラウザでロードするのに時間がかかって、初期画面の表示が遅くなる問題があった。
&lt;strong&gt;2015年&lt;/strong&gt;、その問題を軽減すべく、&lt;a href=&#34;https://rollupjs.org/guide/en&#34;&gt;Rollup&lt;/a&gt;というのが出てきた。
Rollupは、&lt;a href=&#34;https://rollupjs.org/guide/en#tree-shaking&#34;&gt;Tree-shaking&lt;/a&gt;という機能で、バンドル時に不要なコードを削除することでファイルサイズを小さくできることを売りにした。
が、webpackがバージョン2でTree-shakingをサポートしたため、使う理由がなくなった。&lt;/p&gt;

&lt;p&gt;webpackは機能的には最高にクールだったが、設定が複雑で設定ファイルが肥大化するという問題があった。
この問題を解消すべく、&lt;strong&gt;2017年末&lt;/strong&gt; に&lt;a href=&#34;https://parceljs.org/&#34;&gt;Parcel&lt;/a&gt;というモジュールバンドラがリリースされ、ゼロ設定で使えるということで人気を集めてきている。
今の時点でプロダクションレディなレベルなのかは疑問。&lt;/p&gt;

&lt;h3 id=&#34;altjs&#34;&gt;AltJS&lt;/h3&gt;

&lt;p&gt;上に書いた通り、&lt;strong&gt;2009年&lt;/strong&gt; にECMAScript 5が発行されて、JavaScriptは若干改善されたわけだけど、はっきり言ってまだまだ貧弱な言語だった。
そこに&lt;a href=&#34;https://coffeescript.org/&#34;&gt;CoffeeScript&lt;/a&gt;が登場。
&lt;strong&gt;2009年末&lt;/strong&gt; のことだった。&lt;/p&gt;

&lt;p&gt;CoffeeScriptは、RubyやPythonみたいな簡潔で機能的な構文を備えた生産性の高い言語で、JavaScriptにコンパイルできる。
クラス構文とか、アロー関数とか、配列内包表記とか、インデントによるブロック構造とかを実現してて書き心地がかなりよかったのと、Ruby on Railsに採用されたというのもあって、&lt;strong&gt;2010年代中盤&lt;/strong&gt; くらいまで結構流行った。&lt;/p&gt;

&lt;p&gt;CoffeeScriptのように、JavaScriptの代替として使い、JavaScriptに変換して実行するのを主なユースケースとする言語を、AltJS (Alternative JavaScript)と呼ぶ。
CoffeeScriptの最大の功績は、このAltJSという分野を切り開き、JavaScriptフロントエンドにコンパイルという概念を持ち込んだことだったと思う。&lt;/p&gt;

&lt;p&gt;CoffeeScript自体はその後、&lt;strong&gt;2015年&lt;/strong&gt; に発行されたECMAScript 2015がその仕様を取り込んだことで役目を終えた。
&lt;strong&gt;2017年9月&lt;/strong&gt; に&lt;a href=&#34;https://coffeescript.org/announcing-coffeescript-2/&#34;&gt;バージョン2をアナウンス&lt;/a&gt;して再起を図ったが、そのころすでに他に有力なAltJSが出てたし、ECMAScriptも結構成熟してきてたし、あまり注目されなかった。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;AltJSには他に以下のようなものがあるが、ほぼTypeScriptしか使われてなさそう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2012年10月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Microsoft製。&lt;/li&gt;
&lt;li&gt;静的型付けが最大の特徴で、他にもクラスやアロー関数やレキシカル変数などをサポート。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.purescript.org/&#34;&gt;PureScript&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年4月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;強い静的型付けの関数型言語。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dartlang.org/&#34;&gt;Dart&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2011年10月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Google製。&lt;/li&gt;
&lt;li&gt;全く流行らなかったし、Google自身も社内標準プログラミング言語にTypeScriptを採用したので、だれも使ってなくてよくわからない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2018年8月&lt;/strong&gt; にバージョン2がリリースされ、再起を図ってはいる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jsx.github.io/&#34;&gt;JSX&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;DeNA製。&lt;/li&gt;
&lt;li&gt;名前がReactの&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;と紛らわしい。&lt;/li&gt;
&lt;li&gt;誰も使ってないし、&lt;strong&gt;2014年&lt;/strong&gt; くらいから開発止まってる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;altcss&#34;&gt;AltCSS&lt;/h3&gt;

&lt;p&gt;CSSにもalternativesがある。
というかAltJSよりも歴史が古い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sass-lang.com/&#34;&gt;Sass&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2006年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;SASS記法とSCSS記法がある。&lt;/li&gt;
&lt;li&gt;AltCSSでは1番人気っぽい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lesscss.org/&#34;&gt;Less&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2009年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Sassに感銘を受けたけど、そのSASS記法がCSSと違いすぎてちょっと、と思った人がCSSに寄せて作った。けどSassもCSSに寄せたSCSS記法をサポートしたため食われた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stylus-lang.com/&#34;&gt;Stylus&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://postcss.org/&#34;&gt;PostCSS&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;正確にはAltCSSではなく、CSSを処理するツールをJavaScriptで開発できるフレームワーク。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://preset-env.cssdb.org/&#34;&gt;PostCSS Preset Env&lt;/a&gt;というプラグインとともに使うと、CSSのエッジな機能を使えるようになる。つまりどちらかといえば後述のトランスパイラに近い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;トランスパイラ&#34;&gt;トランスパイラ&lt;/h3&gt;

&lt;p&gt;CoffeeScriptの流行などを受けて、ECMAScriptに再び改善の圧力がかかったのか、&lt;strong&gt;2011年後半&lt;/strong&gt; ころから次期ECMAScriptの議論が活発化した。
&lt;strong&gt;2015年&lt;/strong&gt; に満を持してECMAScript 6改めECMAScript 2015が発行された。&lt;/p&gt;

&lt;p&gt;ECMAScript 2015は、クラス構文、アロー関数、レキシカル変数、定数、関数のデフォルト引数、ジェネレータ、テンプレート文字列、モジュールシステムなどをサポートし、一気にまともなプログラミング言語になった。&lt;/p&gt;

&lt;p&gt;しかし、それらの新しい機能をアプリケーションに使うには、各社のブラウザのJavaScriptエンジンが実装して、さらにその実装したバージョンのブラウザがユーザに十分に行きわたるのを待たないといけない。
ECMAScriptの新機能は、正式に発行される前から仕様が公開され、ブラウザが先行して実装してはいくものの、&lt;a href=&#34;http://threevirtues.com/&#34;&gt;プログラマは短気&lt;/a&gt;なのでそんなの待ってられない。&lt;/p&gt;

&lt;p&gt;といった状況のなか、&lt;strong&gt;2014年10月&lt;/strong&gt; に&lt;a href=&#34;https://www.npmjs.com/package/6to5&#34;&gt;6to5&lt;/a&gt;というツールがnpmで公開された。
ECMAScript 6で書かれたコードをECMAScript 5なコードに変換してくれる、トランスパイラというツールだった。&lt;/p&gt;

&lt;p&gt;(実はトランスパイラとしては&lt;strong&gt;2013年3月&lt;/strong&gt;に公開されたGoogle製の&lt;a href=&#34;https://github.com/google/traceur-compiler&#34;&gt;Traceur&lt;/a&gt;とか、&lt;strong&gt;2014年4月&lt;/strong&gt; に公開されたEmber.jsチーム製の&lt;a href=&#34;https://esnext.github.io/esnext/&#34;&gt;esnext&lt;/a&gt;のほうが先駆けだったんだけど、6to5の開発スピードがとんでもなく早く、&lt;strong&gt;2015年1Q&lt;/strong&gt; には機能面で両者を抜いてしまったらしい。)&lt;/p&gt;

&lt;p&gt;6to5は&lt;strong&gt;2015年2月&lt;/strong&gt;に名前を&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;に&lt;a href=&#34;https://babeljs.io/blog/2015/02/15/not-born-to-die&#34;&gt;変えて&lt;/a&gt;、単に6to5という名前が示す機能だけでなく、JavaScript周りの様々なツールを開発・統合するためのプラットフォームとなった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2018年現在&lt;/strong&gt;、Babel無しでフロントエンド開発をすることはほぼ無さそうな感じになってる。&lt;/p&gt;

&lt;h3 id=&#34;タスクランナー&#34;&gt;タスクランナー&lt;/h3&gt;

&lt;p&gt;モジュールバンドラやら、AltJSやら、AltCSSやらで、フロントエンドにコンパイルとかビルドとかいう作業が必要になって来たため、この業界にも必然的にタスクランナーが登場してきた。&lt;/p&gt;

&lt;p&gt;タスクランナーというのは、他業界ではビルドツールなどとも呼ばれているもので、Cとかで使われる&lt;a href=&#34;https://ja.wikipedia.org/wiki/Make&#34;&gt;Make&lt;/a&gt;とか、Javaの&lt;a href=&#34;https://ant.apache.org/&#34;&gt;Ant&lt;/a&gt;とか&lt;a href=&#34;https://maven.apache.org/&#34;&gt;Maven&lt;/a&gt;とか&lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt;とか、Googleの&lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;とかと同様のもの。&lt;/p&gt;

&lt;p&gt;まず、&lt;strong&gt;2012年1月&lt;/strong&gt; に&lt;a href=&#34;https://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;がリリースされて人気を博した。
が、当時のGruntの設定ファイルがJSONで&lt;a href=&#34;http://monmon.hatenablog.com/entry/2013/12/20/151321&#34;&gt;書きにくい&lt;/a&gt;とか、処理がシーケンシャルで遅いとかいう不満が潜在的に溜まっていった。&lt;/p&gt;

&lt;p&gt;で、それらの問題を払拭する&lt;a href=&#34;https://gulpjs.com/&#34;&gt;gulp&lt;/a&gt;が&lt;strong&gt;2013年7月&lt;/strong&gt;に出て、Gruntを食った。&lt;/p&gt;

&lt;p&gt;けど結局、Gruntもgulpも、タスクの処理をどこかの馬の骨が作ったプラグインに頼っていて不安定で、またビルドツールというレイヤが増えたせいでビルドエラーのデバッグがし辛くなるという&lt;a href=&#34;https://qiita.com/chuck0523/items/dafdbd19c12efd40e2de&#34;&gt;根本的な問題が顕在化&lt;/a&gt;し、&lt;a href=&#34;https://docs.npmjs.com/misc/scripts&#34;&gt;npm-scripts&lt;/a&gt;でいいじゃん、ってなった。&lt;/p&gt;

&lt;p&gt;シンプルイズベスト。&lt;/p&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第2世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第2世代)&lt;/h1&gt;

&lt;p&gt;前章で書いたフロントエンド界の変容の後あたりに、当時の先端技術を取り入れて誕生したフロントエンドフレームワークを、この記事では第2世代と呼ぶ。&lt;/p&gt;

&lt;p&gt;第2世代は第1世代から正統な進化を遂げた感じで、あいかわらずMVW (i.e. MV*)だった。
主要なのは以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; v1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年12月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Googleのエンジニア(個人)製。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mizchi.hatenablog.com/entry/2014/02/13/153742&#34;&gt;軽量AngularJS&lt;/a&gt;な感じらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://aurelia.io/&#34;&gt;Aurelia&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年11月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSっぽいフルスタックフレームワークで、EcmaScript 2015+とかWeb Componentsとかの先端技術を取り入れていることが売り。&lt;/li&gt;
&lt;li&gt;2-wayバインディング推しで、あまり流行らなかった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://riot.js.org/&#34;&gt;Riot&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年6月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSもReactも複雑すぎ。フロントエンド開発に必要十分なコンパクトな機能を提供するぜ、というフレームワーク。&lt;/li&gt;
&lt;li&gt;Aureliaよりかは使われていそう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/&#34;&gt;Angular&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年9月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSの後継。AngularJSとの互換性をばっさり切り捨てる代わりに、アーキテクチャを刷新し、性能面と機能面の&lt;a href=&#34;https://medium.com/@mnemon1ck/why-you-should-not-use-angularjs-1df5ddf6fc99&#34;&gt;色々な問題&lt;/a&gt;を克服したらしい。&lt;/li&gt;
&lt;li&gt;が、Reactが画期的過ぎてAngularJSの栄光は取り戻せなかった。&lt;/li&gt;
&lt;li&gt;最初2-wayバインディングまで切り捨てたが、あとで復活させた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;react-virtual-dom&#34;&gt;React (Virtual DOM)&lt;/h1&gt;

&lt;p&gt;第1世代から流行っていた2-wayバインディングがちょっと&lt;a href=&#34;https://stackoverflow.com/questions/35379515/why-is-two-way-databinding-in-angularjs-an-antipattern&#34;&gt;辛みを帯びてきた&lt;/a&gt;。
というか、2-wayバインディングしかできないAngularJSが辛くなってきたということだったのかもしれない。&lt;/p&gt;

&lt;p&gt;2-wayバインディングには以下のような問題があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;変更をwatchするオブジェクトが増えて、性能が悪くなる。&lt;/li&gt;
&lt;li&gt;ModelとViewとの間の依存やデータの流れが複雑になって、コーディングやデバッグが難しくなる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これに異を唱えて登場してきたのがFacebookによる&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;。
&lt;strong&gt;2013年3月&lt;/strong&gt; のことであった。&lt;/p&gt;

&lt;p&gt;2-wayバインディングもMVCもテンプレートも要らんとして、代わりにReactが突きつけてきた&lt;a href=&#34;https://reactjs.org/docs/faq-internals.html&#34;&gt;Virtual DOM&lt;/a&gt;という解は、世界中の人々の&lt;a href=&#34;https://qiita.com/mizchi/items/4d25bc26def1719d52e6&#34;&gt;魂を震えさせた&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Virtual DOMは、その名の通りDOMの仮想化であり、JavaScriptからReactのAPIを通してDOMのようなものを更新すると、Reactがいい感じに実DOMを更新してくれるというもの。
開発者は深く考えずに、イベントが発生するごとに、ページ全体を表すDOMツリーがどうなっているべきかをReactに教えるだけでいい。
あとはReactが、現在の実DOMとの差分を計算し、差分だけを性能よく更新してくれる。
これによって開発者は、DOMの状態やイベントの種類をみてアドホックに実DOMやModelの更新処理を書くという苦行から解放され、宣言的に&lt;a href=&#34;http://blog.neleid.com/2016/04/05/%E5%AF%8C%E8%B1%AA%E7%9A%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E6%AD%BB%E8%AA%9E%E3%81%8B/&#34;&gt;富豪的に&lt;/a&gt;フロントエンドプログラミングができるようになった。&lt;/p&gt;

&lt;p&gt;さらに&lt;strong&gt;2014年5月&lt;/strong&gt;、Reactにベストマッチするアプリケーションアーキテクチャとして&lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;Flux&lt;/a&gt;が発表された。
これは単方向のデータフローが特徴のアーキテクチャで、斬新でかっこよくて未来だった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/flux/raw/master/docs/img/flux-diagram-white-background.png&#34; alt=&#34;Flux&#34; title=&#34;Flux&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第3世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第3世代)&lt;/h1&gt;

&lt;p&gt;React後、Virtual DOMの実装がいくつも出てきた。
&lt;a href=&#34;https://github.com/Matt-Esch/virtual-dom&#34;&gt;virtual-dom&lt;/a&gt;とか&lt;a href=&#34;https://maquettejs.org/&#34;&gt;Maquette&lt;/a&gt;とか&lt;a href=&#34;https://preactjs.com/&#34;&gt;Preact&lt;/a&gt;とか&lt;a href=&#34;https://infernojs.org/&#34;&gt;Inferno&lt;/a&gt;とか。&lt;/p&gt;

&lt;p&gt;Fluxの実装も、Facebook自身による&lt;a href=&#34;https://github.com/facebook/flux&#34;&gt;Flux&lt;/a&gt;のほか、&lt;a href=&#34;http://fluxxor.com/&#34;&gt;Fluxxor&lt;/a&gt;とか&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;とか&lt;a href=&#34;https://mobx.js.org/&#34;&gt;MobX&lt;/a&gt;とか沢山出た。&lt;/p&gt;

&lt;p&gt;で、React+Reduxがいい感じってなって、&lt;a href=&#34;https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d&#34;&gt;世界の8割近くの人がReactで書くようになって&lt;/a&gt;、猫も杓子もVirtual DOMってなった辺りのフロントエンドフレームワークを第3世代と呼ぶことにする。&lt;/p&gt;

&lt;p&gt;第3世代としては以下が挙げられる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://grommet.io/&#34;&gt;Grommet&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年6月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;HPE製。&lt;/li&gt;
&lt;li&gt;Reactと&lt;a href=&#34;https://github.com/inuitcss/inuitcss&#34;&gt;inuitcss&lt;/a&gt;によるフレームワーク。&lt;/li&gt;
&lt;li&gt;全然流行ってないけど&lt;a href=&#34;http://grommet.io/docs/components&#34;&gt;コンポーネント&lt;/a&gt;の取り揃えがよくて結構いいような気がする。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://emberjs.com/blog/2015/08/13/ember-2-0-released.html&#34;&gt;Ember.js v2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年8月&lt;/strong&gt; リリース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://glimmerjs.com/&#34;&gt;Glimmer&lt;/a&gt;というレンダリングエンジンを搭載。

&lt;ul&gt;
&lt;li&gt;Glimmerは、テンプレートをGlimmer VM上で動くバイトコードにコンパイルして、実DOMを速くレンダリングしてくれるもの。&lt;/li&gt;
&lt;li&gt;Virtual DOMとは違う感じだけど、実DOMの更新を開発者の代わりにやってくれるあたり、目指しているものは同じ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://jp.vuejs.org/2016/10/01/here-2.0/&#34;&gt;Vue.js v2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年10月&lt;/strong&gt; リリース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/snabbdom/snabbdom&#34;&gt;snabbdom&lt;/a&gt;ベースのVirtual DOM実装を搭載。&lt;/li&gt;
&lt;li&gt;2017年頭位からかなりの勢いで流行ってきている。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hyperapp.js.org/&#34;&gt;Hyperapp&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2017年1月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/&#34;&gt;Qiita&lt;/a&gt;で働いてるエンジニアが趣味で作ったフレームワークで、Qiitaに採用された。&lt;/li&gt;
&lt;li&gt;超軽量(1KB!)で、シンプルが売り。&lt;/li&gt;
&lt;li&gt;独自のVirtual DOM実装であるPicodom(現&lt;a href=&#34;https://github.com/jorgebucaran/superfine&#34;&gt;superfine&lt;/a&gt;)を搭載。&lt;/li&gt;
&lt;li&gt;JSXにも対応。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://dojo.io/&#34;&gt;Dojo&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2018年5月&lt;/strong&gt; 正式版リリース。&lt;/li&gt;
&lt;li&gt;Dojo Toolkitの後継。&lt;/li&gt;
&lt;li&gt;Virtual DomでTypeScriptでリアクティブでフルスタック。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;終わりに&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2018年8月現在&lt;/strong&gt; では、React vs Vue.js vs Angularといった感じで、激動の時代が過ぎてやや落ち着いて来ている感があるが、油断はできない。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;いろいろ書いたけど、&lt;a href=&#34;https://electronjs.org/&#34;&gt;Electron&lt;/a&gt;とか&lt;a href=&#34;https://facebook.github.io/react-native/&#34;&gt;React Native&lt;/a&gt;とか&lt;a href=&#34;https://nextjs.org&#34;&gt;Next.js&lt;/a&gt;とかの&lt;a href=&#34;https://jp.vuejs.org/v2/guide/ssr.html&#34;&gt;SSR&lt;/a&gt;とか&lt;a href=&#34;https://www.gatsbyjs.org/&#34;&gt;Gatsby.js&lt;/a&gt;とか&lt;a href=&#34;https://graphql.org/learn/&#34;&gt;GraphQL&lt;/a&gt;とか&lt;a href=&#34;https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/?hl=ja&#34;&gt;PWA&lt;/a&gt;とか&lt;a href=&#34;https://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;とか&lt;a href=&#34;https://aws.amazon.com/jp/getting-started/serverless-web-app/&#34;&gt;サーバーレス&lt;/a&gt;とか&lt;a href=&#34;https://kuroeveryday.blogspot.com/2017/03/css-structure-and-rules.html&#34;&gt;CSS設計手法&lt;/a&gt;とかCSSフレームワークとかいろいろ書き漏れた。&lt;/p&gt;

&lt;p&gt;フロントエンドのユニットテストとかE2Eテストとかもいろいろあって面白い。
(E2Eテストは&lt;a href=&#34;https://www.kaitoy.xyz/2017/08/04/browser-test-framework/&#34;&gt;前に書いた&lt;/a&gt;。)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;年表も気が向いたら追加したい。&lt;/p&gt;

&lt;p&gt;しかしReact+Reduxに再入門したよ、っていう記事の前座として書くつもりだったのに、ずいぶん長編になってしまった…&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
