<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>https://www.kaitoy.xyz/tags/frontend/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2018</rights>
    <updated>2018-09-26 23:03:04 &#43;0900 JST</updated>

    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その6: Redux</title>
          <link>https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/</link>
          <pubDate>Wed, 26 Sep 2018 23:03:04 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/&#34;&gt;前回&lt;/a&gt;はMaterial-UIをセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reactの状態管理&#34;&gt;Reactの状態管理&lt;/h1&gt;

&lt;p&gt;Reactによるプログラミングをするとき、小さいUIコンポーネントをたくさん作って、それらを組み合わせてVirtual DOMツリーを作っておいて、そこにpropsをほうりこんでレンダリングする、という感じになる。
また、レンダリングした後はコンポーネントのstateをいじって状態を変化させる。&lt;/p&gt;

&lt;p&gt;このpropsやstateの扱いをReactの状態管理という。
propsやstateを適当にアドホックに設定してると、結局jQuery使ってるのとそんなに変わらなくなって辛くなるので、Reactの開発元であるFacebookは&lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;Flux&lt;/a&gt;というアーキテクチャを提案している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/flux/raw/master/docs/img/flux-diagram-white-background.png&#34; alt=&#34;Flux&#34; title=&#34;Flux&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Fluxでは、単一の(またはドメイン毎くらいの単位の)オブジェクトでアプリケーション全体の状態(state)を表し、これをStoreに保持する。
ReactはStoreが保持するstateを受け取り、それをもとにViewをレンダリングする。
Viewに対するユーザの操作(など)はActionというオブジェクトで表現され、Dispatcherに渡され、Dispatcherに登録されたcallbackを通してstateを変化させる。&lt;/p&gt;

&lt;p&gt;データが常に一方向に流れて見通しがよく、各コンポーネントの独立性が高いのが特徴。
各コンポーネントは、受け取ったデータをピュアに処理すればよく、リアクティブにファンクショナルに実装できる。&lt;/p&gt;

&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;

&lt;p&gt;Fluxの実装、というか発展形がRedux。&lt;/p&gt;

&lt;p&gt;ReduxではFluxのDispatcher辺りがReducerに置き換わっている。
ReducerはActionと現在のstateから次のstateを計算する純粋関数。&lt;/p&gt;

&lt;p&gt;また、ReduxからはViewが切り離されていて、Actionによってstateを更新する状態管理ライブラリの役割に徹している。
ReactコンポーネントのイベントハンドラからActionオブジェクトを生成したり、更新したstateをReactに渡したりするつなぎ目は、別途&lt;a href=&#34;https://github.com/reduxjs/react-redux&#34;&gt;React Redux&lt;/a&gt;というライブラリが担当する。&lt;/p&gt;

&lt;p&gt;ReduxとReact Reduxについては、Qiitaの「&lt;a href=&#34;https://qiita.com/mpyw/items/a816c6380219b1d5a3bf&#34;&gt;たぶんこれが一番分かりやすいと思います React + Redux のフロー図解&lt;/a&gt;」という記事が分かりやすい。&lt;/p&gt;

&lt;p&gt;今回はReduxを導入する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redux v4.0.0が入った。&lt;/p&gt;

&lt;p&gt;以降、現時点で唯一のUIコンポーネントであるHOGEボタンの状態管理を実装してみる。&lt;/p&gt;

&lt;h2 id=&#34;action&#34;&gt;Action&lt;/h2&gt;

&lt;p&gt;まず&lt;a href=&#34;https://redux.js.org/basics/actions&#34;&gt;Action&lt;/a&gt;を実装する。&lt;/p&gt;

&lt;p&gt;Actionオブジェクトはどんな形式でもいいけど、普通は&lt;a href=&#34;https://github.com/redux-utilities/flux-standard-action&#34;&gt;Flux Standard Action&lt;/a&gt;(FSA)にする。
FSAは以下のプロパティを持つプレーンオブジェクト。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type: Action種別を示す文字列定数。必須。&lt;/li&gt;
&lt;li&gt;payload: Actionの情報を示す任意の型の値。任意。&lt;/li&gt;
&lt;li&gt;error: Actionがエラーを表すものかを示す boolean プロパティ。エラーなら true にして、payload にエラーオブジェクトをセットする。任意。&lt;/li&gt;
&lt;li&gt;meta: その他の情報を入れる任意の型の値。任意。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Actionのコードは、Actionのtypeに入れる値を定義する&lt;code&gt;actionTypes.js&lt;/code&gt;と、Action Creator(i.e. Actionオブジェクトを生成する関数)を定義する&lt;code&gt;actions.js&lt;/code&gt;からなり、ともに&lt;code&gt;src/actions/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;HOGEボタンをクリックしたときのAction、&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;を定義してみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/actions/actionTypes.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const HOGE_BUTTON_CLICKED = &#39;HOGE_BUTTON_CLICKED&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/actions/actions.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {
  HOGE_BUTTON_CLICKED,
} from &#39;./actionTypes&#39;;

export function hogeButtonClicked(payload) {
  return {
    type: HOGE_BUTTON_CLICKED,
    payload,
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;h2 id=&#34;reducer&#34;&gt;Reducer&lt;/h2&gt;

&lt;p&gt;次は&lt;a href=&#34;https://redux.js.org/basics/reducers&#34;&gt;Reducer&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Reducerは、上記Action Creatorが生成するActionオブジェクトに対応して起動し、Store(後述)から現在のstateオブジェクトを受け取って、Actionオブジェクトのpayloadの値(など)に応じて新しいstateオブジェクトを作る。&lt;/p&gt;

&lt;p&gt;Reducerを書く前に、stateオブジェクトの構造を設計しておくことが推奨されている。
UIコンポーネント毎にプロパティを分けて、コンポーネント構造と同様の階層構造にしておけばだいたいよさそう。&lt;/p&gt;

&lt;p&gt;HOGEボタンに一つ、クリックしたかどうかの状態(&lt;code&gt;clicked&lt;/code&gt;)を持たせるとすると、stateオブジェクトは以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  hoge: {
    clicked: false,
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Reducerはピュアじゃないといけないので、内部で&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0&#34;&gt;副作用&lt;/a&gt;を起こしてはいけない。
副作用とは、具体的には以下のようなもの。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引数で与えられたオブジェクトを変更する。&lt;/li&gt;
&lt;li&gt;REST APIへのリクエストを送る。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(ログの出力も厳密には副作用なんだろうけど、それは許されてる気がする。)&lt;/p&gt;

&lt;p&gt;また、ピュアであるためには&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E9%80%8F%E9%81%8E%E6%80%A7&#34;&gt;参照透過性&lt;/a&gt;を持たないといけなくて、つまり同じ引数に対しては同じ戻り値を返さないといけないので、内部で&lt;code&gt;Date.now()&lt;/code&gt;とか&lt;code&gt;Math.random()&lt;/code&gt;とかを呼ぶのもダメ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Reducerのコードは&lt;code&gt;src/reducers/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;が発生したら、&lt;code&gt;hoge&lt;/code&gt;の&lt;code&gt;clicked&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にするReducer(&lt;code&gt;hoge()&lt;/code&gt;)は以下の感じに書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;

const initialState = {
  hoge: {
    clicked: false,
  },
};

export function hoge(state = initialState, action) {
  switch (action.type) {
    case HOGE_BUTTON_CLICKED:
      const newHoge = {
        hoge: {
          clicked: true,
        },
      };
      return Object.assign({}, state, newHoge);
    default:
      return state;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hoge()&lt;/code&gt;のポイントはたくさんある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt;と&lt;code&gt;action&lt;/code&gt;を引数に取る。前者が現在の状態を表すstateオブジェクトで、後者がActionオブジェクト。&lt;/li&gt;
&lt;li&gt;戻り値は新しい状態を表すstateオブジェクト。&lt;/li&gt;
&lt;li&gt;actionオブジェクトはどのActionを表すものかは分からないので、&lt;code&gt;action.type&lt;/code&gt;を見て&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;だけを処理するようにする。

&lt;ul&gt;
&lt;li&gt;知らないActionだったら(i.e. &lt;code&gt;default&lt;/code&gt;句のなかに来たら)、受け取ったstateオブジェクトをそのまま返す。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;アプリケーションの初期化時には&lt;code&gt;state&lt;/code&gt;に&lt;code&gt;undefined&lt;/code&gt;が渡されるので、それに備え、初期状態である&lt;code&gt;initialState&lt;/code&gt;をデフォルト引数に設定する。&lt;/li&gt;
&lt;li&gt;渡されたstateオブジェクトを変更してはいけないので、&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&#34;&gt;Object.assgin()&lt;/a&gt;に空オブジェクト&lt;code&gt;{}&lt;/code&gt;とともに&lt;code&gt;state&lt;/code&gt;を渡してコピーする。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assgin()&lt;/code&gt;の代わりに&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5&#34;&gt;オブジェクト分割代入&lt;/a&gt;を使う方法も&lt;a href=&#34;https://redux.js.org/recipes/usingobjectspreadoperator&#34;&gt;ある&lt;/a&gt;。この場合&lt;a href=&#34;https://babeljs.io/docs/en/babel-plugin-transform-object-rest-spread&#34;&gt;babel-plugin-transform-object-rest-spread&lt;/a&gt;が必要。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.assign()&lt;/code&gt;の第三引数に&lt;code&gt;newHoge&lt;/code&gt;で上書きするようにしている。

&lt;ul&gt;
&lt;li&gt;今はstateオブジェクトのプロパティが&lt;code&gt;hoge&lt;/code&gt;一つだけなので単に&lt;code&gt;newHoge&lt;/code&gt;をreturnしても結果は一緒。なので無駄なことをしてるようにも見えるけど、stateオブジェクトのプロパティが増えた場合に&lt;code&gt;hoge&lt;/code&gt;以外に影響を与えないための計らい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これはこれでいい感じに見えるけど、&lt;code&gt;hoge()&lt;/code&gt;が&lt;code&gt;hoge&lt;/code&gt;プロパティしか扱わないのに、stateオブジェクト全体を渡しているのがイケていない。
(まあ今はstateオブジェクトには&lt;code&gt;hoge&lt;/code&gt;プロパティしかないんだけど、他のプロパティが色々増えてくるとイケてない感が高まる。)
&lt;code&gt;hoge&lt;/code&gt;プロパティがstateオブジェクト構造のどこにあるかを&lt;code&gt;hoge()&lt;/code&gt;が気にしないといけないのもイケてない。
&lt;code&gt;hoge()&lt;/code&gt;には&lt;code&gt;hoge&lt;/code&gt;プロパティだけを見てほしい。&lt;/p&gt;

&lt;p&gt;ということで、普通はReducerは分割して書いて、それぞれのReducerにstateオブジェクトを分割して渡してやる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;

-const initialState = {
-  hoge: {
-    clicked: false,
-  },
-};

-export function hoge(state = initialState, action) {
+export function hoge(state = { clicked: false }, action) {
   switch (action.type) {
     case HOGE_BUTTON_CLICKED:
       const newHoge = {
-        hoge: {
-          clicked: true,
-        },
+        clicked: true,
       };
       return Object.assign({}, state, newHoge);
     default:
       return state;
   }
 }

+export function rootReducer(state = {}, action) {
+  return {
+    hoge: hoge(state.hoge, action),
+  }
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで、&lt;code&gt;rootReducer()&lt;/code&gt;がstateオブジェクトを分割して子Reducerを呼び出す。
孫Reducerとか曾孫Reducerとかがあってもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rootReducer()&lt;/code&gt;は別のファイルに書くと見やすくなるし、Reduxの&lt;a href=&#34;https://redux.js.org/api/combinereducers&#34;&gt;combineReducers()&lt;/a&gt;というヘルパー関数を使うともっと楽に書ける。
上記&lt;code&gt;reducers.js&lt;/code&gt;からは&lt;code&gt;rootReducer()&lt;/code&gt;を削除して、&lt;code&gt;rootReducer.js&lt;/code&gt;に以下のように書く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { combineReducers } from &#39;redux&#39;;
import hoge from &#39;./reducers&#39;;

const rootReducer = combineReducers({
  hoge,
});
export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように&lt;code&gt;combineReducers()&lt;/code&gt;で作った&lt;code&gt;rootReducer&lt;/code&gt;は、上で自前で書いた&lt;code&gt;rootReducer&lt;/code&gt;と全く同じ動きをする。&lt;/p&gt;

&lt;p&gt;さらに簡単に、以下のようにも書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { combineReducers } from &#39;redux&#39;;
import * as reducers from &#39;./reducers&#39;;

const rootReducer = combineReducers(reducers);
export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておけば、Reducerの追加は&lt;code&gt;reducers.js&lt;/code&gt;に関数を追加するだけでよくなる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redux-utilities/redux-actions&#34;&gt;redux-actions&lt;/a&gt;を使うとさらに記述を簡略化できるみたいだけど、逆に何が何だか分からなくなりそうだったので、慣れるまでは使わないでおく。&lt;/p&gt;

&lt;h2 id=&#34;store&#34;&gt;Store&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://redux.js.org/basics/store&#34;&gt;Store&lt;/a&gt;は以下のような特徴を持つオブジェクト。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState()&lt;/code&gt;でstateオブジェクトを返す。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;でActionをディスパッチできる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;でActionのディスパッチをサブスクライブできる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StoreはrootReducerを&lt;a href=&#34;https://redux.js.org/api/createstore&#34;&gt;createStore()&lt;/a&gt;に渡すことで作れる。
&lt;code&gt;createStore()&lt;/code&gt;を呼ぶコードはモジュールにしておくのがいい。
後で膨らんでくるので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore } from &#39;redux&#39;;
import rootReducer from &#39;./reducers/rootReducer&#39;;

export default function configureStore(initialState = {}) {
  const store = createStore(
    rootReducer,
    initialState,
  );
  return store;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でReduxのコンポーネントが一通りそろって、状態管理システムができた。
試しに動かしてみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/try.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { hogeButtonClicked } from &#39;./actions/actions&#39;;
import configureStore from &#39;./configureStore&#39;;

const store = configureStore();
console.log(store.getState()); // =&amp;gt; { hoge: {clicked: false} }

store.subscribe(() =&amp;gt; {
  console.log(store.getState());
});

store.dispatch(hogeButtonClicked()); // =&amp;gt; { hoge: {clicked: true} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;するとReducer(&lt;code&gt;hoge()&lt;/code&gt;)が実行され、stateオブジェクトが更新されることが分かる。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その5: Material-UIとWebフォント</title>
          <link>https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/</link>
          <pubDate>Thu, 06 Sep 2018 23:33:31 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/&#34;&gt;前回&lt;/a&gt;はCSS周りの処理系をセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;既成reactコンポーネント&#34;&gt;既成Reactコンポーネント&lt;/h1&gt;

&lt;p&gt;前回まででHTMLもCSSもReactコンポーネント単位で書けるようになったんだけど、実際、自分で1からコンポーネントを書くのは、特にデザインセンスがない人にとっては辛い。
かっこいいUIコンポーネントを作りたいならデザイナーの協力が必要だけど、個人の開発などそれができない状況も多い。&lt;/p&gt;

&lt;p&gt;という問題を抱えた人たち向けなのかはわからないが、既成のReactコンポーネントセットが色々OSSで提供されている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://material-ui.com/&#34;&gt;Material-UI&lt;/a&gt;: Googleの&lt;a href=&#34;https://material.io/design/&#34;&gt;マテリアルデザイン&lt;/a&gt;のReact実装。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://react.semantic-ui.com/&#34;&gt;Semantic UI React&lt;/a&gt;: &lt;a href=&#34;https://semantic-ui.com/&#34;&gt;Semantic UI&lt;/a&gt;のReactバインディング。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ant.design/docs/react/introduce&#34;&gt;antd&lt;/a&gt;: &lt;a href=&#34;https://ant.design/&#34;&gt;Ant Design&lt;/a&gt;のReact実装。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blueprintjs.com/&#34;&gt;Blueprint&lt;/a&gt;: 複雑でデータ量の多いUI向けに作られたReact UIツールキット。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://react-bootstrap.github.io/&#34;&gt;React-Bootstrap&lt;/a&gt;: &lt;a href=&#34;https://getbootstrap.com/&#34;&gt;Bootstrap&lt;/a&gt;のReactバインディング。現時点ではv4未対応。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://grommet.io/&#34;&gt;Grommet&lt;/a&gt;: HPEによるエンタープライズレディなデザインシステム。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/fabric#/components&#34;&gt;Office UI Fabric React&lt;/a&gt;: OfficeなどのMicrosoft製品に使われているReactコンポーネントセット。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;今回はこの中でも圧倒的に人気なMaterial-UIを導入する。&lt;/p&gt;

&lt;h1 id=&#34;material-ui&#34;&gt;Material-UI&lt;/h1&gt;

&lt;p&gt;Material-UIは簡単に使える。
とりあえずコアパッケージをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add @material-ui/core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v1.4.1が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとはパッケージに入っている色々なコンポーネントをMaterial-UIのドキュメント見ながら使えばいいだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import styled from &#39;styled-components&#39;;
 +import Button from &#39;@material-ui/core/Button&#39;;

 const Wrapper = styled.div`
   font-size: 5rem;
 `;

 const App = () =&amp;gt; (
   &amp;lt;Wrapper&amp;gt;
-    HOGE
+    &amp;lt;Button variant=&amp;quot;contained&amp;quot;&amp;gt;
+      HOGE
+    &amp;lt;/Button&amp;gt;
   &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでただのテキストがボタンになった。&lt;/p&gt;

&lt;h1 id=&#34;css-web-fonts&#34;&gt;CSS Web Fonts&lt;/h1&gt;

&lt;p&gt;前節でいちおうMaterial-UI使えたけど、フォントをケアしてやるともう少しかっこよくなる。
Material-UIは&lt;a href=&#34;https://fonts.google.com/specimen/Roboto&#34;&gt;Robotoフォント&lt;/a&gt;を想定して作られているが、これはブラウザにデフォルトで入ってはいないので、そのままだとArialとかにフォールバックされちゃう。
のでRobotoフォントを導入する。&lt;/p&gt;

&lt;p&gt;フォントは&lt;a href=&#34;https://www.w3schools.com/css/css3_fonts.asp&#34;&gt;CSS Web Fonts&lt;/a&gt;の機能である&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/@font-face&#34;&gt;@font-face&lt;/a&gt;で、フォントファイルをブラウザにロードさせることで導入できる。
&lt;code&gt;@font-face&lt;/code&gt;で読み込むフォントファイル(i.e. &lt;code&gt;url()&lt;/code&gt;関数で指定するファイル)はwebpackでバンドルできる。&lt;/p&gt;

&lt;p&gt;Robotoフォントのフォントファイルはnpmで配布されていて、Yarnでプロジェクトにインストールできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add typeface-roboto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;フォントファイルの種類は、OTFとかTTFとかWOFFとかWOFF2とかいろいろあるけど、&lt;a href=&#34;https://www.6666666.jp/design/20160218/&#34;&gt;この記事&lt;/a&gt;などをみるに、WOFFだけ使えばよさげ。&lt;/p&gt;

&lt;p&gt;フォントファイルのバンドルは&lt;a href=&#34;https://github.com/webpack-contrib/url-loader&#34;&gt;url-loader&lt;/a&gt;を使う方法と&lt;a href=&#34;https://github.com/webpack-contrib/file-loader&#34;&gt;file-loader&lt;/a&gt;を使う方法とがある。&lt;/p&gt;

&lt;h2 id=&#34;url-loaderを使う方法&#34;&gt;url-loaderを使う方法&lt;/h2&gt;

&lt;p&gt;url-loaderを使う場合は、url-loaderとフォールバック用のfile-loaderをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn add -D url-loader file-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackのローダ設定は以下のようなのを追加すればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;(前略)
   module: {
     rules: [
(中略)
-      }
+      },
+      {
+        test: /\.(png|woff|woff2|eot|ttf|svg)$/,
+        include: [path.resolve(__dirname, &#39;node_modules/typeface-roboto&#39;)],
+        loader: &#39;url-loader&#39;,
+        options: {
+          limit: 100000,
+        },
+      },
     ],
   },
(後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとは、typeface-robotoパッケージ内のフォントファイルを指すようにCSSに@font-faceを書けばいい。
例えば、weightが300のWOFFファイルを読むなら以下のような感じ。&lt;/p&gt;

&lt;p&gt;src/fonts.css:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@font-face {
  font-family: &#39;Roboto&#39;;
  font-style: normal;
  font-display: swap;
  font-weight: 300;
  src: local(&#39;Roboto Light &#39;), local(&#39;Roboto-Light&#39;),
    url(&#39;../node_modules/typeface-roboto/files/roboto-latin-300.woff&#39;) format(&#39;woff&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどこかのJavaScriptでインポートしてやればいい。&lt;/p&gt;

&lt;p&gt;src/index.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import ReactDOM from &#39;react-dom&#39;;
 import App from &#39;./components/App&#39;;
+import &#39;./fonts.css&#39;;

 const root = document.getElementById(&#39;root&#39;);

 if (root) {
   ReactDOM.render(
     &amp;lt;App /&amp;gt;,
     root,
   );
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;けど、styled-componentsを使っている場合はurl-loaderは使えないみたいで、代わりにfile-loaderを使う必要がある。&lt;/p&gt;

&lt;h2 id=&#34;file-loaderを使う方法-styled-components&#34;&gt;file-loaderを使う方法 (styled-components)&lt;/h2&gt;

&lt;p&gt;file-loaderを使う場合は、file-loaderだけインストールすればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn add -D file-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackのローダ設定は以下のようなのを追加すればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;(前略)
   module: {
     rules: [
(中略)
-      }
+      },
+      {
+        test: /\.(png|woff|woff2|eot|ttf|svg)$/,
+        include: [path.resolve(__dirname, &#39;node_modules&#39;)],
+        loader: &#39;file-loader&#39;,
+      },
     ],
   },
(後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、&lt;a href=&#34;https://github.com/styled-components/styled-components/issues/233&#34;&gt;ここ&lt;/a&gt;にある通り、styled-componentsの&lt;a href=&#34;https://www.styled-components.com/docs/api#injectglobal&#34;&gt;injectGlobal&lt;/a&gt;というAPIを使って、以下のようにフォントファイルを読み込む。&lt;/p&gt;

&lt;p&gt;src/font.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { injectGlobal } from &#39;styled-components&#39;;
import roboto300 from &#39;../node_modules/typeface-roboto/files/roboto-latin-300.woff&#39;;

injectGlobal`
  /* roboto-300normal - latin */
  @font-face {
    font-family: &#39;Roboto&#39;;
    font-style: normal;
    font-display: swap;
    font-weight: 300;
    src:
      local(&#39;Roboto Light &#39;),
      local(&#39;Roboto-Light&#39;),
      url(&#39;${roboto300}&#39;) format(&#39;woff&#39;);
  }
`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとはこれをどこかのJavaScriptでインポートしてやればいい。&lt;/p&gt;

&lt;p&gt;src/index.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import ReactDOM from &#39;react-dom&#39;;
 import App from &#39;./components/App&#39;;
+import &#39;./fonts&#39;;

 const root = document.getElementById(&#39;root&#39;);

 if (root) {
   ReactDOM.render(
     &amp;lt;App /&amp;gt;,
     root,
   );
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/&#34;&gt;次回&lt;/a&gt;はようやくReduxを導入する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その4: CSS ModulesとPostCSSとstylelintとstyled-components</title>
          <link>https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/</link>
          <pubDate>Wed, 29 Aug 2018 23:50:53 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/&#34;&gt;前回&lt;/a&gt;はPrettierとESLintをセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;css&#34;&gt;CSS&lt;/h1&gt;

&lt;p&gt;前回までで作った環境で、Reactを使ってHTMLのDOMツリーを構築することができるようになったが、これは基本的にUIに表示する情報の構造しか定義しない。
UIの見た目(スタイル)を決めるのはCSSなので、それをアプリに組み込むことを考えないといけない。&lt;/p&gt;

&lt;p&gt;組み込み方には現時点で大きく3通りある。&lt;/p&gt;

&lt;h2 id=&#34;cssを別途設計する&#34;&gt;CSSを別途設計する&lt;/h2&gt;

&lt;p&gt;一つ目はCSSを別途設計する方法。&lt;/p&gt;

&lt;p&gt;Reactコンポーネントからレンダリングされる要素にclassが付くようにしておいて、設計したCSSをbundle.jsとは別途読み込んでスタイルを適用することにはる。&lt;/p&gt;

&lt;p&gt;この場合、CSSのスタイル定義はすべてグローバルなので、設計効率やメンテナンス効率を維持しつつ、各コンポーネントに意図したスタイルが適用されるようにするため、テクニックを凝らしてCSSクラスを設計する必要がある。
例えば&lt;a href=&#34;https://en.bem.info/&#34;&gt;BEM&lt;/a&gt; (2009年3月誕生)、&lt;a href=&#34;http://oocss.org/&#34;&gt;OOCSS&lt;/a&gt; (2009年3月誕生)、&lt;a href=&#34;https://smacss.com/ja&#34;&gt;SMACSS&lt;/a&gt; (2011年9月誕生)、&lt;a href=&#34;https://github.com/hiloki/flocss&#34;&gt;FLOCSS&lt;/a&gt; (2014年4月誕生)など。&lt;/p&gt;

&lt;p&gt;CSS自体は、素のCSSを書くことはあまりなく、普通は&lt;a href=&#34;https://sass-lang.com/&#34;&gt;Sass&lt;/a&gt;などのAltCSSや&lt;a href=&#34;https://postcss.org/&#34;&gt;PostCSS&lt;/a&gt;を使って書く。&lt;/p&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/stylelint/stylelint&#34;&gt;stylelint&lt;/a&gt;でリンティングすることで、CSSの品質を上げられる。
リンティングルールは、stylelintプロジェクトから提供されている&lt;a href=&#34;https://github.com/stylelint/stylelint-config-recommended&#34;&gt;stylelint-config-recommended&lt;/a&gt;か&lt;a href=&#34;https://github.com/stylelint/stylelint-config-standard&#34;&gt;stylelint-config-standard&lt;/a&gt;を使えば十分。
後者がGoogleやAirbnbのCSSスタイルガイドを反映していていい感じ。&lt;/p&gt;

&lt;p&gt;書いたCSSは、webpackの&lt;a href=&#34;https://github.com/webpack-contrib/css-loader&#34;&gt;css-loader&lt;/a&gt;で読み込める。
webpackはJavaScriptの&lt;code&gt;import &#39;./App.css&#39;;&lt;/code&gt;みたいなコードを見つけると、css-loaderに処理を渡す。
css-loaderは、&lt;code&gt;import&lt;/code&gt;文で指定されたCSSファイルだけでなく、&lt;code&gt;@import&lt;/code&gt;や&lt;code&gt;url()&lt;/code&gt;で定義される依存関係をたどって関連するCSSを一通り読み込む。&lt;/p&gt;

&lt;p&gt;読み込んだCSSは、webpackの&lt;a href=&#34;https://github.com/webpack-contrib/style-loader&#34;&gt;style-loader&lt;/a&gt;を使ってDOMに適用できる。
style-loaderは、読み込んだCSSを&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;タグで囲ってHTMLのヘッダに挿入してくれる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;CSSの処理にはPostCSSを使うとして、プロジェクトに以下のパッケージを追加する。
(PostCSSについては&lt;a href=&#34;https://qiita.com/morishitter/items/4a04eb144abf49f41d7d&#34;&gt;Qiitaの記事&lt;/a&gt;が参考になった。)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;css-loader: CSSを読み込むためのwebpackのローダ。&lt;/li&gt;
&lt;li&gt;style-loader: CSSをDOMに追加するためのwebpackのローダ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/postcss/postcss-loader&#34;&gt;postcss-loader&lt;/a&gt;: PostCSSを実行するためのwebpackのローダ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://preset-env.cssdb.org/&#34;&gt;postcss-preset-env&lt;/a&gt;: CSSのエッジな機能を使うためのPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/postcss/autoprefixer&#34;&gt;autoprefixer&lt;/a&gt;: CSSプロパティにベンダプレフィックスを追加してくれるPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/luisrudge/postcss-flexbugs-fixes&#34;&gt;postcss-flexbugs-fixes&lt;/a&gt;: &lt;a href=&#34;https://www.w3schools.com/css/css3_flexbox.asp&#34;&gt;Flexbox&lt;/a&gt;のバグを修正してくれるPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cssnano/cssnano&#34;&gt;cssnano&lt;/a&gt;: CSSをミニファイしてくれるPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;stylelint: CSSのリンタ。&lt;/li&gt;
&lt;li&gt;stylelint-config-standard: stylelintのルール設定集。&lt;/li&gt;
&lt;li&gt;stylelint-config-prettier: &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;が施すコード整形とコンフリクトするルールを無効にするstylelintルール設定集。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D css-loader style-loader postcss-loader postcss-preset-env autoprefixer postcss-flexbugs-fixes cssnano stylelint stylelint-config-standard stylelint-config-prettier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;PostCSSとstylelintの設定は、それぞれpostcss.config.jsとstylelint.config.jsを書いてプロジェクトルートに置けばいい。&lt;/p&gt;

&lt;p&gt;postcss.config.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  plugins: {
    stylelint: {},
    &#39;postcss-preset-env&#39;: {},
    autoprefixer: {},
    &#39;postcss-flexbugs-fixes&#39;: {},
    cssnano: {},
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stylelint.config.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  extends: [&#39;stylelint-config-standard&#39;, &#39;stylelint-config-prettier&#39;],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stylelintはPostCSSのプラグインとしてPostCSSから実行する構成。&lt;/p&gt;

&lt;p&gt;stylelint.config.jsで、stylelint-config-prettierはextendsの最後に書く必要があることに注意。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackにもローダの設定を追加する。&lt;/p&gt;

&lt;p&gt;webpack.common.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
+      {
+        test: /\.css$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        use: [
+          &#39;style-loader&#39;,
+          {
+            loader: &#39;css-loader&#39;,
+            options: {
+              importLoaders: 1,
+            },
+          },
+          &#39;postcss-loader&#39;,
+        ],
+      },
     ],
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで追加した設定は、&lt;code&gt;&amp;lt;プロジェクトルート&amp;gt;/src&lt;/code&gt;ディレクトリ内の&lt;code&gt;.css&lt;/code&gt;ファイルが&lt;code&gt;import&lt;/code&gt;されたら、postcss-loader、css-loader、style-loaderの順にそのファイルを処理する、というもの。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;実際のCSSは普通に書いて、JavaScriptからimportしてやればいい。&lt;/p&gt;

&lt;p&gt;components/App.css:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.normal {
  font-size: 5rem;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;components/App.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
+import &#39;./App.css&#39;

 const App = () =&amp;gt; (
-  &amp;lt;div&amp;gt;
+  &amp;lt;div className=&amp;quot;normal&amp;quot;&amp;gt;
     HOGE
   &amp;lt;/div&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSXでHTML要素にclass属性を付けるには、classNameプロパティを使うことに注意。&lt;/p&gt;

&lt;p&gt;これでHOGEに&lt;code&gt;font-size: 5rem&lt;/code&gt;が適用され、文字が大きくなる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でCSSを適用できた。&lt;/p&gt;

&lt;p&gt;これはこれで十分で柔軟なやりかただけど、BEMなどでCSSクラスの設計を頑張る手間がある。
UIコンポーネントの構造とスタイルの構造を1対1対応させるなら、もっと楽な方法がある。&lt;/p&gt;

&lt;h2 id=&#34;css-modules&#34;&gt;CSS Modules&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/css-modules/css-modules&#34;&gt;CSS Modules&lt;/a&gt;は2015年9月に&lt;a href=&#34;https://postd.cc/css-modules/&#34;&gt;発表&lt;/a&gt;された技術で、一つのCSSファイルを一つのモジュールと考え、モジュールごとにCSSクラス名の名前空間を自動生成し、スタイルの影響範囲をモジュールに閉じ込めてくれるもの。
(実際には、子要素に継承されるプロパティもあるので完全に閉じ込められるわけではない。)&lt;/p&gt;

&lt;p&gt;ReactによるUIコンポーネントごとにCSSモジュールを作り、コンポーネント単位でスタイリングすることを意図した技術であり、コンポーネント内で閉じたCSSクラス設計をすればいいだけになり、BEMとかを考えなくてよくなる。&lt;/p&gt;

&lt;p&gt;CSS Modulesを使うには、&lt;a href=&#34;https://github.com/gajus/babel-plugin-react-css-modules&#34;&gt;babel-plugin-react-css-modules&lt;/a&gt;というBabelのプラグインをセットアップすればいい。
まずはそれをプロジェクトにインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D babel-plugin-react-css-modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Babelの設定を修正してインストールしたbabel-plugin-react-css-modulesを使うようにする。&lt;/p&gt;

&lt;p&gt;.babelrc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
-  &amp;quot;presets&amp;quot;: [&amp;quot;env&amp;quot;, &amp;quot;react&amp;quot;]
+  &amp;quot;presets&amp;quot;: [&amp;quot;env&amp;quot;, &amp;quot;react&amp;quot;],
+  &amp;quot;plugins&amp;quot;: [&amp;quot;react-css-modules&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackのcss-loaderのオプションを追加して、CSS Modulesを有効にする。&lt;/p&gt;

&lt;p&gt;webpack.common.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
       {
         test: /\.css$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         use: [
           &#39;style-loader&#39;,
           {
             loader: &#39;css-loader&#39;,
             options: {
               importLoaders: 1,
+              modules: true,
+              localIdentName: &#39;[path]___[name]__[local]___[hash:base64:5]&#39;,
             },
           },
           &#39;postcss-loader&#39;,
         ],
       },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;modules&lt;/code&gt;がCSS Modulesを有効化するスイッチ。
&lt;code&gt;localIdentName&lt;/code&gt;はモジュール化したCSSクラスの命名規則で、babel-plugin-react-css-modulesの設定と合っている必要がある。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとは、コンポーネントの方で&lt;code&gt;className&lt;/code&gt;プロパティを&lt;code&gt;styleName&lt;/code&gt;プロパティに変えればいい。&lt;/p&gt;

&lt;p&gt;components/App.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import &#39;./App.css&#39;

 const App = () =&amp;gt; (
-  &amp;lt;div className=&amp;quot;normal&amp;quot;&amp;gt;
+  &amp;lt;div styleName=&amp;quot;normal&amp;quot;&amp;gt;
     HOGE
   &amp;lt;/div&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でCSS Modulesの設定は完了。
App.cssに書いたクラス名はcss-loaderによって変換され、App.jsxに書いたstyleNameはbabel-plugin-react-css-modulesによって変換され、どちらも&lt;code&gt;src-components-___App__normal___1fxGx&lt;/code&gt;になるようになる。&lt;/p&gt;

&lt;h2 id=&#34;css-in-js&#34;&gt;CSS in JS&lt;/h2&gt;

&lt;p&gt;3つめはCSS in JS。&lt;/p&gt;

&lt;p&gt;これは2014年11月に&lt;a href=&#34;https://speakerdeck.com/vjeux/react-css-in-js&#34;&gt;提唱された&lt;/a&gt;技術で、UIコンポーネントとそのスタイルを両方一つのJavaScriptファイルに書いて、完全に一体化させるというもの。&lt;/p&gt;

&lt;p&gt;CSS in JSはCSS Modulesの陰でしばらく目立たなかったが、2016年に&lt;a href=&#34;https://www.styled-components.com/&#34;&gt;styled-components&lt;/a&gt;という実装がリリースされて注目され、その後いくつかの実装が生まれた。
styled-componentsは2017年ころからCSS Modulesに代わって人気になり、&lt;a href=&#34;https://postd.cc/stop-using-css-in-javascript-for-web-development-fa/&#34;&gt;CSS Modules陣営からの反撃&lt;/a&gt;もあったものの、今日まで支持を増やしている模様。
SassやPostCSSなど既存のCSSエコシステムを切り捨てているのと、React限定なのが気になるところではあるが、時流に乗って使ってみることにする。&lt;/p&gt;

&lt;p&gt;なお、CSS in JSはCSS Modulesとセットアップ方法がかなり異なるので、本稿前節までの変更はいったん全部破棄する。&lt;/p&gt;

&lt;p&gt;styled-componentsを使う場合、プロジェクトに追加する必要があるのは二つだけ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;styled-components: styled-components本体。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/styled-components/babel-plugin-styled-components&#34;&gt;babel-plugin-styled-components&lt;/a&gt;: styled-componentsのサポートを強化するBabelプラグイン。実際には必須ではないけど、バンドルサイズを削減出来たり、SSRしやすくなったりする。ベンダプレフィックスの付与とかミニファイもしてくれる。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add styled-components
yarn add -D babel-plugin-styled-components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;styled-componentsはv3.4.4が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Babelの設定は以下のように修正する。&lt;/p&gt;

&lt;p&gt;.babelrc&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
-  &amp;quot;presets&amp;quot;: [&amp;quot;env&amp;quot;, &amp;quot;react&amp;quot;]
+  &amp;quot;presets&amp;quot;: [&amp;quot;env&amp;quot;, &amp;quot;react&amp;quot;],
+  &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;App.jsxは、styled-componentsのstyledというAPIを使ってWrapperコンポーネント(スタイル付きdiv)を定義し、これをdivと置き換える。&lt;/p&gt;

&lt;p&gt;components/App.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
+import styled from &#39;styled-components&#39;;

+const Wrapper = styled.div`
+  font-size: 5rem;
+`;

 const App = () =&amp;gt; (
-  &amp;lt;div&amp;gt;
+  &amp;lt;Wrapper&amp;gt;
     HOGE
-  &amp;lt;/div&amp;gt;
+  &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。CSS Modulesに比べて大分シンプル。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;styled.div&lt;/code&gt;でスタイルを記述している部分は見慣れない構文だけど、ECMAScript 2015で追加されたタグ付きテンプレートリテラルという構文で、テンプレート文字列の一種。
ここに書くスタイルの構文はCSSと全く一緒。
JavaScriptの構文としては単なる文字列なので、変数を使ったり、if文とかで動的に変えたり、数値を計算したり、自由に書ける。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ややややこしいが、&lt;a href=&#34;https://www.styled-components.com/docs/tooling#stylelint&#34;&gt;stylelintによるリンティング&lt;/a&gt;もできる。
以下のパッケージをプロジェクトに追加する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stylelint: CSSのリンタ。(既出)&lt;/li&gt;
&lt;li&gt;stylelint-config-standard: stylelintのルール設定集。(既出)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/styled-components/stylelint-processor-styled-components&#34;&gt;stylelint-processor-styled-components&lt;/a&gt;: スタイル付きコンポーネントからスタイル定義を抽出するstylelintのカスタムプロセッサ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/styled-components/stylelint-config-styled-components&#34;&gt;stylelint-config-styled-components&lt;/a&gt;: stylelint-processor-styled-componentsを使うのに必要なstylelint設定集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/emilgoldsmith/stylelint-custom-processor-loader&#34;&gt;stylelint-custom-processor-loader&lt;/a&gt;: stylelintでカスタムプロセッサを使う場合に必要なwebpackのローダ。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D stylelint stylelint-config-standard stylelint-processor-styled-components stylelint-config-styled-components stylelint-custom-processor-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;stylelintの設定は以下。&lt;/p&gt;

&lt;p&gt;stylelint.config.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  processors: [&#39;stylelint-processor-styled-components&#39;],
  extends: [&#39;stylelint-config-standard&#39;, &#39;stylelint-config-styled-components&#39;],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackの設定にstylelint-custom-processor-loaderの設定を追加する。&lt;/p&gt;

&lt;p&gt;webpack.common.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
+      {
+        test: /\.(js|jsx)$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        enforce: &#39;pre&#39;,
+        loader: &#39;stylelint-custom-processor-loader&#39;,
+      },
     ],
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでstyled-componentsにstylelintを適用できた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/&#34;&gt;次回&lt;/a&gt;は&lt;a href=&#34;https://material-ui.com/&#34;&gt;Material-UI&lt;/a&gt;を導入する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その3: PrettierとESLint</title>
          <link>https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/</link>
          <pubDate>Thu, 23 Aug 2018 00:19:09 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/&#34;&gt;前回&lt;/a&gt;はReactをセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;フォーマッタとリンタ&#34;&gt;フォーマッタとリンタ&lt;/h1&gt;

&lt;p&gt;プロジェクトにフォーマッタとリンタを導入する。&lt;/p&gt;

&lt;p&gt;フォーマッタはソースの体裁を整えるツール。
フォーマッタを使うことで体裁が統一され、ソースが読みやすくなり、品質向上につながる。&lt;/p&gt;

&lt;p&gt;リンタはソースを静的解析して、潜在的なバグ、構造的な問題、体裁の問題を検出して警告してくれるツール。
フォーマッタは体裁だけ整えるのに対し、リンタは論理構造にも制約を課せるので、コーディングスタイルがより統一できたり、ミスをしやすい論理構造が無くなったりして、品質向上につながる。&lt;/p&gt;

&lt;p&gt;JavaScriptのような動的型付け言語では、実行時まで顕在化しないバグを作りこみやすく、また実行時エラーの原因解析が静的型付け言語に比べて難しいので、フォーマッタとリンタでプログラム実行前に問題をできるだけ取り除いておくのが重要。
またチーム開発では、コードレビューでコーディンスタイルを見る必要がなくなり、効率化につながる。&lt;/p&gt;

&lt;h2 id=&#34;prettier&#34;&gt;Prettier&lt;/h2&gt;

&lt;p&gt;フォーマッタには&lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;Prettierは&lt;a href=&#34;https://jlongster.com/A-Prettier-Formatter&#34;&gt;2017年1月&lt;/a&gt;にリリースされた新しいツール。
構文解析をして&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8&#34;&gt;AST&lt;/a&gt;を構築し、そこからフォーマット済みコードを出力するので、従来のツールよりも厳密な整形(e.g. 行の最大長を考慮した整形)ができる。&lt;/p&gt;

&lt;p&gt;また、opinionated(独断的)であることも特徴で、Prettierプロジェクトが推奨するフォーマットをほぼ強制し、設定がほとんどない。
このため導入が簡単だけど、かゆいところに手が届かないこともある。&lt;/p&gt;

&lt;p&gt;JavaScriptの他、JSX、CSS、Markdown、GraphQLのフォーマットにも対応している。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;まずプロジェクトにインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D prettier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v1.14.0が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://prettier.io/docs/en/options.html&#34;&gt;設定&lt;/a&gt;は&lt;code&gt;prettier.config.js&lt;/code&gt;という&lt;a href=&#34;https://prettier.io/docs/en/configuration.html&#34;&gt;ファイル&lt;/a&gt;を書いてプロジェクトルートに置けばいい。&lt;/p&gt;

&lt;p&gt;prettier.config.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  printWidth: 100, // 行の最大長
  tabWidth: 2, // インデント長
  singleQuote: true, // 文字列をシングルクオートで囲う
  trailingComma: &#39;all&#39;, // オブジェクトのプロパティとか関数の引数を複数行で書いたときに、全行の末尾にカンマをつける
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、フォーマット対象外のファイルを指定するファイルである&lt;code&gt;.prettierignore&lt;/code&gt;をプロジェクトルートに置く。&lt;/p&gt;

&lt;p&gt;.prettierignore:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node_modules/
dist/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node_modulesはnpmパッケージが入るディレクトリ。
実際はnode_modulesはデフォルトで無視されるから書かなくていいんだけど。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://prettier.io/docs/en/ignore.html&#34;&gt;prettier-ignoreコメント&lt;/a&gt;を書くことで、ソースを部分的にフォーマット対象外とすることもできる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;最後に、npmスクリプトを書く。&lt;/p&gt;

&lt;p&gt;package.json:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   &amp;quot;scripts&amp;quot;: {
+    &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.css&amp;quot;,
     &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
     &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;yarn format&lt;/code&gt;を実行するとプロジェクト内ソースを一通りフォーマットできる。&lt;/p&gt;

&lt;h2 id=&#34;eslint&#34;&gt;ESLint&lt;/h2&gt;

&lt;p&gt;リンタにはデファクトスタンダードの&lt;a href=&#34;https://eslint.org/&#34;&gt;ESLint&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;ESLintは2013年6月にリリースされたそこそこ歴史のあるツール。
リンティングルールがプラガブルで、豊富なルールを細かく制御できるのが特徴。
フォーマッタとしての機能もあるけど、そこはPrettierにまかせることにする。&lt;/p&gt;

&lt;p&gt;JavaScriptもJSXもリンティングできる。&lt;/p&gt;

&lt;p&gt;リンティングルールはAirbnbによる&lt;a href=&#34;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb&#34;&gt;eslint-config-airbnb&lt;/a&gt;が有名なのでこれを使う。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ESLintを導入するために、以下のパッケージをプロジェクトにインストールする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;eslint: ESLint本体。&lt;/li&gt;
&lt;li&gt;eslint-loader: webpackからESLintを実行するやつ。&lt;/li&gt;
&lt;li&gt;eslint-config-airbnb: ESLintルール設定集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/benmosher/eslint-plugin-import&#34;&gt;eslint-plugin-import&lt;/a&gt;: eslint-config-airbnbのピア依存。import文を処理するためのESLintプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/evcohen/eslint-plugin-jsx-a11y&#34;&gt;eslint-plugin-jsx-a11y&lt;/a&gt;: eslint-config-airbnbのピア依存。JSXを処理するためのESLintプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yannickcr/eslint-plugin-react&#34;&gt;eslint-plugin-react&lt;/a&gt;: eslint-config-airbnbのピア依存。React特有のリンティングルールを追加するESLintプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prettier/eslint-config-prettier&#34;&gt;eslint-config-prettier&lt;/a&gt;: Prettierが施すコード整形とコンフリクトするルールを無効にするESLintルール設定集。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ピア依存をインストールするのにはちょっとコツがいるので、&lt;a href=&#34;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb#eslint-config-airbnb-1&#34;&gt;eslint-config-airbnbのドキュメント&lt;/a&gt;を参照すべし。&lt;/p&gt;

&lt;p&gt;今回は以下のコマンドでインストールした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D &amp;quot;eslint@&amp;gt;=1.6.0 &amp;lt;5.0.0&amp;quot; eslint-loader eslint-config-airbnb &amp;quot;eslint-plugin-import@^2.12.0&amp;quot; &amp;quot;eslint-plugin-jsx-a11y@^6.0.3&amp;quot; &amp;quot;eslint-plugin-react@^7.9.1&amp;quot; eslint-config-prettier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESlintはv4.19.1が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eslint.org/docs/user-guide/configuring&#34;&gt;ESlintの設定&lt;/a&gt;は、設定ファイルである&lt;code&gt;.eslintrc.js&lt;/code&gt;をプロジェクトルートに置けばいい。&lt;/p&gt;

&lt;p&gt;.eslintrc.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  env: {
    browser: true,
  },
  extends: [&#39;airbnb&#39;, &#39;prettier&#39;],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アプリの実行環境はブラウザなので&lt;code&gt;env.browser&lt;/code&gt;をtrueにしている。
これにより、ブラウザ環境でデフォルトで使えるグローバル変数(e.g. &lt;code&gt;document&lt;/code&gt;)を使うときにESLintに怒られないようになる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;は&lt;code&gt;eslint-config-airbnb&lt;/code&gt;と&lt;code&gt;eslint-config-prettier&lt;/code&gt;のルール設定を取り込むように書いている。
&lt;code&gt;prettier&lt;/code&gt;が最後でなければいけないことに注意。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://eslint.org/docs/user-guide/configuring#ignoring-files-and-directories&#34;&gt;リンティング対象外のファイルを指定するファイル&lt;/a&gt;をプロジェクトルートに置く。&lt;/p&gt;

&lt;p&gt;.eslintignore:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node_modules/*
dist/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node_modulesはnpmパッケージが入るディレクトリ。
実際はnode_modulesはデフォルトで無視されるから書かなくていいんだけど。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments&#34;&gt;eslint-disableコメント&lt;/a&gt;を書くことで、ソースを部分的にリンティング対象外としたり、特定のルールを無効化することもできる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackからESLintを実行し、エラーがなくならない限りビルド成功できないようにする。&lt;/p&gt;

&lt;p&gt;webpack.common.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   module: {
     rules: [
+      {
+        test: /\.(js|jsx)$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        enforce: &#39;pre&#39;,
+        loader: &#39;eslint-loader&#39;,
+        options: {
+          configFile: &#39;./.eslintrc.js&#39;,
+          failOnError: true,
+        },
       },
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
     ],
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとはnpmスクリプト書くだけ。&lt;/p&gt;

&lt;p&gt;package.json:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   &amp;quot;scripts&amp;quot;: {
     &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.css&amp;quot;,
+    &amp;quot;lint&amp;quot;: &amp;quot;eslint **/*.jsx **/*.js&amp;quot;,
     &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
     &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;yarn lint&lt;/code&gt;を実行するとプロジェクト内ソースを一通りリンティングできる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上で、フォーマッタとリンタを導入できた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/&#34;&gt;次回&lt;/a&gt;はCSS周りの処理系を追加する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その2: React</title>
          <link>https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/</link>
          <pubDate>Wed, 22 Aug 2018 08:21:28 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/&#34;&gt;前回&lt;/a&gt;はNode.jsとYarnとBabelとwebpackをセットアップした。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reactとは&#34;&gt;Reactとは&lt;/h1&gt;

&lt;p&gt;以前にも同じような事を書いたけど、改めてReactについて書く。
ちょっとコーディングの詳細にも触れながら。&lt;/p&gt;

&lt;p&gt;ReactはViewを記述するためのライブラリで、特徴は&lt;a href=&#34;https://reactjs.org/docs/faq-internals.html&#34;&gt;Virtual DOM&lt;/a&gt;と&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;virtual-dom&#34;&gt;Virtual DOM&lt;/h2&gt;

&lt;p&gt;Virtual DOMはDOMを仮想化するもので、JavaScriptからVirtual DOMでUIを記述してやると、それが実DOMに効率的に反映されるようになっている。&lt;/p&gt;

&lt;h2 id=&#34;jsx&#34;&gt;JSX&lt;/h2&gt;

&lt;p&gt;Virtual DOMはJSXというHTMLみたいな言語で記述できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな風に書くと、idが&lt;code&gt;root&lt;/code&gt;であるHTML要素の中に、&lt;code&gt;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;/code&gt;がレンダリングされる。
上記コードの&lt;code&gt;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;/code&gt;の部分がJSX。&lt;/p&gt;

&lt;h2 id=&#34;コンポーネント&#34;&gt;コンポーネント&lt;/h2&gt;

&lt;p&gt;JSXではコンポーネントを定義して新たなタグとして使うことができるので、再利用できるコンポーネントを作って、それらを組み合わせてUIを構築することで、効率的な開発ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// Welcomeコンポーネントの定義
function Welcome() {
  return &amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;;
}

// Welcomeコンポーネントのレンダリング
ReactDOM.render(
  &amp;lt;Welcome /&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記コードではコンポーネントをfunctionで定義しているが、アロー関数で書いても全く一緒。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Welcome = () =&amp;gt; (
  &amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;関数の代わりにclassで定義することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Welcome extends React.Component {
  render() {
    return &amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数による定義とclassによる定義はおおむね変わらないが、&lt;a href=&#34;https://reactjs.org/docs/state-and-lifecycle.html&#34;&gt;stateとライフサイクルメソッド&lt;/a&gt;を使いたいときはclassにする必要がある。&lt;/p&gt;

&lt;h2 id=&#34;props&#34;&gt;props&lt;/h2&gt;

&lt;p&gt;コンポーネントはレンダリングの際に&lt;code&gt;props&lt;/code&gt;というパラメータを受け取って使うことができるので、上手く設計すれば汎用的なコンポーネントが書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// Welcomeコンポーネントの定義 (props付き)
function Welcome(props) {
  return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
}

// Welcomeコンポーネントのレンダリング (props付き)
ReactDOM.render(
  &amp;lt;Welcome name=&amp;quot;Kaitoy&amp;quot; /&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;props&lt;/code&gt;はイミュータブルにしてコンポーネント内で変更しない(i.e. コンポーネントをpureにする)のが定石。&lt;/p&gt;

&lt;h2 id=&#34;prop-types&#34;&gt;prop-types&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/prop-types&#34;&gt;prop-types&lt;/a&gt;を使うと、コンポーネントに渡される&lt;code&gt;props&lt;/code&gt;に期待する型を定義することができる。&lt;/p&gt;

&lt;p&gt;前節で作ったWelcomeコンポーネントの&lt;code&gt;props&lt;/code&gt;の&lt;code&gt;name&lt;/code&gt;はStringオブジェクトを受け取ることを期待するので、prop-typesを以下のように定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Welcome(props) {
  return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
}

Welcome.propTypes = {
  name: PropTypes.string.isRequired,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておくと、実行時に型チェックが走り、型が合わないとコンソールに警告がでるようになる。&lt;/p&gt;

&lt;h1 id=&#34;reactのインストール&#34;&gt;Reactのインストール&lt;/h1&gt;

&lt;p&gt;上記のコードを実行するためのライブラリを一通りプロジェクトに追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add react react-dom prop-types
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reactはv16.4.1が入った。&lt;/p&gt;

&lt;h1 id=&#34;ソース構成&#34;&gt;ソース構成&lt;/h1&gt;

&lt;p&gt;ソースを入れる&lt;code&gt;src&lt;/code&gt;ディレクトリの構成は、&lt;a href=&#34;https://qiita.com/numanomanu/items/af97312f34cf1388cee6#%E5%AE%9F%E9%9A%9B%E3%81%AE%E3%83%97%E3%83%AD%E3%83%80%E3%82%AF%E3%83%88%E3%81%AE%E3%83%95%E3%82%A9%E3%83%AB%E3%83%80%E6%A7%8B%E6%88%90&#34;&gt;Qiitaの記事&lt;/a&gt;を参考に以下のようにする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;react-redux-scaffold/

&lt;ul&gt;
&lt;li&gt;src/

&lt;ul&gt;
&lt;li&gt;actions/&lt;/li&gt;
&lt;li&gt;components/&lt;/li&gt;
&lt;li&gt;containers/&lt;/li&gt;
&lt;li&gt;reducers/&lt;/li&gt;
&lt;li&gt;sagas/&lt;/li&gt;
&lt;li&gt;services/&lt;/li&gt;
&lt;li&gt;index.jsx&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;今のところ使うのは&lt;code&gt;index.jsx&lt;/code&gt;と&lt;code&gt;components&lt;/code&gt;だけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;index.jsx&lt;/code&gt;は&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/#webpack%E8%A8%AD%E5%AE%9A%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB&#34;&gt;前回&lt;/a&gt;書いた通り、webpackが初めにロードするファイル。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;components&lt;/code&gt;にはReactのコンポーネントを入れる。&lt;/p&gt;

&lt;p&gt;その他のディレクトリについては追って説明する。&lt;/p&gt;

&lt;h1 id=&#34;reactコンポーネント作成&#34;&gt;Reactコンポーネント作成&lt;/h1&gt;

&lt;p&gt;最初のReactコンポーネントとして、適当なものを作る。&lt;/p&gt;

&lt;p&gt;components/App.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;

const App = () =&amp;gt; (
  &amp;lt;div&amp;gt;
    HOGE
  &amp;lt;/div&amp;gt;
);

export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、これを&lt;code&gt;index.jsx&lt;/code&gt;でインポートしてレンダリングしてやる。&lt;/p&gt;

&lt;p&gt;src/index.jsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./components/App&#39;;

const root = document.getElementById(&#39;root&#39;);

if (root) {
  ReactDOM.render(
    &amp;lt;App /&amp;gt;,
    root,
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;yarn build&lt;/code&gt;すると&lt;code&gt;dist/bundle.js&lt;/code&gt;が生成される。&lt;/p&gt;

&lt;p&gt;実践的なコンポーネント構成の考え方については、公式の&lt;a href=&#34;https://reactjs.org/docs/thinking-in-react.html&#34;&gt;Thinking in React&lt;/a&gt;が参考になる。&lt;/p&gt;

&lt;h1 id=&#34;htmlファイル作成&#34;&gt;HTMLファイル作成&lt;/h1&gt;

&lt;p&gt;bundle.jsを読み込むHTMLファイルを作る。&lt;/p&gt;

&lt;p&gt;HTMLファイルを書くときは、「&lt;a href=&#34;https://hail2u.net/documents/html-best-practices.html&#34;&gt;普通のHTMLの書き方&lt;/a&gt;」の1～3章とか、「&lt;a href=&#34;https://qiita.com/miya0001/items/8fff46c201bf9eaeba4a&#34;&gt;フロントエンドチェックリスト&lt;/a&gt;」のHead、HTML辺りが参考になる。
まあ開発時にしか使わないだろうから実際は適当でいいし、なんなら&lt;a href=&#34;https://webpack.js.org/plugins/html-webpack-plugin/&#34;&gt;HtmlWebpackPlugin&lt;/a&gt;で自動生成してもいい。&lt;/p&gt;

&lt;p&gt;作るファイルは、&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/#webpack-dev-server%E8%A8%AD%E5%AE%9A&#34;&gt;webpackの設定に書いた&lt;/a&gt;通り、&lt;code&gt;public/index.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;内容は以下。&lt;/p&gt;

&lt;p&gt;public/index.html:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;x-ua-compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;React Redux&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;React Redux Scaffold&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;noscript&amp;gt;
      You need to enable JavaScript to run this app.
    &amp;lt;/noscript&amp;gt;
    &amp;lt;script src=&amp;quot;./bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ポイントは2点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;の最初に&lt;code&gt;id=root&lt;/code&gt;の&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;を書く&lt;/p&gt;

&lt;p&gt;上で書いた&lt;code&gt;index.jsx&lt;/code&gt;で、&lt;code&gt;id&lt;/code&gt;が&lt;code&gt;root&lt;/code&gt;の要素を取得して&lt;code&gt;ReactDOM.render()&lt;/code&gt;に渡しているので、この&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;要素のなかに全てのWeb UIがレンダリングされることになる。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;の最後に&lt;code&gt;&amp;lt;script src=&amp;quot;./bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;を書く&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;要素により、bundle.jsがWebサーバからダウンロードされて実行される。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でReactは一通り。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yarn start&lt;/code&gt;してブラウザで&lt;code&gt;http://localhost:3000&lt;/code&gt;にアクセスするとHOGEと表示されるはず。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/&#34;&gt;次回&lt;/a&gt;はフォーマッタとリンタを導入する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その1: Node.jsとYarnとBabelとwebpack</title>
          <link>https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/</link>
          <pubDate>Sun, 19 Aug 2018 15:27:19 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/</guid>
          <description>

&lt;p&gt;昔、&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo Toolkit&lt;/a&gt;を使ってFlashなUIをJavaScriptに書き換えた時以来、仕事でWeb UIを触ることはなかったんだけど、最近になってWeb UIを書かなければいけなくなるような気がして再学習を始めた。&lt;/p&gt;

&lt;p&gt;題材は&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt; (と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;)。
今一番人気のフロントエンドフレームワークで、&lt;a href=&#34;https://www.kaitoy.xyz/2015/12/21/hello-react/&#34;&gt;昔触ったこともある&lt;/a&gt;ので。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/&#34;&gt;前回の記事でReactが生まれた経緯を学んだ&lt;/a&gt;ので、今回から実習に入る。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;プロジェクト作成&#34;&gt;プロジェクト作成&lt;/h1&gt;

&lt;p&gt;ちょっと&lt;a href=&#34;https://github.com/facebook/create-react-app&#34;&gt;Create React App&lt;/a&gt;を触ってみたけど使わないことにした。
すぐ開発始められるのはよかったんだけど、裏でなにが起こっているかわからな過ぎて肌に合わないし、使うライブラリが結構固定されちゃいそうだったし、トラブルシュート(特にライブラリのバグを踏んだ時)が大変そうだったので。&lt;/p&gt;

&lt;p&gt;代わりに、&lt;a href=&#34;https://reactjs.org/docs/create-a-new-react-app.html#creating-a-toolchain-from-scratch&#34;&gt;公式&lt;/a&gt;で紹介されているブログ記事である&lt;a href=&#34;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&#34;&gt;Creating a React App… From Scratch.&lt;/a&gt;を見ながら、スクラッチからプロジェクトを作ることにした。&lt;/p&gt;

&lt;p&gt;環境はWindows 10 Home。&lt;/p&gt;

&lt;p&gt;最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。&lt;/p&gt;

&lt;h2 id=&#34;node-jsインストール&#34;&gt;Node.jsインストール&lt;/h2&gt;

&lt;p&gt;なにはともあれ&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Node.jsのバージョン管理には以前は&lt;a href=&#34;https://github.com/marcelklehr/nodist&#34;&gt;nodist&lt;/a&gt;使っていたんだけど、こいつは2年ほど前に開発が止まっているので、代わりに&lt;a href=&#34;https://github.com/coreybutler/nvm-windows&#34;&gt;nvm for Windows&lt;/a&gt;を入れた。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nvm install&lt;/code&gt;で任意のバージョンのNode.jsをインストール出来て、&lt;code&gt;nvm use&lt;/code&gt;で使うNode.jsのバージョンを切り替えられる。&lt;/p&gt;

&lt;p&gt;今回使うNode.jsのバージョンは、現時点でLTS版の最新である8.11.4にする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;C:\&amp;gt;nvm install 8.11.4
Downloading node.js version 8.11.4 (64-bit)...
Complete
Creating C:\Users\kaitoy\AppData\Roaming\nvm\temp

Downloading npm version 5.6.0... Complete
Installing npm v5.6.0...

Installation complete. If you want to use this version, type

nvm use 8.11.4

C:\&amp;gt;nvm use 8.11.4
Now using node v8.11.4 (64-bit)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;yarnインストール&#34;&gt;Yarnインストール&lt;/h2&gt;

&lt;p&gt;パッケージマネージャには&lt;a href=&#34;https://yarnpkg.com/lang/ja/&#34;&gt;Yarn&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;Yarnちょっとバギーだとか、npm 5がlockファイルをサポートしてYarnの優位性が減ったとか、&lt;a href=&#34;https://github.com/mixmaxhq/deyarn&#34;&gt;Yarnからnpmに戻るためのツール&lt;/a&gt;が出てきたりしてるけど、現時点では深く考えずにYarnでいいと思う。&lt;/p&gt;

&lt;p&gt;YarnはWindows環境ではMSIファイルを&lt;a href=&#34;https://yarnpkg.com/ja/docs/install#windows-stable&#34;&gt;ダウンロード&lt;/a&gt;して実行すればインストールできる。&lt;/p&gt;

&lt;p&gt;(npmでもインストールできるけど邪道。)&lt;/p&gt;

&lt;p&gt;Yarnはv1.7.0を使う。&lt;/p&gt;

&lt;h2 id=&#34;package-json生成&#34;&gt;package.json生成&lt;/h2&gt;

&lt;p&gt;プロジェクトの構成情報を記述するファイルであるpackage.jsonをYarnで生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;C:\&amp;gt;mkdir react-redux-scaffold

C:\&amp;gt;cd react-redux-scaffold

C:\react-redux-scaffold&amp;gt;yarn init
yarn init v1.7.0
question name (react-redux-scaffold):
question version (1.0.0):
question description: React Redux Scaffold
question entry point (index.js): src/index.jsx
question repository url: https://github.com/kaitoy/react-redux-scaffold.git
question author: kaitoy
question license (MIT):
question private:
success Saved package.json
Done in 40.38s.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できたのがこれ。&lt;/p&gt;

&lt;p&gt;package.json:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;react-redux-scaffold&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;React Redux Scaffold&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;src/index.jsx&amp;quot;,
  &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/kaitoy/react-redux-scaffold.git&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;kaitoy&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以降、カレントディレクトリは&lt;code&gt;C:\react-redux-scaffold&lt;/code&gt;として、プロンプト表示は省略する。&lt;/p&gt;

&lt;h1 id=&#34;ビルド環境セットアップ&#34;&gt;ビルド環境セットアップ&lt;/h1&gt;

&lt;p&gt;ビルド環境としてトランスパイラとかモジュールバンドラとかをセットアップする。&lt;/p&gt;

&lt;h2 id=&#34;babel&#34;&gt;Babel&lt;/h2&gt;

&lt;p&gt;トランスパイラはデファクトスタンダードの&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;Babelのプラグインはとりあえず最低限入れるとして、以下のnpmパッケージをプロジェクトにインストールする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/en/babel-core&#34;&gt;babel-core&lt;/a&gt;: Babel本体。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/en/babel-preset-react&#34;&gt;babel-preset-react&lt;/a&gt;: Reactの&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;とか&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;とかを処理するプラグイン集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/en/babel-preset-env&#34;&gt;babel-preset-env&lt;/a&gt;: ES 2015+をES 5にトランスパイルするプラグイン集。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのパッケージは実行時には要らないので&lt;code&gt;yarn add -D&lt;/code&gt;コマンドで開発時依存としてインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D babel-core babel-preset-react babel-preset-env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Babelは6.26.3が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、Babelの&lt;a href=&#34;https://babeljs.io/docs/en/babelrc&#34;&gt;設定ファイル&lt;/a&gt;を書いてプロジェクトルートに置いておく。&lt;/p&gt;

&lt;p&gt;.babelrc:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;presets&amp;quot;: [&amp;quot;env&amp;quot;, &amp;quot;react&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;polyfill&#34;&gt;Polyfill&lt;/h2&gt;

&lt;p&gt;BabelはES 2015+で追加された構文の変換はしてくれるけど、追加されたグローバルオブジェクト(e.g. &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;)とかメソッド(e.g. Object.assignとかArray.prototype.includes)とかを補完してくれるわけではない。
そこを補完してくれるのが&lt;a href=&#34;https://en.wikipedia.org/wiki/Polyfill_%28programming%29&#34;&gt;Polyfill&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;少なくとも後で導入する&lt;a href=&#34;https://redux-saga.js.org/&#34;&gt;redux-saga&lt;/a&gt;が使う&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/function*&#34;&gt;ジェネレータ&lt;/a&gt;がPolyfillを必要とする(ないと&lt;code&gt;ReferenceError: regeneratorRuntime is not defined&lt;/code&gt;というエラーが出る)ので、今の時点で入れておくことにする。&lt;/p&gt;

&lt;p&gt;Polyfillの実装はいくつかあるけど、定番っぽい&lt;a href=&#34;https://babeljs.io/docs/en/babel-polyfill/&#34;&gt;babel-polyfill&lt;/a&gt;を使う。
こちらは実行時依存としてインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add babel-polyfill
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;webpack&#34;&gt;webpack&lt;/h2&gt;

&lt;p&gt;モジュールバンドラは現時点で一番人気の&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;を使う。
(&lt;a href=&#34;https://parceljs.org/&#34;&gt;Parcel&lt;/a&gt;の方がナウいはナウいけど。)&lt;/p&gt;

&lt;p&gt;webpackは、タスクランナーの機能も備えたモジュールバンドラみたいな感じで、バンドルしたいファイルの形式とか実行したいタスクに応じた&lt;a href=&#34;https://webpack.js.org/loaders/&#34;&gt;ローダー&lt;/a&gt;を設定することでプロジェクトのビルドを定義できる。&lt;/p&gt;

&lt;p&gt;ちょっと古いけど&lt;a href=&#34;https://qiita.com/chuck0523/items/caacbf4137642cb175ec&#34;&gt;この記事&lt;/a&gt;を読むとwebpackの理解が深まる。&lt;/p&gt;

&lt;p&gt;こちらもとりあえず最低限のローダーをセットアップするとして、以下のnpmパッケージをプロジェクトにインストールする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;webpack: webpack本体。&lt;/li&gt;
&lt;li&gt;webpack-cli: webpackのコマンドラインインターフェース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpack/webpack-dev-server&#34;&gt;webpack-dev-server&lt;/a&gt;: webpackから起動できる開発用 HTTP サーバ。ライブリロードしてくれる。(&lt;a href=&#34;https://github.com/webpack-contrib/webpack-serve&#34;&gt;webpack-serve&lt;/a&gt;の方がモダンではある。)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.js.org/loaders/babel-loader/&#34;&gt;babel-loader&lt;/a&gt;: Babelを実行してくれるやつ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D webpack webpack-cli webpack-dev-server babel-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpackはv4.16.0が入った。&lt;/p&gt;

&lt;h3 id=&#34;webpack設定ファイル&#34;&gt;webpack設定ファイル&lt;/h3&gt;

&lt;p&gt;webpackの設定は&lt;a href=&#34;https://webpack.js.org/configuration/&#34;&gt;設定ファイル&lt;/a&gt;を書いてプロジェクトルートに置けばいい。
設定は結構複雑だけど、v1の時よりかは若干書きやすくなったし、公式のマニュアルとかローダーのマニュアル見てれば書くのは難しくない。
&lt;a href=&#34;https://generatewebpackconfig.netlify.com/&#34;&gt;設定ファイルを生成してくれるサイト&lt;/a&gt;もある。&lt;/p&gt;

&lt;p&gt;とりあえず適当に書くとこんな感じ。&lt;/p&gt;

&lt;p&gt;webpack.config.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const packageJson = require(&#39;./package.json&#39;);

module.exports = {
  mode: &#39;development&#39;,
  entry: [&#39;babel-polyfill&#39;, `./${packageJson.main}`],
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;,
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        include: [path.resolve(__dirname, &#39;src&#39;)],
        loader: &#39;babel-loader&#39;,
      },
    ],
  },
  resolve: {
    extensions: [&#39;*&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
    modules: [&#39;node_modules&#39;],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定の意味は、&lt;code&gt;./src/index.jsx&lt;/code&gt;を読んで、&lt;code&gt;.js&lt;/code&gt;か&lt;code&gt;.jsx&lt;/code&gt;を拡張子としたファイルとかモジュールをロードするコードがあったら、babel-loaderでBabelを呼んでトランスパイルして、バンドルした結果は&lt;code&gt;&amp;lt;プロジェクトルート&amp;gt;/dist/bundle.js&lt;/code&gt;に吐き出す。
というだけ。
(&lt;a href=&#34;https://nodejs.org/docs/latest/api/modules.html#modules_dirname&#34;&gt;__dirname&lt;/a&gt;はNode.jsが値を入れてくれる変数で、webpack.config.jsのあるディレクトリの絶対パスが入ってる。)&lt;/p&gt;

&lt;p&gt;ファイルをロードするコードというのは、&lt;code&gt;import App from &#39;./components/App&#39;;&lt;/code&gt;みたいなやつ。
webpackはこのコードを読んだら、&lt;code&gt;./components&lt;/code&gt;ディレクトリのなかを見て、&lt;code&gt;App&lt;/code&gt;か&lt;code&gt;App.js&lt;/code&gt;か&lt;code&gt;App.jsx&lt;/code&gt;というファイルを探してロードする。
また、モジュールをロードするコードというのは&lt;code&gt;import React from &#39;react&#39;;&lt;/code&gt;みたいなやつで、webpackはこのコードを読んだら、プロジェクトの&lt;code&gt;node_modules/react/package.json&lt;/code&gt;の&lt;code&gt;main&lt;/code&gt;プロパティの値に書いてあるファイルをロードする。
という挙動が上記webpack.config.jsの&lt;code&gt;resolve&lt;/code&gt;に書いてあって、その詳細は&lt;a href=&#34;https://webpack.js.org/concepts/module-resolution/&#34;&gt;公式のドキュメントのModule Resolution&lt;/a&gt;に書いてある。&lt;/p&gt;

&lt;p&gt;webpack.config.jsの&lt;code&gt;entry&lt;/code&gt;には、最初に&lt;code&gt;babel-polyfill&lt;/code&gt;を書いておいて、bundle.jsの最初に一度だけPolyfillがロードされるようにしている。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;は後述。&lt;/p&gt;

&lt;h3 id=&#34;webpack-dev-server設定&#34;&gt;webpack-dev-server設定&lt;/h3&gt;

&lt;p&gt;webpack-dev-serverの設定もwebpack.config.jsに書く。&lt;/p&gt;

&lt;p&gt;以下を&lt;code&gt;resolve&lt;/code&gt;の次辺りに書き足せばいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  devServer: {
    contentBase: path.join(__dirname, &#39;public&#39;),
    compress: true,
    hot: true,
    port: 3000,
    publicPath: &#39;http://localhost:3000/&#39;,
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この設定でwebpack-dev-serverを実行すると、&lt;code&gt;http://localhost:3000/&lt;/code&gt;へのアクセスに&lt;code&gt;public/index.html&lt;/code&gt;を返すWebサーバを起動できる。
Webサーバが起動するときにプロジェクトがインメモリでビルドされ、メモリからbundle.jsがサーブされる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hot&lt;/code&gt;をtrueにしておくと&lt;a href=&#34;https://webpack.js.org/concepts/hot-module-replacement/&#34;&gt;Hot Module Replacement&lt;/a&gt;が有効になる。
これによって、webpack-dev-serverの起動中にソースを編集すると、自動で再ビルドし、動的にモジュール単位でロードし、ブラウザをリロードしてくれるようになる。
Hot Module Replacementを有効にするときは&lt;code&gt;publicPath&lt;/code&gt;をフルURLで書かないといけない。&lt;/p&gt;

&lt;p&gt;webpack-dev-serverの他の設定については&lt;a href=&#34;https://webpack.js.org/configuration/dev-server/&#34;&gt;公式のマニュアルのDevServer&lt;/a&gt;を見るべし。&lt;/p&gt;

&lt;h3 id=&#34;webpackのmode&#34;&gt;webpackのmode&lt;/h3&gt;

&lt;p&gt;webpackにはビルドの&lt;a href=&#34;https://webpack.js.org/concepts/#mode&#34;&gt;mode&lt;/a&gt;という概念があり、modeを切り替えることで適切な最適化を適用してくれる。&lt;/p&gt;

&lt;p&gt;modeにはdevelopmentとproduction(とnone)があり、productionにしておくと、&lt;a href=&#34;https://webpack.js.org/plugins/uglifyjs-webpack-plugin/&#34;&gt;UglifyJsPlugin&lt;/a&gt;とかを適用して、出力するバンドルファイルのサイズを小さくしてくれたりする。
(v1のころはUglifyJsPluginとかは全部自分でwebpack.config.jsに指定していた記憶があるので、楽になった。)&lt;/p&gt;

&lt;h3 id=&#34;webpack-config-jsの分割&#34;&gt;webpack.config.jsの分割&lt;/h3&gt;

&lt;p&gt;modeを切り替えるのにwebpack.config.jsを書き換えるのはイケてないので、developmentとproductionでファイルを分割して使い分けるようにする。&lt;/p&gt;

&lt;p&gt;developmentとproductionはほとんどが共通の設定なので、共通部分をwebpack.common.jsに書いて、developmentとproductionに固有な設定だけをそれぞれwebpack.dev.jsとwebpack.prod.jsに書く。
webpack.common.jsは、&lt;a href=&#34;https://github.com/survivejs/webpack-merge&#34;&gt;webpack-merge&lt;/a&gt;でwebpack.dev.jsとwebpack.prod.jsにマージする。
というのが&lt;a href=&#34;https://webpack.js.org/guides/production/&#34;&gt;公式&lt;/a&gt;で紹介されているプラクティス。&lt;/p&gt;

&lt;p&gt;まずwebpack-mergeをプロジェクトにインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D webpack-merge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分割したファイルは以下の感じ。全部プロジェクトルートに置いておく。&lt;/p&gt;

&lt;p&gt;webpack.common.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const packageJson = require(&#39;./package.json&#39;);

module.exports = {
  entry: [&#39;babel-polyfill&#39;, `./${packageJson.main}`],
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;,
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        include: [path.resolve(__dirname, &#39;src&#39;)],
        loader: &#39;babel-loader&#39;,
      },
    ],
  },
  resolve: {
    extensions: [&#39;*&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
    modules: [&#39;node_modules&#39;],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpack.dev.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const webpackMerge = require(&#39;webpack-merge&#39;);
const webpackCommon = require(&#39;./webpack.common.js&#39;);

module.exports = webpackMerge(webpackCommon, {
  mode: &#39;development&#39;,
  devServer: {
    contentBase: path.join(__dirname, &#39;public&#39;),
    compress: true,
    hot: true,
    port: 3000,
    publicPath: &#39;http://localhost:3000/&#39;,
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpack.prod.js&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const webpackMerge = require(&#39;webpack-merge&#39;);
const webpackCommon = require(&#39;./webpack.common.js&#39;);

module.exports = webpackMerge(webpackCommon, {
  mode: &#39;production&#39;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;npmスクリプト&#34;&gt;npmスクリプト&lt;/h3&gt;

&lt;p&gt;webpackによるビルドは次のコマンドで実行できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;node_modules\.bin\webpack --config webpack.prod.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、webpack-dev-serverは次のコマンドで起動できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;node_modules\.bin\webpack-dev-server --hot --config webpack.dev.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--hot&lt;/code&gt;はHot Module Replacementに必要なオプション。&lt;/p&gt;

&lt;p&gt;コマンドが長くて面倒なのは、&lt;a href=&#34;https://docs.npmjs.com/misc/scripts&#34;&gt;npmスクリプト&lt;/a&gt;で楽にできる。
package.jsonの&lt;code&gt;main&lt;/code&gt;の次辺りに以下を書き足せばいい。
(npmスクリプトは実行時に&lt;code&gt;node_modules\.bin&lt;/code&gt;にPATHを通してくれるので、それを省略できる。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
    &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておくと、&lt;code&gt;yarn build&lt;/code&gt;でビルド、&lt;code&gt;yarn start&lt;/code&gt;でwebpack-dev-server起動できる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でビルド環境セットアップはいったん完了とする。
&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/&#34;&gt;次回&lt;/a&gt;はReactが動くところらへんまで。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Webアプリケーションフロントエンド年代記 - 2018年夏編</title>
          <link>https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/</link>
          <pubDate>Thu, 16 Aug 2018 23:44:39 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/</guid>
          <description>

&lt;p&gt;Webアプリケーションの、主にフロントエンド周りに関連する歴史をまとめた。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;静的サイト&#34;&gt;静的サイト&lt;/h1&gt;

&lt;p&gt;まずは原初の話から。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1990年代前半&lt;/strong&gt;、まだWebアプリケーションという言葉が無かった時代。
静的にHTMLファイルを配信するだけのWebサイト(静的サイト)だけがあった。
静的サイトでは、HTTPサーバーに複数のHTMLファイルを置いておいて、クライアントのHTTPリクエストのURLのパスによって配信するHTMLファイルを変える。&lt;/p&gt;

&lt;p&gt;例えば、HTTPサーバーを&lt;a href=&#34;https://httpd.apache.org/&#34;&gt;httpd&lt;/a&gt;で立てて、ドキュメントルートを&lt;code&gt;/var/www/html&lt;/code&gt;に設定して、以下のようにファイルを配置したとする。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/var/www/html/
    |
    +-- index.html
    |
    +-- sub/
          |
          +-- hoge.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この場合、ブラウザで&lt;code&gt;http://&amp;lt;HTTPサーバアドレス&amp;gt;/index.html&lt;/code&gt;にアクセスすれば&lt;code&gt;/var/www/html/index.html&lt;/code&gt;が配信されてレンダリングされて表示される。
&lt;code&gt;http://&amp;lt;HTTPサーバアドレス&amp;gt;/sub/hoge.html&lt;/code&gt;にアクセスすれば&lt;code&gt;/var/www/html/sub/hoge.html&lt;/code&gt;が配信される。&lt;/p&gt;

&lt;p&gt;古のWebサイトは、こんな感じにコンテンツごとにHTMLファイルを書いてサーバに置いておいて、その間にリンクを張って辿れるようにすることで構成されていた。&lt;/p&gt;

&lt;p&gt;まあ今も大体そんな感じだけど。&lt;/p&gt;

&lt;h1 id=&#34;動的html生成-プログラムでhtmlを書き出す&#34;&gt;動的HTML生成 (プログラムでHTMLを書き出す)&lt;/h1&gt;

&lt;p&gt;静的サイトだと表現できることが非常に限られるので、クライアントからのリクエストの内容をサーバが解釈し、DBの情報やなんかをもとにサーバ側でHTMLドキュメントを動的に生成し、クライアントに返す、ということをするようになった。&lt;/p&gt;

&lt;p&gt;原始的(&lt;strong&gt;1990年代中盤から後半&lt;/strong&gt;)には、プログラム中で一連のHTMLドキュメントを出力する方法がとられた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void doGet(
  HttpServletRequest request, HttpServletResponse response
) throws IOException, ServletException {

  response.setContentType(&amp;quot;text/html;&amp;quot;);
  PrintWriter out = response.getWriter();

  out.println(&amp;quot;&amp;lt;html&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;head&amp;gt;&amp;quot;);
  out.println(&amp;quot;    &amp;lt;title&amp;gt;Hoge&amp;lt;/title&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;/head&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;body&amp;gt;&amp;quot;);
  out.println(new java.util.Date());
  out.println(&amp;quot;  &amp;lt;/body&amp;gt;&amp;quot;);
  out.println(&amp;quot;&amp;lt;/html&amp;gt;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使われた技術は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Common_Gateway_Interface&#34;&gt;CGI&lt;/a&gt; (Perl)とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java_Servlet&#34;&gt;Java Servlet&lt;/a&gt;とか。
&lt;a href=&#34;http://jakarta.apache.org/ecs/index.html&#34;&gt;Jakarta ECS&lt;/a&gt;なんてのもあった。&lt;/p&gt;

&lt;h1 id=&#34;動的html生成-htmlにプログラムを埋め込む&#34;&gt;動的HTML生成 (HTMLにプログラムを埋め込む)&lt;/h1&gt;

&lt;p&gt;プログラムでHTMLを書き出すことにより、かなり動的な感じにはなったが、書き出す処理を書くのがめんどくさすぎるし、読みにくい。
そのため、&lt;strong&gt;1990年代後半から2000年代初頭&lt;/strong&gt; にかけ、HTMLを主体にして、そのなかの動的な部分だけにプログラムを埋め込む技術がいくつも生まれた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html %&amp;gt;

&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hoge&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%
    out.println(new java.util.Date());
    %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTMLドキュメントのひな型を作っておいて、その中にプログラムの処理結果を埋め込んでクライアントに返すため、テンプレートエンジンとか、テンプレートシステムとか呼ばれる。&lt;/p&gt;

&lt;p&gt;該当する技術は、&lt;a href=&#34;http://www.php.net/&#34;&gt;PHP&lt;/a&gt;とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/JavaServer_Pages&#34;&gt;JSP&lt;/a&gt;とか、&lt;a href=&#34;http://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/ERuby&#34;&gt;eRuby&lt;/a&gt;とか。&lt;/p&gt;

&lt;h1 id=&#34;dhtml&#34;&gt;DHTML&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1990年代後半&lt;/strong&gt;、クライアントサイドのJavaScriptでHTMLドキュメントをいじって、多少の動的感・インタラクティブ感をだす技術は既に一応あって、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%83%8A%E3%83%9F%E3%83%83%E3%82%AFHTML&#34;&gt;DHTML&lt;/a&gt;と呼ばれていた。&lt;/p&gt;

&lt;p&gt;DHTMLの肝はJavaScriptの&lt;a href=&#34;https://ja.wikipedia.org/wiki/Document_Object_Model&#34;&gt;DOM&lt;/a&gt; APIだ。
このAPIでは、HTML文書が各要素(タグなど)をノードとするツリー構造(DOMツリー)で表され、任意の要素を検索して取得したり、属性などを書き換えたり、要素の追加・削除ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;hogehoge&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
      // idがhogehogeの要素の子要素として「&amp;lt;p&amp;gt;HOGEEEEEEE&amp;lt;/p&amp;gt;」を追加。
      document.getElementById(&amp;quot;hogehoge&amp;quot;).innerHTML = &amp;quot;&amp;lt;p&amp;gt;HOGEEEEEEE&amp;lt;/p&amp;gt;&amp;quot;
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、このころのJavaScriptは、仕様・機能が貧弱だった上、ブラウザ間で挙動に差があったり、標準メソッドがブラウザ固有のメソッドで代替されていたりして開発体験が最悪だったためか、今日のようにWeb UIの中心的役割を果たすことはなく、補助的・装飾的機能の実装に使われることが多かったように思う。&lt;/p&gt;

&lt;p&gt;アクセスした日付を表示したり、背景に雪を降らせたり、マウスカーソルを目玉に追いかけさせたり。&lt;/p&gt;

&lt;h1 id=&#34;mvcアーキテクチャ&#34;&gt;MVCアーキテクチャ&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2000年初頭&lt;/strong&gt;、&lt;a href=&#34;http://struts.apache.org/&#34;&gt;Struts&lt;/a&gt; (Struts1)というJavaのWebアプリケーションフレームワークが流行り、Controller (Java Servlet)がクライアントからリクエストを受け取り、Model (JavaBeans)がそれを処理して、View (JSP)がHTMLをレンダリングしてクライアントに返す、という、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_Controller&#34;&gt;MVCアーキテクチャ&lt;/a&gt;が流行った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/500px-MVC-Process.svg.png&#34; alt=&#34;MVC&#34; title=&#34;MVC&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Strutsに続いて&lt;a href=&#34;https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html&#34;&gt;Spring MVC&lt;/a&gt;、&lt;a href=&#34;https://rubyonrails.org/&#34;&gt;Ruby on Rails&lt;/a&gt;、&lt;a href=&#34;https://cakephp.org/jp&#34;&gt;CakePHP&lt;/a&gt;といったフレームワークが出てきて、MVCアーキテクチャによる開発効率や開発体験は洗練されていった。&lt;/p&gt;

&lt;h1 id=&#34;ajax&#34;&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Strutsが全盛期の&lt;strong&gt;2005年&lt;/strong&gt;ころ、JavaScriptで非同期にサーバからデータを取得し、それをもとにクライアントサイドでHTMLを動的に編集するような技術に、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Ajax&#34;&gt;Ajax&lt;/a&gt;という名前が付いた。&lt;/p&gt;

&lt;p&gt;Ajaxは「Asynchronous JavaScript + XML」の略で、&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest&#34;&gt;XMLHttpRequest&lt;/a&gt; (略してXHR)というJavaScriptのAPIで
、サーバにHTTPリクエストを送り、そのレスポンスを非同期に処理する技術。
レスポンスは、当時XMLが流行っていたので、その形式で送ることが想定されていたが、実際にはどんな形式でもいい。はず。
最近はJSONで送られることがほとんど。&lt;/p&gt;

&lt;p&gt;JavaScriptはシングルスレッドで動くわけだけど、XMLHttpRequestはレスポンスを非同期に処理するため、リクエスト送信からレスポンス受信までの間、クライアントがスタックせずに済む。
また、通常のHTTPリクエストは、完全なHTMLドキュメントを受信して画面全体をレンダリングしなおす(i.e. 画面遷移する)のに対して、Ajaxは受信したデータをもとに画面の一部だけを更新するので、ネイティブアプリケーションに近めなユーザエクスペリエンスを実現できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var xhr = new XMLHttpRequest();
xhr.open(&#39;GET&#39;, &#39;https://httpbin.org/get&#39;, true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 &amp;amp;&amp;amp; xhr.status === 200) {
    console.log(xhr.responseText);
    // DOMをいじる処理
    // …
  }
};
xhr.send(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ajaxは、GoogleがGoogle Mapsで活用して一気に注目を集めた。
地図データをサーバから非同期に先読みするなどして、マウスのドラッグによって地図を滑らかにスクロールして見せるそのUIは当時画期的で、それまでの、画面遷移中心のUIからの飛躍を感じさせた。&lt;/p&gt;

&lt;h1 id=&#34;prototypeとjquery&#34;&gt;PrototypeとjQuery&lt;/h1&gt;

&lt;p&gt;Ajaxの普及を後押ししたのが、&lt;a href=&#34;http://prototypejs.org/&#34;&gt;Prototype&lt;/a&gt;と&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;というJavaScriptライブラリの登場だった。&lt;/p&gt;

&lt;p&gt;PrototypeはRubyにインスパイアされて開発され、Ruby on Railsに採用されたことで&lt;strong&gt;2005年&lt;/strong&gt;ころから普及したライブラリで、JavaScriptの標準グローバルオブジェクトであるArrayとかElementに便利メソッドを生やしたり、独自のグローバルユーティリティオブジェクトを追加したりして、Ajax処理をしやすくしたり、JavaScriptの機能を拡張してくれたりする。&lt;/p&gt;

&lt;p&gt;特に、当時のプロトタイプベースで使いにくかったJavaScriptのオブジェクト指向を扱いやすくしてくれる&lt;a href=&#34;http://prototypejs.org/learn/class-inheritance&#34;&gt;Class&lt;/a&gt;や、配列の処理に便利なeachとかmapとかincludeとかのメソッドを追加する&lt;a href=&#34;http://api.prototypejs.org/language/Enumerable/&#34;&gt;Enumerable&lt;/a&gt;なんかが熱かったように思う。&lt;/p&gt;

&lt;p&gt;一方jQueryは、ファーストバージョンが&lt;strong&gt;2006年8月&lt;/strong&gt;にリリースされ、ブラウザ間の非互換性をほとんど気にすることなく、簡潔なコードでDOM操作やAjax通信ができるAPIを提供した。
Prototypeと比べて、標準オブジェクトやグローバル名前空間を汚さない点がよかったのか、&lt;strong&gt;2007年&lt;/strong&gt; ころにはPrototypeを抜いて猛烈に普及した。&lt;/p&gt;

&lt;p&gt;この頃からWebアプリケーションは、UIはクライアントサイドのJavaScriptでインタラクティブな感じに書いて、サーバサイドはXMLHttpRequestに対してJSONデータを返すAPIサーバとして働く、という感じのものが増えていったように思う。
またこの頃から、クライアントサイドの開発が量質ともに上がったために独立した仕事になり、サーバサイドと対比して、前者をフロントエンド、後者をバックエンドと呼ぶようになってきた。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;因みに、PrototypeやjQueryと同様というかもう少し高機能な&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo Toolkit&lt;/a&gt;というライブラリが&lt;strong&gt;2004年&lt;/strong&gt;ころからあったんだけど、あまり流行らなかった。
カスタムビルドという、モジュールを結合してminifyする&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;みたいな機能を、&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js&lt;/a&gt;もない時代に実現していた先進的なライブラリだったんだけど、時代がついてこれなかったのかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;ria-flashとか&#34;&gt;RIA (Flashとか)&lt;/h1&gt;

&lt;p&gt;WebアプリケーションにはAjaxと別の世界線もあった。&lt;/p&gt;

&lt;p&gt;そこでは&lt;strong&gt;1997年&lt;/strong&gt;ころに&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%83%E3%83%81%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;RIA (Rich Internet Application)&lt;/a&gt;という言葉が生まれた。
これは、クライアントサイドの技術を駆使した、表現力やユーザビリティが高いWebアプリケーションのこと。&lt;/p&gt;

&lt;p&gt;(実際にはAjaxなアプリもこのくくりに入るが、ここでは非Web標準なクライアントサイド技術を使ったものの話を書く。)&lt;/p&gt;

&lt;p&gt;RIA技術の代表格である&lt;a href=&#34;https://ja.wikipedia.org/wiki/Adobe_Flash&#34;&gt;Flash&lt;/a&gt;は&lt;strong&gt;1996年&lt;/strong&gt;に生まれた。
このころはShockwave FlashとかMacromedia Flashとか呼ばれたが、開発元が&lt;strong&gt;2005年&lt;/strong&gt;にAdobeに買収されてAdobe Flashになり、そのあたりから&lt;strong&gt;2010年代前半&lt;/strong&gt;辺りまで最先端のWeb UI技術として甚だしく流行った。&lt;/p&gt;

&lt;p&gt;Flashは、&lt;a href=&#34;https://www.adobe.com/jp/products/flex.html&#34;&gt;Flex&lt;/a&gt;というフレームワーク(ツール?)のもと、&lt;a href=&#34;https://ja.wikipedia.org/wiki/ActionScript&#34;&gt;ActionScript&lt;/a&gt;というJavaScriptっぽいプログラミング言語と、&lt;a href=&#34;https://ja.wikipedia.org/wiki/MXML&#34;&gt;MXML&lt;/a&gt;というXMLなUI記述言語を駆使してWeb UIを開発できる技術。
WebブラウザにAdobe Flash PlayerとかAdobe AIRのプラグインを入れると表示できる。&lt;/p&gt;

&lt;p&gt;Flashの人気に触発されたのか、Microsoftが&lt;strong&gt;2007年&lt;/strong&gt;に&lt;a href=&#34;https://www.microsoft.com/silverlight/&#34;&gt;Silverlight&lt;/a&gt;というのをリリースした。
これは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/.NET_Framework&#34;&gt;.NET Framework&lt;/a&gt;な言語(&lt;a href=&#34;https://docs.microsoft.com/ja-jp/dotnet/csharp/&#34;&gt;C#&lt;/a&gt;とか&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/cc427807.aspx&#34;&gt;JScript&lt;/a&gt;とか)と、&lt;a href=&#34;https://docs.microsoft.com/ja-jp/dotnet/framework/wpf/advanced/xaml-overview-wpf&#34;&gt;XAML&lt;/a&gt;というHTMLっぽいUI記述言語を駆使してWeb UIを開発できる技術。
WebブラウザにMicrosoft Silverlightプラグインを入れると表示できる。&lt;/p&gt;

&lt;p&gt;また、Flashの誕生とほぼ同時期に、JavaでWebアプリケーションのUIを書く&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java%E3%82%A2%E3%83%97%E3%83%AC%E3%83%83%E3%83%88&#34;&gt;Java Applet&lt;/a&gt;というのも生まれていた。が、初期のバージョンでロードに時間がかかったり動作が重かったりする問題があり、嫌厭されてFlashほど流行らなかった。
WebブラウザにJavaプラグインを入れると表示できる。
なぜか最近になって、&lt;strong&gt;2017年&lt;/strong&gt; 公開のマイナンバーのポータルサイトで採用されて話題になった。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;こうした非Web標準技術を使ったRIAは、Ajaxに比べてリッチな表現ができたり、ブラウザ間の非互換性に悩まされないところに優位性があったが、以下のような問題があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;プロプライエタリな技術をベースにしていて、実装がブラックボックスだったり、仕様の方向性がベンダの都合に左右されたり、ベンダロックインされやすかったりする。&lt;/li&gt;
&lt;li&gt;ユーザがブラウザにプラグインをいれてないと表示されない。&lt;/li&gt;
&lt;li&gt;セキュリティ問題が見つかった場合、オープンな技術のものに比べて対策が遅い傾向があるし、ベンダによる実装しかないので替えが利かない。&lt;/li&gt;
&lt;li&gt;他ベンダの技術や標準技術との親和性が無かったり、連携が弱かったりする。&lt;/li&gt;
&lt;li&gt;ブラウザ内で文字列検索ができなかったり、検索エンジンにまともにクローリングしてもらえない。&lt;/li&gt;
&lt;li&gt;動作が重い。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;このような問題のためか、Web標準周辺技術の発展に伴い、一時期は隆盛を誇ったFlashなども次第に廃れていった。&lt;/p&gt;

&lt;p&gt;Flashは&lt;strong&gt;2020年&lt;/strong&gt;に、Silverlightは&lt;strong&gt;2021年&lt;/strong&gt;にサポート終了になり、Java Appletは&lt;strong&gt;2018年9月&lt;/strong&gt;に出るJava 11で廃止されることが決まっている。&lt;/p&gt;

&lt;h1 id=&#34;html-5とcss-3とecmascript-5&#34;&gt;HTML 5とCSS 3とECMAScript 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2000年代中盤&lt;/strong&gt; から非Web標準なRIAが流行ったのは、そもそもWeb標準技術であるHTML、CSS、JavaScript(というかその標準仕様を定める&lt;a href=&#34;https://ja.wikipedia.org/wiki/ECMAScript&#34;&gt;ECMAScript&lt;/a&gt;)が、アプリケーションのUIを作るという目的で設計されているわけではなく、それらを使ってWeb UIを作ることに限界があったのが一因だったと思う。&lt;/p&gt;

&lt;p&gt;RIAの流行を受け、Web標準業界に危機感が募ったのか、&lt;strong&gt;2000年代後半&lt;/strong&gt; くらいからWeb標準技術にWeb UIを意識したバージョンアップの動きが始まった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/html/html5_intro.asp&#34;&gt;HTML 5&lt;/a&gt;の勧告 (&lt;strong&gt;2014年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるHTML 4.01の勧告が&lt;strong&gt;1999年&lt;/strong&gt;だったので、&lt;strong&gt;15年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;文書構造を表すタグの追加: &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;とか&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;図を表現するためのタグの追加: &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;inputタイプの追加: &lt;code&gt;date&lt;/code&gt;、&lt;code&gt;range&lt;/code&gt;、&lt;code&gt;email&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;inputタグの属性の追加: &lt;code&gt;autocomplete&lt;/code&gt;、&lt;code&gt;pattern&lt;/code&gt;、&lt;code&gt;placeholder&lt;/code&gt;、&lt;code&gt;required&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;マルチメディアのためのタグの追加:&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Webアプリケーション向けAPI追加: Drag and Drop、Local Storage、Web Workerとか。&lt;/li&gt;
&lt;li&gt;冗長だったり見た目に関するタグ・属性の削除: &lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;とか&lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt;とか&lt;code&gt;border&lt;/code&gt;とか&lt;code&gt;color&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data-*&lt;/code&gt;属性のサポート。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/CSS3&#34;&gt;CSS 3&lt;/a&gt;の勧告 (&lt;strong&gt;2011年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるCSS 2の勧告が&lt;strong&gt;1998年&lt;/strong&gt;だったので、&lt;strong&gt;13年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;角丸、シャドウ、グラデーションのサポート。&lt;/li&gt;
&lt;li&gt;セレクタの機能追加: 属性値の部分マッチ、nth-childなど。&lt;/li&gt;
&lt;li&gt;メディアクエリ。&lt;/li&gt;
&lt;li&gt;Flexboxレイアウト、Gridレイアウト。&lt;/li&gt;
&lt;li&gt;Webフォント。&lt;/li&gt;
&lt;li&gt;トランジション、トランスフォーム、アニメーション。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/js/js_es5.asp&#34;&gt;ECMAScript 5&lt;/a&gt;の発行 (&lt;strong&gt;2009年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるECMAScript 3の勧告が&lt;strong&gt;1999年&lt;/strong&gt;だったので、&lt;strong&gt;10年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;strictモード。&lt;/li&gt;
&lt;li&gt;Arrayのメソッド追加: forEach、map、filterなど。&lt;/li&gt;
&lt;li&gt;Objectのメソッド追加: keys、freezeなど。&lt;/li&gt;
&lt;li&gt;グローバルオブジェクトにJSONが追加。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第1世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第1世代)&lt;/h1&gt;

&lt;p&gt;Web標準技術が進化して表現力が上がり、ECMAScript 5やjQueryによってロジックを書きやすくなり、人々がWeb UIをバリバリ書けるようになり、RIAの影響もあってUIの複雑化が進んだ。&lt;/p&gt;

&lt;p&gt;UIが複雑化すると、ユーザ入力の処理、Ajaxによるサーバとのデータ通信、UIの状態の取得、DOMの操作なんかを、何の秩序も構造化もレイヤー分けもなくナイーブにコーディングするのが辛くなってきた。&lt;/p&gt;

&lt;p&gt;この辛みに対処すべく誕生してきたのが数多のJavaScriptフロントエンドフレームワーク。
&lt;strong&gt;2018年現在&lt;/strong&gt; まで続くフロントエンドフレームワーク戦国時代の幕開けである。&lt;/p&gt;

&lt;p&gt;フロントエンドフレームワークは大抵以下のような機能を提供してくれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UI(View)の記述を楽にする何か。テンプレートエンジンとか。&lt;/li&gt;
&lt;li&gt;Viewに表示しているデータとJavaScriptプログラムで保持しているデータを紐づける仕組み。(i.e. &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0&#34;&gt;データバインディング&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ajaxユーティリティ。&lt;/li&gt;
&lt;li&gt;URLをViewやロジックと紐づける仕組み。(i.e. URLルーティング)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;フロントエンドフレームワーク戦国時代初期に生まれた主要なフロントエンドフレームワークを列挙する。&lt;/p&gt;

&lt;p&gt;(この記事では便宜上第1世代と呼ぶ。)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://knockoutjs.com/&#34;&gt;Knockout&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVMアーキテクチャ&lt;/a&gt;。

&lt;ul&gt;
&lt;li&gt;ModelがUIと独立してデータ(Ajaxでサーバから取ったものなど)を保持する。&lt;/li&gt;
&lt;li&gt;ViewModelがUIに紐づくデータとその操作を表現する。&lt;/li&gt;
&lt;li&gt;ViewはDOMツリー。ViewModelへの変更は自動でViewに反映されるし、その逆もしかり。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://backbonejs.org/&#34;&gt;Backbone.js&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;主にModelとViewからなるMVC的アーキテクチャ。

&lt;ul&gt;
&lt;li&gt;Modelはデータとビジネスロジックを表現する。

&lt;ul&gt;
&lt;li&gt;サーバから取ってきたデータを保持。&lt;/li&gt;
&lt;li&gt;ビジネスロジックによってデータが変わると、イベントを生成。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewがModelをDOMに反映する。

&lt;ul&gt;
&lt;li&gt;ModelからのイベントをlistenしてDOMに反映。&lt;/li&gt;
&lt;li&gt;ユーザからの入力を取得して、Modelに渡す。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.emberjs.com/&#34;&gt;Ember.js&lt;/a&gt; v1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2011年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;URLルーティングをコアとするコンセプトが特徴的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2012年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Google製。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;DIやテストなどのサポートまであるフルスタックフレームワーク。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第1世代は、フロントエンドの世界にMVCアーキテクチャ(とその派生)をもたらした。&lt;/p&gt;

&lt;p&gt;このMVCは、Struts時代のMVCとは違い、完全にクライアントサイドに閉じたアーキテクチャだ。
サーバ側はエントリーポイントとしてHTML(とCSSとJavaScript)をサーブするほかは、JSONを返すAPIサーバとしての役割に徹する。
このようなWebアプリケーションは、ページ遷移が発生せず、単一ページだけでUIが構成されるので、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%AB%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;Single Page Application (SPA)&lt;/a&gt;と呼ばれる。&lt;/p&gt;

&lt;p&gt;ModelとViewとの間でのデータの同期の仕方には以下のように2方向がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;M⇒V: Modelを更新すると対応するViewが自動で更新される。&lt;/li&gt;
&lt;li&gt;V⇒M: Viewがユーザ入力などによって変更されるとModelが自動で更新される。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者だけをするのが1-wayバインディングで、両方するのが2-wayバインディング。
上に挙げた中では、Backbone.js以外が2-wayバインディング推しで、このころは2-wayバインディングが正義だったっぽい。&lt;/p&gt;

&lt;h1 id=&#34;commonjs-node-js-パッケージマネージャ-モジュールバンドラ-altjs-altcss-トランスパイラ-タスクランナー&#34;&gt;CommonJS、Node.js、パッケージマネージャ、モジュールバンドラ、AltJS、AltCSS、トランスパイラ、タスクランナー&lt;/h1&gt;

&lt;p&gt;第1世代のフロントエンドフレームワークが出始めたころ、JavaScriptの言語周りの環境にも大きな変化があった。
正直書くの辛くなってきたので、一気に片付ける。&lt;/p&gt;

&lt;h3 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h3&gt;

&lt;p&gt;クライアントサイドでJavaScriptが盛り上がっているのを見て、もっとJavaScriptいろんなところで活用できるんじゃね?
となって、ブラウザの外でも普通のプログラミング言語としてJavaScriptを使うためには、どんな機能を追加すべきか、みたいな議論をするプロジェクトが&lt;strong&gt;2009年&lt;/strong&gt;に立ち上がった。
&lt;a href=&#34;http://www.commonjs.org/&#34;&gt;CommonJS&lt;/a&gt;である。&lt;/p&gt;

&lt;p&gt;CommonJSの最大の功績は多分、モジュールシステムを言語仕様でちゃんとサポートしよう、と言ったこと。
モジュールシステムは、Cでいうincludeとか、JavaやPythonのimportとか、そういう機能。
JavaScriptにはもともとそういうのが無くて、単にファイルを分割して個別にロードしていただけだったので、名前空間がコンフリクトしたりしなかったりしてた。&lt;/p&gt;

&lt;p&gt;因みに、JavaScriptのモジュールシステムには、CommonJSのやつ以外にも&lt;a href=&#34;https://en.wikipedia.org/wiki/Asynchronous_module_definition&#34;&gt;AMD&lt;/a&gt;というのがあったけど、そっちは盛り上がらなかった。&lt;/p&gt;

&lt;h3 id=&#34;node-js&#34;&gt;Node.js&lt;/h3&gt;

&lt;p&gt;CommonJSの流れを汲んで、サーバサイドのJavaScriptランタイムとして&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt;が&lt;strong&gt;2009年&lt;/strong&gt;にリリースされた。
これにより、ブラウザ外でJavaScriptを実行できるようになり、以降のJavaScript開発体験の劇的な改善につながった。&lt;/p&gt;

&lt;h3 id=&#34;パッケージマネージャ&#34;&gt;パッケージマネージャ&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2010年&lt;/strong&gt; には、Node.jsにパッケージマネージャとして&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;が同梱されるようになった。
これにより、モジュールを公開してシェアして再利用する文化が定着し、JavaScriptプログラムの開発効率や品質がかなり向上したはず。&lt;/p&gt;

&lt;p&gt;パッケージマネージャとしてはもうひとつ、&lt;a href=&#34;https://bower.io/&#34;&gt;Bower&lt;/a&gt;というのが&lt;strong&gt;2012年&lt;/strong&gt;に出た。
npmはサーバサイドのパッケージ、Bowerはクライアントサイドのパッケージ、みたいな住みわけが当初はあったが、最近は全部npmになってBower使ってるプロジェクトは見なくなった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2016年10月&lt;/strong&gt; には、Facebookが&lt;a href=&#34;https://yarnpkg.com/lang/ja/&#34;&gt;Yarn&lt;/a&gt;というnpmを代替するツールを&lt;a href=&#34;https://code.fb.com/web/yarn-a-new-package-manager-for-javascript/&#34;&gt;発表&lt;/a&gt;。
パッケージバージョンのロック、&lt;a href=&#34;https://twitter.com/madbyk/status/988795520805203969?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E988795520805203969&amp;amp;ref_url=https%3A%2F%2Fblog.risingstack.com%2Fyarn-vs-npm-node-js-package-managers%2F&#34;&gt;CDN (CloudFlare)&lt;/a&gt;・キャッシュ・並列処理によるパッケージダウンロードの高速化、パッケージ間のバージョンの不整合解消(フラットモード)、といった機能により、発表直後から急速にシェアを伸ばした。&lt;/p&gt;

&lt;h3 id=&#34;モジュールバンドラ&#34;&gt;モジュールバンドラ&lt;/h3&gt;

&lt;p&gt;サーバサイドでモジュールシステムができたのはよかったけど、その仕様がブラウザでサポートされることは終ぞなかった。
ので、モジュールバンドラというものが生まれた。
これは、ソース中のモジュールインポート(requireとかimport)をたどって、モジュール分割されたソースをブラウザが読めるように一つに結合してくれるツール。&lt;/p&gt;

&lt;p&gt;モジュールバンドラのパイオニアが、&lt;strong&gt;2011年&lt;/strong&gt; にリリースされた&lt;a href=&#34;http://browserify.org/&#34;&gt;Browserify&lt;/a&gt;。
Browserifyは、モジュールの結合だけでなく、Node.js特有のAPIをある程度ブラウザでも動くようにしてくれるなど、魔法のようなツールだった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2012年&lt;/strong&gt; には&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;というモジュールバンドラが出て、後述のトランスパイラと上手く連携したり、JavaScriptだけでなくCSSもHTMLもフォントも画像ファイルもなんでもバンドルできる高機能により、Browserifyを食った。&lt;/p&gt;

&lt;p&gt;モジュールバンドルすると、ファイルサイズが大きくなって、ブラウザでロードするのに時間がかかって、初期画面の表示が遅くなる問題があった。
&lt;strong&gt;2015年&lt;/strong&gt;、その問題を軽減すべく、&lt;a href=&#34;https://rollupjs.org/guide/en&#34;&gt;Rollup&lt;/a&gt;というのが出てきた。
Rollupは、&lt;a href=&#34;https://rollupjs.org/guide/en#tree-shaking&#34;&gt;Tree-shaking&lt;/a&gt;という機能で、バンドル時に不要なコードを削除することでファイルサイズを小さくできることを売りにした。
が、webpackがバージョン2でTree-shakingをサポートしたため、使う理由がなくなった。&lt;/p&gt;

&lt;p&gt;webpackは機能的には最高にクールだったが、設定が複雑で設定ファイルが肥大化するという問題があった。
この問題を解消すべく、&lt;strong&gt;2017年末&lt;/strong&gt; に&lt;a href=&#34;https://parceljs.org/&#34;&gt;Parcel&lt;/a&gt;というモジュールバンドラがリリースされ、ゼロ設定で使えるということで人気を集めてきている。
今の時点でプロダクションレディなレベルなのかは疑問。&lt;/p&gt;

&lt;h3 id=&#34;altjs&#34;&gt;AltJS&lt;/h3&gt;

&lt;p&gt;上に書いた通り、&lt;strong&gt;2009年&lt;/strong&gt; にECMAScript 5が発行されて、JavaScriptは若干改善されたわけだけど、はっきり言ってまだまだ貧弱な言語だった。
そこに&lt;a href=&#34;https://coffeescript.org/&#34;&gt;CoffeeScript&lt;/a&gt;が登場。
&lt;strong&gt;2009年末&lt;/strong&gt; のことだった。&lt;/p&gt;

&lt;p&gt;CoffeeScriptは、RubyやPythonみたいな簡潔で機能的な構文を備えた生産性の高い言語で、JavaScriptにコンパイルできる。
クラス構文とか、アロー関数とか、配列内包表記とか、インデントによるブロック構造とかを実現してて書き心地がかなりよかったのと、Ruby on Railsに採用されたというのもあって、&lt;strong&gt;2010年代中盤&lt;/strong&gt; くらいまで結構流行った。&lt;/p&gt;

&lt;p&gt;CoffeeScriptのように、JavaScriptの代替として使い、JavaScriptに変換して実行するのを主なユースケースとする言語を、AltJS (Alternative JavaScript)と呼ぶ。
CoffeeScriptの最大の功績は、このAltJSという分野を切り開き、JavaScriptフロントエンドにコンパイルという概念を持ち込んだことだったと思う。&lt;/p&gt;

&lt;p&gt;CoffeeScript自体はその後、&lt;strong&gt;2015年&lt;/strong&gt; に発行されたECMAScript 2015がその仕様を取り込んだことで役目を終えた。
&lt;strong&gt;2017年9月&lt;/strong&gt; に&lt;a href=&#34;https://coffeescript.org/announcing-coffeescript-2/&#34;&gt;バージョン2をアナウンス&lt;/a&gt;して再起を図ったが、そのころすでに他に有力なAltJSが出てたし、ECMAScriptも結構成熟してきてたし、あまり注目されなかった。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;AltJSには他に以下のようなものがあるが、ほぼTypeScriptしか使われてなさそう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2012年10月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Microsoft製。&lt;/li&gt;
&lt;li&gt;静的型付けが最大の特徴で、他にもクラスやアロー関数やレキシカル変数などをサポート。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.purescript.org/&#34;&gt;PureScript&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年4月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;強い静的型付けの関数型言語。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dartlang.org/&#34;&gt;Dart&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2011年10月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Google製。&lt;/li&gt;
&lt;li&gt;全く流行らなかったし、Google自身も社内標準プログラミング言語にTypeScriptを採用したので、だれも使ってなくてよくわからない。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2018年8月&lt;/strong&gt; にバージョン2がリリースされ、再起を図ってはいる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jsx.github.io/&#34;&gt;JSX&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;DeNA製。&lt;/li&gt;
&lt;li&gt;名前がReactの&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;と紛らわしい。&lt;/li&gt;
&lt;li&gt;誰も使ってないし、&lt;strong&gt;2014年&lt;/strong&gt; くらいから開発止まってる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;altcss&#34;&gt;AltCSS&lt;/h3&gt;

&lt;p&gt;CSSにもalternativesがある。
というかAltJSよりも歴史が古い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sass-lang.com/&#34;&gt;Sass&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2006年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;SASS記法とSCSS記法がある。&lt;/li&gt;
&lt;li&gt;AltCSSでは1番人気っぽい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lesscss.org/&#34;&gt;Less&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2009年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Sassに感銘を受けたけど、そのSASS記法がCSSと違いすぎてちょっと、と思った人がCSSに寄せて作った。けどSassもCSSに寄せたSCSS記法をサポートしたため食われた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stylus-lang.com/&#34;&gt;Stylus&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://postcss.org/&#34;&gt;PostCSS&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;正確にはAltCSSではなく、CSSを処理するツールをJavaScriptで開発できるフレームワーク。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://preset-env.cssdb.org/&#34;&gt;PostCSS Preset Env&lt;/a&gt;というプラグインとともに使うと、CSSのエッジな機能を使えるようになる。つまりどちらかといえば後述のトランスパイラに近い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;トランスパイラ&#34;&gt;トランスパイラ&lt;/h3&gt;

&lt;p&gt;CoffeeScriptの流行などを受けて、ECMAScriptに再び改善の圧力がかかったのか、&lt;strong&gt;2011年後半&lt;/strong&gt; ころから次期ECMAScriptの議論が活発化した。
&lt;strong&gt;2015年&lt;/strong&gt; に満を持してECMAScript 6改めECMAScript 2015が発行された。&lt;/p&gt;

&lt;p&gt;ECMAScript 2015は、クラス構文、アロー関数、レキシカル変数、定数、関数のデフォルト引数、ジェネレータ、テンプレート文字列、モジュールシステムなどをサポートし、一気にまともなプログラミング言語になった。&lt;/p&gt;

&lt;p&gt;しかし、それらの新しい機能をアプリケーションに使うには、各社のブラウザのJavaScriptエンジンが実装して、さらにその実装したバージョンのブラウザがユーザに十分に行きわたるのを待たないといけない。
ECMAScriptの新機能は、正式に発行される前から仕様が公開され、ブラウザが先行して実装してはいくものの、&lt;a href=&#34;http://threevirtues.com/&#34;&gt;プログラマは短気&lt;/a&gt;なのでそんなの待ってられない。&lt;/p&gt;

&lt;p&gt;といった状況のなか、&lt;strong&gt;2014年10月&lt;/strong&gt; に&lt;a href=&#34;https://www.npmjs.com/package/6to5&#34;&gt;6to5&lt;/a&gt;というツールがnpmで公開された。
ECMAScript 6で書かれたコードをECMAScript 5なコードに変換してくれる、トランスパイラというツールだった。&lt;/p&gt;

&lt;p&gt;(実はトランスパイラとしては&lt;strong&gt;2013年3月&lt;/strong&gt;に公開されたGoogle製の&lt;a href=&#34;https://github.com/google/traceur-compiler&#34;&gt;Traceur&lt;/a&gt;とか、&lt;strong&gt;2014年4月&lt;/strong&gt; に公開されたEmber.jsチーム製の&lt;a href=&#34;https://esnext.github.io/esnext/&#34;&gt;esnext&lt;/a&gt;のほうが先駆けだったんだけど、6to5の開発スピードがとんでもなく早く、&lt;strong&gt;2015年1Q&lt;/strong&gt; には機能面で両者を抜いてしまったらしい。)&lt;/p&gt;

&lt;p&gt;6to5は&lt;strong&gt;2015年2月&lt;/strong&gt;に名前を&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;に&lt;a href=&#34;https://babeljs.io/blog/2015/02/15/not-born-to-die&#34;&gt;変えて&lt;/a&gt;、単に6to5という名前が示す機能だけでなく、JavaScript周りの様々なツールを開発・統合するためのプラットフォームとなった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2018年現在&lt;/strong&gt;、Babel無しでフロントエンド開発をすることはほぼ無さそうな感じになってる。&lt;/p&gt;

&lt;h3 id=&#34;タスクランナー&#34;&gt;タスクランナー&lt;/h3&gt;

&lt;p&gt;モジュールバンドラやら、AltJSやら、AltCSSやらで、フロントエンドにコンパイルとかビルドとかいう作業が必要になって来たため、この業界にも必然的にタスクランナーが登場してきた。&lt;/p&gt;

&lt;p&gt;タスクランナーというのは、他業界ではビルドツールなどとも呼ばれているもので、Cとかで使われる&lt;a href=&#34;https://ja.wikipedia.org/wiki/Make&#34;&gt;Make&lt;/a&gt;とか、Javaの&lt;a href=&#34;https://ant.apache.org/&#34;&gt;Ant&lt;/a&gt;とか&lt;a href=&#34;https://maven.apache.org/&#34;&gt;Maven&lt;/a&gt;とか&lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt;とか、Googleの&lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;とかと同様のもの。&lt;/p&gt;

&lt;p&gt;まず、&lt;strong&gt;2012年1月&lt;/strong&gt; に&lt;a href=&#34;https://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;がリリースされて人気を博した。
が、当時のGruntの設定ファイルがJSONで&lt;a href=&#34;http://monmon.hatenablog.com/entry/2013/12/20/151321&#34;&gt;書きにくい&lt;/a&gt;とか、処理がシーケンシャルで遅いとかいう不満が潜在的に溜まっていった。&lt;/p&gt;

&lt;p&gt;で、それらの問題を払拭する&lt;a href=&#34;https://gulpjs.com/&#34;&gt;gulp&lt;/a&gt;が&lt;strong&gt;2013年7月&lt;/strong&gt;に出て、Gruntを食った。&lt;/p&gt;

&lt;p&gt;けど結局、Gruntもgulpも、タスクの処理をどこかの馬の骨が作ったプラグインに頼っていて不安定で、またビルドツールというレイヤが増えたせいでビルドエラーのデバッグがし辛くなるという&lt;a href=&#34;https://qiita.com/chuck0523/items/dafdbd19c12efd40e2de&#34;&gt;根本的な問題が顕在化&lt;/a&gt;し、&lt;a href=&#34;https://docs.npmjs.com/misc/scripts&#34;&gt;npm-scripts&lt;/a&gt;でいいじゃん、ってなった。&lt;/p&gt;

&lt;p&gt;シンプルイズベスト。&lt;/p&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第2世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第2世代)&lt;/h1&gt;

&lt;p&gt;前章で書いたフロントエンド界の変容の後あたりに、当時の先端技術を取り入れて誕生したフロントエンドフレームワークを、この記事では第2世代と呼ぶ。&lt;/p&gt;

&lt;p&gt;第2世代は第1世代から正統な進化を遂げた感じで、あいかわらずMVW (i.e. MV*)だった。
主要なのは以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; v1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年12月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Googleのエンジニア(個人)製。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mizchi.hatenablog.com/entry/2014/02/13/153742&#34;&gt;軽量AngularJS&lt;/a&gt;な感じらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://aurelia.io/&#34;&gt;Aurelia&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年11月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSっぽいフルスタックフレームワークで、EcmaScript 2015+とかWeb Componentsとかの先端技術を取り入れていることが売り。&lt;/li&gt;
&lt;li&gt;2-wayバインディング推しで、あまり流行らなかった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://riot.js.org/&#34;&gt;Riot&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年6月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSもReactも複雑すぎ。フロントエンド開発に必要十分なコンパクトな機能を提供するぜ、というフレームワーク。&lt;/li&gt;
&lt;li&gt;Aureliaよりかは使われていそう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/&#34;&gt;Angular&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年9月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSの後継。AngularJSとの互換性をばっさり切り捨てる代わりに、アーキテクチャを刷新し、性能面と機能面の&lt;a href=&#34;https://medium.com/@mnemon1ck/why-you-should-not-use-angularjs-1df5ddf6fc99&#34;&gt;色々な問題&lt;/a&gt;を克服したらしい。&lt;/li&gt;
&lt;li&gt;が、Reactが画期的過ぎてAngularJSの栄光は取り戻せなかった。&lt;/li&gt;
&lt;li&gt;最初2-wayバインディングまで切り捨てたが、あとで復活させた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;react-virtual-dom&#34;&gt;React (Virtual DOM)&lt;/h1&gt;

&lt;p&gt;第1世代から流行っていた2-wayバインディングがちょっと&lt;a href=&#34;https://stackoverflow.com/questions/35379515/why-is-two-way-databinding-in-angularjs-an-antipattern&#34;&gt;辛みを帯びてきた&lt;/a&gt;。
というか、2-wayバインディングしかできないAngularJSが辛くなってきたということだったのかもしれない。&lt;/p&gt;

&lt;p&gt;2-wayバインディングには以下のような問題があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;変更をwatchするオブジェクトが増えて、性能が悪くなる。&lt;/li&gt;
&lt;li&gt;ModelとViewとの間の依存やデータの流れが複雑になって、コーディングやデバッグが難しくなる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これに異を唱えて登場してきたのがFacebookによる&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;。
&lt;strong&gt;2013年3月&lt;/strong&gt; のことであった。&lt;/p&gt;

&lt;p&gt;2-wayバインディングもMVCもテンプレートも要らんとして、代わりにReactが突きつけてきた&lt;a href=&#34;https://reactjs.org/docs/faq-internals.html&#34;&gt;Virtual DOM&lt;/a&gt;という解は、世界中の人々の&lt;a href=&#34;https://qiita.com/mizchi/items/4d25bc26def1719d52e6&#34;&gt;魂を震えさせた&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Virtual DOMは、その名の通りDOMの仮想化であり、JavaScriptからReactのAPIを通してDOMのようなものを更新すると、Reactがいい感じに実DOMを更新してくれるというもの。
開発者は深く考えずに、イベントが発生するごとに、ページ全体を表すDOMツリーがどうなっているべきかをReactに教えるだけでいい。
あとはReactが、現在の実DOMとの差分を計算し、差分だけを性能よく更新してくれる。
これによって開発者は、DOMの状態やイベントの種類をみてアドホックに実DOMやModelの更新処理を書くという苦行から解放され、宣言的に&lt;a href=&#34;http://blog.neleid.com/2016/04/05/%E5%AF%8C%E8%B1%AA%E7%9A%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E6%AD%BB%E8%AA%9E%E3%81%8B/&#34;&gt;富豪的に&lt;/a&gt;フロントエンドプログラミングができるようになった。&lt;/p&gt;

&lt;p&gt;さらに&lt;strong&gt;2014年5月&lt;/strong&gt;、Reactにベストマッチするアプリケーションアーキテクチャとして&lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;Flux&lt;/a&gt;が発表された。
これは単方向のデータフローが特徴のアーキテクチャで、斬新でかっこよくて未来だった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/flux/raw/master/docs/img/flux-diagram-white-background.png&#34; alt=&#34;Flux&#34; title=&#34;Flux&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第3世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第3世代)&lt;/h1&gt;

&lt;p&gt;React後、Virtual DOMの実装がいくつも出てきた。
&lt;a href=&#34;https://github.com/Matt-Esch/virtual-dom&#34;&gt;virtual-dom&lt;/a&gt;とか&lt;a href=&#34;https://maquettejs.org/&#34;&gt;Maquette&lt;/a&gt;とか&lt;a href=&#34;https://preactjs.com/&#34;&gt;Preact&lt;/a&gt;とか&lt;a href=&#34;https://infernojs.org/&#34;&gt;Inferno&lt;/a&gt;とか。&lt;/p&gt;

&lt;p&gt;Fluxの実装も、Facebook自身による&lt;a href=&#34;https://github.com/facebook/flux&#34;&gt;Flux&lt;/a&gt;のほか、&lt;a href=&#34;http://fluxxor.com/&#34;&gt;Fluxxor&lt;/a&gt;とか&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;とか&lt;a href=&#34;https://mobx.js.org/&#34;&gt;MobX&lt;/a&gt;とか沢山出た。&lt;/p&gt;

&lt;p&gt;で、React+Reduxがいい感じってなって、&lt;a href=&#34;https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d&#34;&gt;世界の8割近くの人がReactで書くようになって&lt;/a&gt;、猫も杓子もVirtual DOMってなった辺りのフロントエンドフレームワークを第3世代と呼ぶことにする。&lt;/p&gt;

&lt;p&gt;第3世代としては以下が挙げられる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://grommet.io/&#34;&gt;Grommet&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年6月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;HPE製。&lt;/li&gt;
&lt;li&gt;Reactと&lt;a href=&#34;https://github.com/inuitcss/inuitcss&#34;&gt;inuitcss&lt;/a&gt;によるフレームワーク。&lt;/li&gt;
&lt;li&gt;全然流行ってないけど&lt;a href=&#34;http://grommet.io/docs/components&#34;&gt;コンポーネント&lt;/a&gt;の取り揃えがよくて結構いいような気がする。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://emberjs.com/blog/2015/08/13/ember-2-0-released.html&#34;&gt;Ember.js v2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年8月&lt;/strong&gt; リリース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://glimmerjs.com/&#34;&gt;Glimmer&lt;/a&gt;というレンダリングエンジンを搭載。

&lt;ul&gt;
&lt;li&gt;Glimmerは、テンプレートをGlimmer VM上で動くバイトコードにコンパイルして、実DOMを速くレンダリングしてくれるもの。&lt;/li&gt;
&lt;li&gt;Virtual DOMとは違う感じだけど、実DOMの更新を開発者の代わりにやってくれるあたり、目指しているものは同じ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://jp.vuejs.org/2016/10/01/here-2.0/&#34;&gt;Vue.js v2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年10月&lt;/strong&gt; リリース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/snabbdom/snabbdom&#34;&gt;snabbdom&lt;/a&gt;ベースのVirtual DOM実装を搭載。&lt;/li&gt;
&lt;li&gt;2017年頭位からかなりの勢いで流行ってきている。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hyperapp.js.org/&#34;&gt;Hyperapp&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2017年1月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/&#34;&gt;Qiita&lt;/a&gt;で働いてるエンジニアが趣味で作ったフレームワークで、Qiitaに採用された。&lt;/li&gt;
&lt;li&gt;超軽量(1KB!)で、シンプルが売り。&lt;/li&gt;
&lt;li&gt;独自のVirtual DOM実装であるPicodom(現&lt;a href=&#34;https://github.com/jorgebucaran/superfine&#34;&gt;superfine&lt;/a&gt;)を搭載。&lt;/li&gt;
&lt;li&gt;JSXにも対応。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://dojo.io/&#34;&gt;Dojo&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2018年5月&lt;/strong&gt; 正式版リリース。&lt;/li&gt;
&lt;li&gt;Dojo Toolkitの後継。&lt;/li&gt;
&lt;li&gt;Virtual DomでTypeScriptでリアクティブでフルスタック。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;終わりに&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2018年8月現在&lt;/strong&gt; では、React vs Vue.js vs Angularといった感じで、激動の時代が過ぎてやや落ち着いて来ている感があるが、油断はできない。
実際、最近&lt;a href=&#34;http://elm-lang.org/&#34;&gt;Elm&lt;/a&gt;という関数型AltJS兼Frontendフレームワークがじわじわ盛り上がってきている感じがあり、一波乱あるかもしれない。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;いろいろ書いたけど、&lt;a href=&#34;https://electronjs.org/&#34;&gt;Electron&lt;/a&gt;とか&lt;a href=&#34;https://facebook.github.io/react-native/&#34;&gt;React Native&lt;/a&gt;とか&lt;a href=&#34;https://nextjs.org&#34;&gt;Next.js&lt;/a&gt;とかの&lt;a href=&#34;https://jp.vuejs.org/v2/guide/ssr.html&#34;&gt;SSR&lt;/a&gt;とか&lt;a href=&#34;https://www.gatsbyjs.org/&#34;&gt;Gatsby.js&lt;/a&gt;とか&lt;a href=&#34;https://graphql.org/learn/&#34;&gt;GraphQL&lt;/a&gt;とか&lt;a href=&#34;https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/?hl=ja&#34;&gt;PWA&lt;/a&gt;とか&lt;a href=&#34;https://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;とか&lt;a href=&#34;https://aws.amazon.com/jp/getting-started/serverless-web-app/&#34;&gt;サーバーレス&lt;/a&gt;とか&lt;a href=&#34;https://kuroeveryday.blogspot.com/2017/03/css-structure-and-rules.html&#34;&gt;CSS設計手法&lt;/a&gt;とかCSSフレームワークとかいろいろ書き漏れた。&lt;/p&gt;

&lt;p&gt;フロントエンドのユニットテストとかE2Eテストとかもいろいろあって面白い。
(E2Eテストは&lt;a href=&#34;https://www.kaitoy.xyz/2017/08/04/browser-test-framework/&#34;&gt;前に書いた&lt;/a&gt;。)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;年表も気が向いたら追加したい。&lt;/p&gt;

&lt;p&gt;しかし&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/&#34;&gt;React+Reduxに再入門したよ、っていう記事&lt;/a&gt;の前座として書くつもりだったのに、ずいぶん長編になってしまった…&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
