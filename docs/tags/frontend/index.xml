<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>To Be Decided </title>
    <link>https://www.kaitoy.xyz/tags/frontend/</link>
    <language>en-us</language>
    <author>Kaito Yamada</author>
    <rights>(C) 2018</rights>
    <updated>2018-11-26 16:09:14 &#43;0900 JST</updated>

    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その11: FlowからTypeScriptへ移行</title>
          <link>https://www.kaitoy.xyz/2018/11/26/creating-react-redux-app-from-scratch-11/</link>
          <pubDate>Mon, 26 Nov 2018 16:09:14 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/11/26/creating-react-redux-app-from-scratch-11/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/07/creating-react-redux-app-from-scratch-10/&#34;&gt;前回&lt;/a&gt;は&lt;a href=&#34;https://reactjs.org/docs/code-splitting.html&#34;&gt;Code Splitting&lt;/a&gt;、&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;、&lt;a href=&#34;https://jestjs.io/ja/&#34;&gt;Jest&lt;/a&gt;、&lt;a href=&#34;https://airbnb.io/enzyme/&#34;&gt;Enzyme&lt;/a&gt;をセットアップした。&lt;/p&gt;

&lt;p&gt;前回でこのシリーズを終わりにするつもりだったけど、型システムをFlowから&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;に移行したのでそれについて書く。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;typescript&#34;&gt;TypeScript&lt;/h1&gt;

&lt;p&gt;TypeScriptはMicrosoft製のAltJS。
もともとは&lt;a href=&#34;https://coffeescript.org/&#34;&gt;CoffeeScript&lt;/a&gt;のように言語の機能面(e.g. class構文やアロー関数)を補強しつつ、静的型付けをサポートする言語だったが、最近はECMAScriptが前者をカバーしてるので、後者を主な目的として使う人が多い。&lt;/p&gt;

&lt;p&gt;2012年に誕生した言語で、同様に静的型付けをサポートするFlowよりも2歳ほど年上。&lt;/p&gt;

&lt;h1 id=&#34;typescript-vs-flow&#34;&gt;TypeScript vs Flow&lt;/h1&gt;

&lt;p&gt;個人的には、静的型付けだけを目的にするならAltJSである必要はなく、静的型付けだけを補完するFlowのほうが筋がいいような気がする。
TypeScriptはECMAScriptの進化に追従すべく、追加される機能や構文をサポートするためのエンハンスを繰り返しているが、そこはBabelに任せて静的型付けに注力したらいいような。&lt;/p&gt;

&lt;p&gt;とはいえ、以下のような点を鑑み、結局TypeScriptを選択した。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;TypeScriptの方が人気

&lt;ul&gt;
&lt;li&gt;GitHubのプロジェクトのスター数はTypeScriptが4万超えでFlowが2万弱。&lt;/li&gt;
&lt;li&gt;観測している限り、FlowからTypeScriptへ移行したというのは聞くが、逆は聞かない。&lt;/li&gt;
&lt;li&gt;人気があるということはコミュニティやエコシステムが大きいということ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TypeScriptがノってる

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/babel/babylon/pull/523&#34;&gt;Babel&lt;/a&gt;や&lt;a href=&#34;https://github.com/facebook/create-react-app/pull/4837&#34;&gt;Create React App&lt;/a&gt;がTypeScriptをサポートして来ていて、なんだか時流にのっている。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Flowは型定義ファイルの管理方法が微妙

&lt;ul&gt;
&lt;li&gt;Flowはflow-typedという専用のツールを使ってファイルをダウンロードし、ダウンロードしたものをGitとかのVCSでバージョン管理するというやりかた。&lt;/li&gt;
&lt;li&gt;TypeScriptはnpmで管理されてるので、Yarnでダウンロードもバージョン管理もできる。VCSのリポジトリに自前のコードしか入れないで済むのもいい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TypeScriptの方が型定義ファイルが沢山提供されてる

&lt;ul&gt;
&lt;li&gt;Flowの10倍くらいある。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TypeScriptの方がエラーメッセージが分かりやすい

&lt;ul&gt;
&lt;li&gt;というのをどこかで聞いた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Flowの方が段階的に型を導入できる、というのは昔の話

&lt;ul&gt;
&lt;li&gt;今はTypeScriptもオプションによって段階的に導入できるというのが定評。&lt;/li&gt;
&lt;li&gt;そもそも最初から型付けするならどうでもいい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Flowの方が厳密な型チェックしてくれる、というのも昔の話

&lt;ul&gt;
&lt;li&gt;TypeScriptが追い付いてきて、今はほぼ同程度らしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TypeScript+&lt;a href=&#34;https://code.visualstudio.com/&#34;&gt;VSCode&lt;/a&gt;の開発体験が最高すぎるらしい

&lt;ul&gt;
&lt;li&gt;どっちもMicrosoft製なので。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TypeScriptの方がドキュメントが充実してる&lt;/li&gt;
&lt;li&gt;TypeScriptの方が、いざというときにソースが読みやすい

&lt;ul&gt;
&lt;li&gt;TypeScriptはTypeScriptで実装されてて、Flowは&lt;a href=&#34;https://ocaml.org/&#34;&gt;OCaml&lt;/a&gt;で実装されてる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/niieani/typescript-vs-flowtype&#34;&gt;https://github.com/niieani/typescript-vs-flowtype&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://texta.pixta.jp/entry/2018/06/07/120000&#34;&gt;https://texta.pixta.jp/entry/2018/06/07/120000&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://narinymous.hatenablog.com/entry/2018/03/02/032130&#34;&gt;https://narinymous.hatenablog.com/entry/2018/03/02/032130&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://base.terrasky.co.jp/articles/zuUtT&#34;&gt;https://base.terrasky.co.jp/articles/zuUtT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;前回の記事ではFlowを導入したんだけどTypeScriptに移行する羽目に。
FlowとTypeScriptとで型の表現方式や表現力にあまり差はなかったのでそこはまあ手間ではなかったんだけど、以下のような問題に対応する必要があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ビルド時にTypeScriptの方が時間がかかる。&lt;/li&gt;
&lt;li&gt;TypeScriptのリンタである&lt;a href=&#34;https://palantir.github.io/tslint/&#34;&gt;TSLint&lt;/a&gt;が、FlowのESLintよりルールが貧弱

&lt;ul&gt;
&lt;li&gt;TypeScriptのコンパイラがチェックしてくれるからいいのかもしれないけど。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TypeScriptはAltJSなので、何かと連携するときに何かと面倒

&lt;ul&gt;
&lt;li&gt;Jestでユニットテストするときはどうするんだっけとか&lt;/li&gt;
&lt;li&gt;プレーンJavaScriptと混在した環境ではTSLintとESLint併用しなければいけないんだっけとか&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;flowからtypescriptへの移行&#34;&gt;FlowからTypeScriptへの移行&lt;/h1&gt;

&lt;h2 id=&#34;脱flow&#34;&gt;脱Flow&lt;/h2&gt;

&lt;p&gt;とりあえずFlowを取り除く。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yarn remove flow-bin flow-typed @babel/preset-flow eslint-plugin-flowtype babel-eslint
$ rm -f .flowconfig
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [
       &amp;quot;@babel/preset-env&amp;quot;,
       {
         &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
       }
     ],
-    &amp;quot;@babel/preset-flow&amp;quot;,
     &amp;quot;@babel/preset-react&amp;quot;
   ],
   &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;, &amp;quot;@babel/plugin-syntax-dynamic-import&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.eslintrc.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; module.exports = {
   env: {
     browser: true,
     &#39;jest/globals&#39;: true,
   },
-  parser: &#39;babel-eslint&#39;,
-  extends: [&#39;airbnb&#39;, &#39;plugin:flowtype/recommended&#39;, &#39;prettier&#39;],
-  plugins: [&#39;flowtype&#39;, &#39;jest&#39;],
+  extends: [&#39;airbnb&#39;, &#39;prettier&#39;],
+  plugins: [&#39;jest&#39;],
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;環境はこれでよくて、あとは各&lt;code&gt;.js&lt;/code&gt;ファイルと&lt;code&gt;.jsx&lt;/code&gt;ファイルから&lt;code&gt;// @flow&lt;/code&gt;を消して、型情報も消す。
(型情報はTypeScriptでも同じようなのを書くので残しておいてもいい。)&lt;/p&gt;

&lt;h2 id=&#34;typescript導入&#34;&gt;TypeScript導入&lt;/h2&gt;

&lt;h3 id=&#34;パッケージインストール&#34;&gt;パッケージインストール&lt;/h3&gt;

&lt;p&gt;以下のパッケージを入れる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/typescript&#34;&gt;typescript&lt;/a&gt;: TypeScript本体。コンパイラ(tsc)等を含む。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@types/*&lt;/code&gt;: 各3rdパーティライブラリの&lt;a href=&#34;https://github.com/DefinitelyTyped/DefinitelyTyped&#34;&gt;型定義ファイル(DefinitelyTyped)&lt;/a&gt;。(型定義はライブラリ本体のパッケージに含まれている場合もある。)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/s-panferov/awesome-typescript-loader&#34;&gt;awesome-typescript-loader&lt;/a&gt;: TypeScriptを処理するためのwebpackのローダ。他の選択肢として&lt;a href=&#34;https://github.com/TypeStrong/ts-loader&#34;&gt;ts-loader&lt;/a&gt;があるが、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/react-&amp;amp;-webpack.html&#34;&gt;公式のチュートリアル&lt;/a&gt;がawesome-typescript-loaderをメインで紹介してるのでこっちにする。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yarn add -D typescript @types/react @types/react-dom @types/react-redux @types/redux-logger @types/history @types/react-router-dom @types/uuid @types/styled-components awesome-typescript-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TypeScriptはv3.1.6、awesome-typescript-loaderはv5.2.1が入った。&lt;/p&gt;

&lt;h3 id=&#34;typescriptの設定&#34;&gt;TypeScriptの設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html&#34;&gt;TypeScriptの設定ファイル&lt;/a&gt;であるtsconfig.jsonはtscコマンドでテンプレートを生成できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yarn tsc --init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成されたファイルをプロジェクトルートに置いて、ちょっといじって以下の感じに。
(jsonなのにコメント書ける…)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tsconfig.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {
    /* Basic Options */
    &amp;quot;target&amp;quot;: &amp;quot;es5&amp;quot; /* Specify ECMAScript target version: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;,&#39;ES2018&#39; or &#39;ESNEXT&#39;. */,
    &amp;quot;module&amp;quot;: &amp;quot;esnext&amp;quot; /* Specify module code generation: &#39;none&#39;, &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39;, &#39;es2015&#39;, or &#39;ESNext&#39;. */,
    &amp;quot;lib&amp;quot;: [&amp;quot;es2015&amp;quot;, &amp;quot;dom&amp;quot;] /* Specify library files to be included in the compilation. */,
    // &amp;quot;allowJs&amp;quot;: true,                       /* Allow javascript files to be compiled. */
    // &amp;quot;checkJs&amp;quot;: true,                       /* Report errors in .js files. */
    &amp;quot;jsx&amp;quot;: &amp;quot;react&amp;quot; /* Specify JSX code generation: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;. */,
    // &amp;quot;declaration&amp;quot;: true,                   /* Generates corresponding &#39;.d.ts&#39; file. */
    // &amp;quot;declarationMap&amp;quot;: true,                /* Generates a sourcemap for each corresponding &#39;.d.ts&#39; file. */
    &amp;quot;sourceMap&amp;quot;: true /* Generates corresponding &#39;.map&#39; file. */,
    // &amp;quot;outFile&amp;quot;: &amp;quot;./&amp;quot;,                       /* Concatenate and emit output to single file. */
    // &amp;quot;outDir&amp;quot;: &amp;quot;./&amp;quot;,                        /* Redirect output structure to the directory. */
    // &amp;quot;rootDir&amp;quot;: &amp;quot;./&amp;quot;,                       /* Specify the root directory of input files. Use to control the output directory structure with --outDir. */
    // &amp;quot;composite&amp;quot;: true,                     /* Enable project compilation */
    &amp;quot;removeComments&amp;quot;: true /* Do not emit comments to output. */,
    // &amp;quot;noEmit&amp;quot;: true,                        /* Do not emit outputs. */
    // &amp;quot;importHelpers&amp;quot;: true,                 /* Import emit helpers from &#39;tslib&#39;. */
    // &amp;quot;downlevelIteration&amp;quot;: true,            /* Provide full support for iterables in &#39;for-of&#39;, spread, and destructuring when targeting &#39;ES5&#39; or &#39;ES3&#39;. */
    // &amp;quot;isolatedModules&amp;quot;: true,               /* Transpile each file as a separate module (similar to &#39;ts.transpileModule&#39;). */

    /* Strict Type-Checking Options */
    &amp;quot;strict&amp;quot;: true /* Enable all strict type-checking options. */,
    &amp;quot;noImplicitAny&amp;quot;: true /* Raise error on expressions and declarations with an implied &#39;any&#39; type. */,
    &amp;quot;strictNullChecks&amp;quot;: true /* Enable strict null checks. */,
    &amp;quot;strictFunctionTypes&amp;quot;: true /* Enable strict checking of function types. */,
    &amp;quot;strictPropertyInitialization&amp;quot;: true /* Enable strict checking of property initialization in classes. */,
    &amp;quot;noImplicitThis&amp;quot;: true /* Raise error on &#39;this&#39; expressions with an implied &#39;any&#39; type. */,
    &amp;quot;alwaysStrict&amp;quot;: true /* Parse in strict mode and emit &amp;quot;use strict&amp;quot; for each source file. */,

    /* Additional Checks */
    &amp;quot;noUnusedLocals&amp;quot;: true /* Report errors on unused locals. */,
    &amp;quot;noUnusedParameters&amp;quot;: true /* Report errors on unused parameters. */,
    &amp;quot;noImplicitReturns&amp;quot;: true /* Report error when not all code paths in function return a value. */,
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true /* Report errors for fallthrough cases in switch statement. */,

    /* Module Resolution Options */
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot; /* Specify module resolution strategy: &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6). */,
    // &amp;quot;baseUrl&amp;quot;: &amp;quot;./&amp;quot;,                       /* Base directory to resolve non-absolute module names. */
    // &amp;quot;paths&amp;quot;: {},                           /* A series of entries which re-map imports to lookup locations relative to the &#39;baseUrl&#39;. */
    // &amp;quot;rootDirs&amp;quot;: [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */
    // &amp;quot;typeRoots&amp;quot;: [],                       /* List of folders to include type definitions from. */
    &amp;quot;types&amp;quot;: [] /* Type declaration files to be included in compilation. */,
    // &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */
    &amp;quot;esModuleInterop&amp;quot;: true /* Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies &#39;allowSyntheticDefaultImports&#39;. */
    // &amp;quot;preserveSymlinks&amp;quot;: true,              /* Do not resolve the real path of symlinks. */

    /* Source Map Options */
    // &amp;quot;sourceRoot&amp;quot;: &amp;quot;&amp;quot;,                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */
    // &amp;quot;mapRoot&amp;quot;: &amp;quot;&amp;quot;,                         /* Specify the location where debugger should locate map files instead of generated locations. */
    // &amp;quot;inlineSourceMap&amp;quot;: true,               /* Emit a single file with source maps instead of having a separate file. */
    // &amp;quot;inlineSources&amp;quot;: true,                 /* Emit the source alongside the sourcemaps within a single file; requires &#39;--inlineSourceMap&#39; or &#39;--sourceMap&#39; to be set. */

    /* Experimental Options */
    // &amp;quot;experimentalDecorators&amp;quot;: true,        /* Enables experimental support for ES7 decorators. */
    // &amp;quot;emitDecoratorMetadata&amp;quot;: true,         /* Enables experimental support for emitting type metadata for decorators. */
  },
  &amp;quot;files&amp;quot;: [&amp;quot;src/index.tsx&amp;quot;],
  &amp;quot;awesomeTypescriptLoaderOptions&amp;quot;: {
    &amp;quot;useCache&amp;quot;: true,
    &amp;quot;reportFiles&amp;quot;: [&amp;quot;src/**/*.{ts,tsx}&amp;quot;],
    &amp;quot;forceIsolatedModules&amp;quot;: true
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定ファイルのポイントは以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;compilerOptions&lt;/code&gt;: tscのオプション。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt;: コード生成方法をアプリを動作させる環境に合わせて設定するオプション。IE11を含むブラウザを想定して&lt;code&gt;es5&lt;/code&gt;を設定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module&lt;/code&gt;: モジュールコード(importとかexportとか?)の生成方法をアプリを動作させる環境に合わせて設定するオプション。大抵は&lt;code&gt;commonjs&lt;/code&gt;でいいけど、&lt;a href=&#34;https://github.com/tc39/proposal-dynamic-import&#34;&gt;ダイナミックインポート&lt;/a&gt;を使うために&lt;code&gt;esnext&lt;/code&gt;を設定。(参考: &lt;a href=&#34;https://stackoverflow.com/questions/45149091/typescript-use-dynamic-import-in-es5-with-bluebird&#34;&gt;https://stackoverflow.com/questions/45149091/typescript-use-dynamic-import-in-es5-with-bluebird&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib&lt;/code&gt;: コンパイル時に取り込むライブラリを設定するオプション。ターゲットが&lt;code&gt;es5&lt;/code&gt;の場合はデフォルトで&lt;code&gt;[dom,es5,ScriptHost]&lt;/code&gt;が設定されるけど、それだとジェネレータとかダイナミックインポートを使う場合に「&lt;code&gt;ERROR in [at-loader] TS2468: Cannot find global value &#39;Promise&#39;.&lt;/code&gt;」というエラーがでる。ので&lt;code&gt;es2015&lt;/code&gt;を追加する必要がある。&lt;code&gt;document.getElementById()&lt;/code&gt;をするのに&lt;code&gt;dom&lt;/code&gt;も必要だけど、&lt;code&gt;ScriptHost&lt;/code&gt;は無くてもなんだかビルドできるので、&lt;code&gt;[&amp;quot;es2015&amp;quot;, &amp;quot;dom&amp;quot;]&lt;/code&gt;を設定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;allowJs&lt;/code&gt;: デフォルトではTypeScript(i.e. &lt;code&gt;.ts&lt;/code&gt;ファイルと&lt;code&gt;.tsx&lt;/code&gt;ファイル)以外があるとエラーになるけど、このオプションを&lt;code&gt;true&lt;/code&gt;にするとJavaScript(i.e. &lt;code&gt;.js&lt;/code&gt;ファイルと&lt;code&gt;.jsx&lt;/code&gt;ファイル)も混在させられる。とりあえずデフォルトの&lt;code&gt;false&lt;/code&gt;のままにしておく。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkJs&lt;/code&gt;: allowJsを&lt;code&gt;true&lt;/code&gt;にしていた場合、JavaScriptファイルのエラーチェックをするかを設定するオプション。エラーチェックをするかは、Flowみたいに&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html&#34;&gt;ソースごとにコメントで制御することもできる&lt;/a&gt;。&lt;code&gt;allowJs&lt;/code&gt;は&lt;code&gt;false&lt;/code&gt;にするので関係なし。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jsx&lt;/code&gt;: &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/jsx.html&#34;&gt;JSXのコードをどう処理するかを設定するオプション&lt;/a&gt;。プレーンなJavaScriptに変換してほしいので、&lt;code&gt;react&lt;/code&gt;を設定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;moduleResolution&lt;/code&gt;: &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/module-resolution.html&#34;&gt;モジュールの検索方法を設定するオプション&lt;/a&gt;。npmのパッケージ(i.e. &lt;code&gt;node_modules&lt;/code&gt;ディレクトリ内のモジュール)を使うので&lt;code&gt;node&lt;/code&gt;を設定。(&lt;code&gt;node&lt;/code&gt;以外にするケースはほとんどなさそう。)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;types&lt;/code&gt;: &lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#types-typeroots-and-types&#34;&gt;コンパイル時に自動で取り込む型定義ファイルを設定するオプション&lt;/a&gt;。明示的にimportするものはここに書かなくてもいい。(ソースに&lt;code&gt;import &#39;hoge&#39;&lt;/code&gt;と書けば&lt;code&gt;node_modules/&lt;/code&gt;と&lt;code&gt;node_modules/@types/&lt;/code&gt;内からhogeパッケージが検索される。)とりあえず自動で取り込むようなものはないので&lt;code&gt;[]&lt;/code&gt;を設定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;esModuleInterop&lt;/code&gt;: Babel界との調停のための&lt;code&gt;true&lt;/code&gt;にしておくべきオプション。正直よくわからないが、Babelも併用するし、&lt;a href=&#34;https://qiita.com/karak/items/29ff148788f5abb15331&#34;&gt;積極的に有効にすべき&lt;/a&gt;らしいので&lt;code&gt;true&lt;/code&gt;に設定。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;files: &lt;code&gt;include&lt;/code&gt;と&lt;code&gt;exclude&lt;/code&gt;と合わせて、コンパイル対象ファイルを指定するオプション。指定したファイルがimportするファイルは自動でコンパイル対象になる。ので、webpack設定の&lt;code&gt;entry&lt;/code&gt;に設定しているもの(i.e. &lt;code&gt;[&amp;quot;src/index.tsx&amp;quot;]&lt;/code&gt;)を&lt;code&gt;files&lt;/code&gt;に設定。(大抵のケースはこれでいいはず。)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;awesomeTypescriptLoaderOptions&lt;/code&gt;: awesome-typescript-loaderのオプション。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;useCache&lt;/code&gt;: &lt;a href=&#34;https://github.com/s-panferov/awesome-typescript-loader#performance-issues&#34;&gt;ビルド速度向上のために&lt;/a&gt;&lt;code&gt;true&lt;/code&gt;を設定してファイルキャッシュを有効にする。キャッシュはプロジェクトルートの&lt;code&gt;.awcache&lt;/code&gt;ディレクトリに保存されるので、これを.gitignoreに追加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reportFiles&lt;/code&gt;: エラーチェックするファイルを設定するオプション。自分が書いたソースだけ見てくれればいいので、&lt;code&gt;src/&lt;/code&gt;以下を設定。ちゃんと設定しておかないと&lt;code&gt;node_modules/&lt;/code&gt;以下のファイルのエラーチェックもしちゃう。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forceIsolatedModules&lt;/code&gt;: &lt;a href=&#34;https://github.com/s-panferov/awesome-typescript-loader#performance-issues&#34;&gt;ビルド速度向上のために&lt;/a&gt;&lt;code&gt;true&lt;/code&gt;を設定してモジュールのリコンパイルを抑制する。モジュールがプレーンJavaScriptに変換済みのものだけならこれで問題ないはず。(つまり大抵はこれでいいはず。)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;webpackの設定&#34;&gt;webpackの設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/s-panferov/awesome-typescript-loader#configuration&#34;&gt;awesome-typescript-loaderのドキュメント&lt;/a&gt;の通りにwebpackを設定する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; const path = require(&#39;path&#39;);
+const { CheckerPlugin } = require(&#39;awesome-typescript-loader&#39;);
 const packageJson = require(&#39;./package.json&#39;);

 module.exports = {
   entry: [`./${packageJson.main}`],
   output: {
     path: path.resolve(__dirname, &#39;dist&#39;),
     filename: &#39;bundle.js&#39;,
   },
   module: {
     rules: [
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         enforce: &#39;pre&#39;,
         loader: &#39;eslint-loader&#39;,
         options: {
           configFile: &#39;./.eslintrc.js&#39;,
           failOnError: true,
         },
       },
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         enforce: &#39;pre&#39;,
         loader: &#39;stylelint-custom-processor-loader&#39;,
       },
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
+      {
+        test: /\.(ts|tsx)$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        loader: &#39;awesome-typescript-loader&#39;,
+      },
       {
         test: /\.(png|woff|woff2|eot|ttf|svg)$/,
         include: [path.resolve(__dirname, &#39;node_modules&#39;)],
         loader: &#39;file-loader&#39;,
       },
     ],
   },
   resolve: {
-    extensions: [&#39;*&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
+    extensions: [&#39;*&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
     modules: [&#39;node_modules&#39;],
   },
+  plugins: [
+    new CheckerPlugin(),
+  ],
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;とくにコメントなし。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;awesome-typescript-loaderのドキュメントで推奨されている&lt;a href=&#34;https://github.com/mzgoddard/hard-source-webpack-plugin&#34;&gt;HardSourceWebpackPlugin&lt;/a&gt;も導入しておく。
これを使うと、モジュールの中間キャッシュを生成して、二回目以降のビルドを高速化してくれる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yarn add -D hard-source-webpack-plugin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.dev.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; const path = require(&#39;path&#39;);
 const webpackMerge = require(&#39;webpack-merge&#39;);
+const HardSourceWebpackPlugin = require(&#39;hard-source-webpack-plugin&#39;);
 const webpackCommon = require(&#39;./webpack.common.js&#39;);

 module.exports = webpackMerge(webpackCommon, {
   mode: &#39;development&#39;,
   devServer: {
     contentBase: path.join(__dirname, &#39;public&#39;),
     compress: true,
     hot: true,
     port: 3000,
     publicPath: &#39;http://localhost:3000/&#39;,
     historyApiFallback: true,
   },
+  plugins: [ new HardSourceWebpackPlugin() ],
 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;キャッシュは&lt;code&gt;node_modules/.cache/hard-source/&lt;/code&gt;に保存される。
たまにキャッシュのせいでビルド時とか動作時に問題が起こるので、そんなときはこれを消す。&lt;/p&gt;

&lt;h3 id=&#34;フォーマッタの設定&#34;&gt;フォーマッタの設定&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://prettier.io/docs/en/index.html&#34;&gt;Prettier&lt;/a&gt;は普通にTypeScriptをサポートしてるので、TypeScriptのファイルをフォーマット対象に加えるだけでいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   &amp;quot;scripts&amp;quot;: {
-    &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.css&amp;quot;,
+    &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.tsx **/*.ts **/*.css&amp;quot;,
     &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
     &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;,
     &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;リンタの設定&#34;&gt;リンタの設定&lt;/h3&gt;

&lt;p&gt;TypeScriptのリンティングは普通はTSLintを使う。
けど、すでに&lt;a href=&#34;https://eslint.org/&#34;&gt;ESLint&lt;/a&gt;を&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/#eslint&#34;&gt;がっつりセットアップ&lt;/a&gt;してしまったのでTSLintに移行するのが面倒。
また、将来的にJavaScriptのコードも混在させるかもしれないので、そのときESLintとTSLintの設定(ルール)を同時にメンテするのは面倒。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://hokaccha.hatenablog.com/entry/2018/01/23/232625&#34;&gt;この記事&lt;/a&gt;によれば、&lt;a href=&#34;https://github.com/eslint/typescript-eslint-parser&#34;&gt;typescript-eslint-parser&lt;/a&gt;を使えばそれらの面倒を回避できる。
typescript-eslint-parserはESLintのカスタムパーサで、TypeScriptのコードをESLintでリンティングすることを可能にする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yarn add -D typescript-eslint-parser
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;typescript-eslint-parserはv21.0.1が入った。
これを使うようにESLintを設定する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.eslintrc.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; module.exports = {
   env: {
     browser: true,
     &#39;jest/globals&#39;: true,
   },
+  parser: &#39;typescript-eslint-parser&#39;,
+  parserOptions: {
+    jsx: true,
+    useJSXTextNode: false,
+  },
   extends: [&#39;airbnb&#39;, &#39;prettier&#39;],
   plugins: [&#39;jest&#39;],
+  settings: {
+    &#39;import/resolver&#39;: {
+      node: {
+        extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.ts&#39;, &#39;.tsx&#39;],
+      },
+    },
+  },
+  rules: {
+    &#39;react/jsx-filename-extension&#39;: [&#39;error&#39;, { extensions: [&#39;.tsx&#39;, &#39;.jsx&#39;] }],
+  },
+  overrides: [
+    {
+      files: [&#39;**/*.ts&#39;, &#39;**/*.tsx&#39;],
+      rules: {
+        // Set &#39;no-unused-vars&#39; to off to suppress errors on importing types.
+        // (e.g. error  &#39;FunctionComponent&#39; is defined but never used  no-unused-vars)
+        // Unused vars are checked by TypeScript compiler (at-loader) instead.
+        &#39;no-unused-vars&#39;: &#39;off&#39;,
+      },
+    },
+  ],
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定のポイントは以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;parser&lt;/code&gt;にtypescript-eslint-parserを指定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parserOptions.jsx&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にするのはtypescript-eslint-parserの&lt;a href=&#34;https://github.com/eslint/typescript-eslint-parser#configuration&#34;&gt;要件&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parserOptions.useJSXTextNode&lt;/code&gt;を&lt;code&gt;false&lt;/code&gt;にするのはESLintのv4を使う場合のtypescript-eslint-parserの&lt;a href=&#34;https://github.com/eslint/typescript-eslint-parser#configuration&#34;&gt;要件&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;settings[import/resolver].node.extensions&lt;/code&gt;は、importするモジュールのパス解決の設定。デフォルトではJavaScriptの拡張子しか検索しないので、TypeScriptのモジュールが見つからなくてESLintが「&lt;code&gt;Unable to resolve path to module &#39;./components/App&#39;  import/no-unresolved&lt;/code&gt;」みたいなエラーを吐く。これを防ぐためにTypeScriptの拡張子を追加する。(webpack.common.jsの&lt;code&gt;resolve.extensions&lt;/code&gt;と同じ拡張子を設定しておく。)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rules&lt;/code&gt;では、JSXファイルの拡張子名を制限するルール&lt;code&gt;react/jsx-filename-extension&lt;/code&gt;を定義している。&lt;code&gt;extends&lt;/code&gt;している&lt;code&gt;airbnb&lt;/code&gt;の設定では&lt;code&gt;.jsx&lt;/code&gt;だけになっているので&lt;code&gt;.tsx&lt;/code&gt;を追加する意図。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;overrides&lt;/code&gt;では、宣言だけして使っていない変数をエラーにするルール&lt;code&gt;no-unused-vars&lt;/code&gt;をTypeScriptに対して無効にしている。型をimportして使うコードを書くとエラーになっちゃうことがあるので。同様のチェックはTypeScriptのコンパイラがしてくれるので問題なし。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(2019/1/25追記: TypeScriptチームがTSLintからESLintに移行することが&lt;a href=&#34;https://qiita.com/mysticatea/items/aaf677928e965abe093d&#34;&gt;発表された&lt;/a&gt;。今後はTypeScriptはESLintでチェックするのがスタンダードになる。それに伴ってtypescript-eslint-parserは&lt;a href=&#34;https://www.npmjs.com/package/@typescript-eslint/parser&#34;&gt; @typescript-eslint/parser&lt;/a&gt;に置き換えられる。)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;CSS(というか&lt;a href=&#34;https://github.com/styled-components/styled-components&#34;&gt;styled-components&lt;/a&gt;)のリンタの&lt;a href=&#34;https://github.com/stylelint/stylelint&#34;&gt;stylelint&lt;/a&gt;は&lt;a href=&#34;https://github.com/styled-components/stylelint-processor-styled-components#setup&#34;&gt;TypeScriptに対応している&lt;/a&gt;のでケアする必要なし。&lt;/p&gt;

&lt;h3 id=&#34;javascriptをtypescriptへ書き換える&#34;&gt;JavaScriptをTypeScriptへ書き換える&lt;/h3&gt;

&lt;p&gt;とりあえず、&lt;code&gt;src/&lt;/code&gt;以下の全ファイル(&lt;code&gt;src/__tests__/&lt;/code&gt;以下は除く)について、拡張子を&lt;code&gt;.js&lt;/code&gt;と&lt;code&gt;.jsx&lt;/code&gt;から&lt;code&gt;.ts&lt;/code&gt;と&lt;code&gt;.tsx&lt;/code&gt;に変える。&lt;/p&gt;

&lt;p&gt;型付けについては、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/basic-types.html&#34;&gt;TypeScriptのドキュメント&lt;/a&gt;の他、以下の記事を参考にした。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/lemon/typescript-fsanilai-ranaireact-x-redux&#34;&gt;typescript-fsaに頼らないReact × Redux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/terrierscript/items/b3f9dd95a4c7afe0b102&#34;&gt;TypeScript + Reduxはもうぼちぼちサードライブラリに頼らなくてもある程度はいい感じに補完してくれる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://piotrwitek.github.io/react-redux-typescript-guide/&#34;&gt;react-redux-typescript-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;reactコンポーネントの型&#34;&gt;Reactコンポーネントの型&lt;/h4&gt;

&lt;p&gt;Function Componentは、propsの型を&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/interfaces.html&#34;&gt;interface&lt;/a&gt;で作って、&lt;code&gt;React.FunctionComponent&lt;/code&gt;で型付ける。
&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases&#34;&gt;型エイリアス&lt;/a&gt;の&lt;code&gt;type&lt;/code&gt;じゃなくて&lt;code&gt;interface&lt;/code&gt;を使うのは、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/advanced-types.html#interfaces-vs-type-aliases&#34;&gt;公式が基本はinterfaceを使え&lt;/a&gt;と言ってるので。
因みに&lt;code&gt;React.FunctionComponent&lt;/code&gt;の代わりに&lt;code&gt;React.SFC&lt;/code&gt;を使ってるのをよく見るが、それは古い書き方。&lt;/p&gt;

&lt;p&gt;例えば&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/07/creating-react-redux-app-from-scratch-10/&#34;&gt;前回&lt;/a&gt;書いた&lt;code&gt;MyDialog&lt;/code&gt;は以下のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React, { FunctionComponent } from &#39;react&#39;;
import Dialog from &#39;@material-ui/core/Dialog&#39;;
import DialogTitle from &#39;@material-ui/core/DialogTitle&#39;;
import PropTypes from &#39;prop-types&#39;;

// Props型の定義
interface Props {
  text: string;
  open: boolean;
}

// Function Componentの定義
const MyDialog: FunctionComponent&amp;lt;Props&amp;gt; = ({ text, open }) =&amp;gt; (
  &amp;lt;Dialog open={open}&amp;gt;
    &amp;lt;DialogTitle&amp;gt;{text}&amp;lt;/DialogTitle&amp;gt;
  &amp;lt;/Dialog&amp;gt;
);

MyDialog.propTypes = {
  text: PropTypes.string.isRequired,
  open: PropTypes.bool.isRequired,
};

export default MyDialog;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Container Componentは、Store型を&lt;code&gt;configureStore.ts&lt;/code&gt;辺りで定義しておいて、それを&lt;code&gt;connect&lt;/code&gt;するときの&lt;code&gt;mapStateToProps&lt;/code&gt;で使う。
Storeのプロパティは、Reducerの型付け(後述)のためにそれぞれStateとして型付けしておく。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/#reducer&#34;&gt;以前&lt;/a&gt;書いた&lt;code&gt;state&lt;/code&gt;をStore型として定義すると以下のようになる。&lt;/p&gt;

&lt;p&gt;Store型:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export interface HogeState {
  clicked: boolean;
}

export interface Store {
  hoge: HogeState;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これを使うコードは以下。
(&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/#connect-%E3%81%AE%E3%82%B7%E3%83%B3%E3%83%97%E3%83%AB%E3%81%AA%E6%9B%B8%E3%81%8D%E6%96%B9&#34;&gt;以前の記事&lt;/a&gt;で書いた&lt;code&gt;HogeButton&lt;/code&gt;からの差分。)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/containers/HogeButton.ts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import Button from &#39;@material-ui/core/Button&#39;;
 import { connect } from &#39;react-redux&#39;;
 import { hogeButtonClicked } from &#39;../actions/actions&#39;;
+import { Store } from &#39;../configureStore&#39;;

 const HogeButton = connect(
-  ({hoge}) =&amp;gt; ({
+  ({hoge}: Store) =&amp;gt; ({
     clicked: hoge.clicked
   }),
   {
     onClick: hogeButtonClicked,
   },
 )(Button);

 export default HogeButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Class Componentの型付け方法は&lt;a href=&#34;https://speakerdeck.com/lemon/typescript-fsanilai-ranaireact-x-redux?slide=7&#34;&gt;typescript-fsaに頼らないReact × Redux&lt;/a&gt;の通りでよさそう。
正直あまり考えてない…。
Class Componentはまだ書いてないし、&lt;a href=&#34;https://reactjs.org/docs/hooks-intro.html&#34;&gt;React Hooks&lt;/a&gt;が出てきて、Class Componentは非推奨になりそうでもあるし。&lt;/p&gt;

&lt;h4 id=&#34;reduxのactionの型&#34;&gt;ReduxのActionの型&lt;/h4&gt;

&lt;p&gt;Actionの型は、&lt;code&gt;redux&lt;/code&gt;パッケージに基本的な型が定義されているのでそれを拡張して作る。
&lt;code&gt;redux&lt;/code&gt;パッケージのは&lt;code&gt;string&lt;/code&gt;の&lt;code&gt;type&lt;/code&gt;プロパティだけがある型なので、&lt;a href=&#34;https://github.com/redux-utilities/flux-standard-action&#34;&gt;Flux Standard Action&lt;/a&gt;(FSA)的な形にするために、&lt;code&gt;error&lt;/code&gt;、&lt;code&gt;payload&lt;/code&gt;、&lt;code&gt;meta&lt;/code&gt;の3つのプロパティを&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/advanced-types.html#optional-parameters-and-properties&#34;&gt;オプショナル&lt;/a&gt;で追加する。
&lt;code&gt;error&lt;/code&gt;は&lt;code&gt;boolean&lt;/code&gt;で、&lt;code&gt;payload&lt;/code&gt;と&lt;code&gt;meta&lt;/code&gt;は&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/generics.html&#34;&gt;ジェネリクス&lt;/a&gt;で型を指定する。&lt;/p&gt;

&lt;p&gt;このAction型から、&lt;code&gt;type&lt;/code&gt;、&lt;code&gt;payload&lt;/code&gt;、&lt;code&gt;meta&lt;/code&gt;の型を指定した型エイリアスを作ったり、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/interfaces.html#extending-interfaces&#34;&gt;extends&lt;/a&gt;したりして、個々のActionごとに具体的な型を作る。
&lt;code&gt;type&lt;/code&gt;プロパティは、&lt;a href=&#34;https://www.typescriptlang.org/docs/handbook/advanced-types.html#string-literal-types&#34;&gt;文字列リテラル型&lt;/a&gt;としてAction Typeで型付ける。&lt;/p&gt;

&lt;p&gt;例えば、&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/#rest-api%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97%E3%82%92%E8%A1%A8%E7%8F%BE%E3%81%99%E3%82%8Baction&#34;&gt;以前&lt;/a&gt;書いたAction Creatorは以下のように型付ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/actions/actions.ts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+import Redux from &#39;redux&#39;;

 import {
   HOGE_BUTTON_CLICKED,
   HOGE_FETCH_SUCCEEDED,
   HOGE_FETCH_FAILED,
 } from &#39;./actionTypes&#39;;

+// Action型の定義。
+export interface HogeAction&amp;lt;Type, Payload = undefined, Meta = undefined&amp;gt;
+  extends Redux.Action&amp;lt;Type&amp;gt; {
+  error?: boolean;
+  payload?: Payload;
+  meta?: Meta;
+}

+// 型エイリアスによるAction型の具体化。
+// 「typeof HOGE_BUTTON_CLICKED」で文字列リテラル型を指定している。
+export type HogeButtonClicked = HogeAction&amp;lt;typeof HOGE_BUTTON_CLICKED&amp;gt;;
-export function hogeButtonClicked() {
+export function hogeButtonClicked(): HogeButtonClicked {
   return {
     type: HOGE_BUTTON_CLICKED,
   };
 }

+// payloadの型の定義。
+interface HogeFetchSucceededPayload {
+  hoge: string;
+}
+// インターフェースによるAction型の具体化。payloadプロパティを必須化している。
+export interface HogeFetchSucceeded
+  extends HogeAction&amp;lt;typeof HOGE_FETCH_SUCCEEDED, HogeFetchSucceededPayload, Object&amp;gt; {
+  payload: HogeFetchSucceededPayload;
+}
-export function hogeFetchSucceeded(payload, meta) {
+export function hogeFetchSucceeded(
+  payload: HogeFetchSucceededPayload,
+  meta: Object,
+): HogeFetchSucceeded {
   return {
     type: HOGE_FETCH_SUCCEEDED,
     payload,
     meta,
   };
 }

+export type HogeFetchFailed = HogeAction&amp;lt;typeof HOGE_FETCH_FAILED, Object&amp;gt;;
-export function hogeFetchFailed(payload) {
+export function hogeFetchFailed(payload: Object): HogeFetchFailed {
   return {
     type: HOGE_FETCH_FAILED,
     error: true,
     payload,
   };
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;reduxのreducerの型&#34;&gt;ReduxのReducerの型&lt;/h4&gt;

&lt;p&gt;Reducerの型は&lt;code&gt;redux&lt;/code&gt;パッケージの&lt;code&gt;Reducer&lt;/code&gt;型を使う。
この&lt;code&gt;Reducer&lt;/code&gt;型がジェネリクスで、引数の&lt;code&gt;state&lt;/code&gt;と&lt;code&gt;action&lt;/code&gt;の型を受けるので、すでに定義したState型と具体Action型をimportして渡す。&lt;/p&gt;

&lt;p&gt;例えば、&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/#reducer&#34;&gt;以前&lt;/a&gt;書いたReducerは以下のように型付ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.ts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;+import { Reducer } from &#39;redux&#39;;
+import { HogeState } from &#39;../configureStore&#39;;
 import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;
+import { HogeButtonClicked } from &#39;../actions/actions&#39;;

-export const hoge = (state = { clicked: false }, action) =&amp;gt; {
+export const hoge: Reducer&amp;lt;HogeState, HogeButtonClicked&amp;gt; = (
+  state = { clicked: false },
+  action,
+) =&amp;gt; {
   switch (action.type) {
     case HOGE_BUTTON_CLICKED:
       const newHoge = {
         clicked: true,
       };
       return Object.assign({}, state, newHoge);
     default:
       return state;
   }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;スクリプト以外をimportするコードを修正&#34;&gt;スクリプト以外をimportするコードを修正&lt;/h4&gt;

&lt;p&gt;JavaScriptやTypeScript以外のファイルをimportするコードを書くと、コンパイル時にエラーになる。&lt;/p&gt;

&lt;p&gt;今まで書いた中で該当するのは&lt;code&gt;src/fonts.ts&lt;/code&gt;でフォントファイルをimportしている箇所で、「&lt;code&gt;TS2307: Cannot find module &#39;../node_modules/typeface-roboto/files/roboto-lat
in-300.woff&#39;.&lt;/code&gt;」といったエラーが出る。&lt;/p&gt;

&lt;p&gt;原因は&lt;a href=&#34;https://stackoverflow.com/questions/36148639/webpack-not-able-to-import-images-using-express-and-angular2-in-typescript&#34;&gt;webpackでロードすべきものをtscでロードしちゃってる&lt;/a&gt;から。
フォントファイルはwebpack(のfile-loader)でロードすべき。&lt;/p&gt;

&lt;p&gt;解決策は、&lt;code&gt;import&lt;/code&gt;文はtscが処理しちゃうので、代わりに&lt;code&gt;require&lt;/code&gt;関数を使うこと。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/fonts.ts&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { createGlobalStyle } from &#39;styled-components&#39;;
-import roboto300 from &#39;../node_modules/typeface-roboto/files/roboto-latin-300.woff&#39;;
+const roboto300 = require(&#39;../node_modules/typeface-roboto/files/roboto-latin-300.woff&#39;);

 const Fonts = createGlobalStyle`
   /* roboto-300normal - latin */
   @font-face {
     font-family: &#39;Roboto&#39;;
     font-style: normal;
     font-display: swap;
     font-weight: 300;
     src:
       local(&#39;Roboto Light&#39;),
       local(&#39;Roboto-Light&#39;),
       url(&#39;${roboto300}&#39;) format(&#39;woff&#39;);
   }
 `;

 export default Fonts;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。&lt;/p&gt;

&lt;h3 id=&#34;jestの設定&#34;&gt;Jestの設定&lt;/h3&gt;

&lt;p&gt;Jestを実行するときはwebpackを介さないので、別途TypeScript対応する必要がある。
純粋なTypeScriptプロジェクトでは普通&lt;a href=&#34;https://kulshekhar.github.io/ts-jest/&#34;&gt;ts-jest
&lt;/a&gt;を使うみたいだけど、&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/07/creating-react-redux-app-from-scratch-10/&#34;&gt;前回&lt;/a&gt;入れた&lt;a href=&#34;https://www.npmjs.com/package/babel-jest&#34;&gt;babel-jest&lt;/a&gt;で事足りるようなのでこっちを使う。&lt;/p&gt;

&lt;p&gt;babel-jestは、Jest実行時にテストコードと関連モジュールをBabelで処理してピュアなJavaScriptにしてくれるやつ。
TypeScriptをBabelで処理できるようにするには、&lt;a href=&#34;https://babeljs.io/docs/en/babel-preset-typescript&#34;&gt;@babel/preset-typescript&lt;/a&gt;を入れておく必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yarn add -D @babel/preset-typescript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [
       &amp;quot;@babel/preset-env&amp;quot;,
       {
         &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
       }
     ],
+    &amp;quot;@babel/preset-typescript&amp;quot;,
     &amp;quot;@babel/preset-react&amp;quot;
   ],
   &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;, &amp;quot;@babel/plugin-syntax-dynamic-import&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、jest.config.jsを二か所いじる。&lt;/p&gt;

&lt;p&gt;一つは、JestがTypeScriptの拡張子を認識するように、&lt;code&gt;moduleFileExtensions&lt;/code&gt;に&lt;code&gt;ts&lt;/code&gt;と&lt;code&gt;tsx&lt;/code&gt;を追加する。
もう一つは、Jestがbabel-jestを呼び出すように、&lt;code&gt;transform&lt;/code&gt;にパターンを追加する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jest.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; // For a detailed explanation regarding each configuration property, visit:
 // https://jestjs.io/docs/en/configuration.html

 module.exports = {
   // All imported modules in your tests should be mocked automatically
   // automock: false,

   // Stop running tests after the first failure
   // bail: false,

   // Respect &amp;quot;browser&amp;quot; field in package.json when resolving modules
   // browser: false,

   // The directory where Jest should store its cached dependency information
   // cacheDirectory: &amp;quot;C:\\Users\\kaitoy\\AppData\\Local\\Temp\\jest&amp;quot;,

   // Automatically clear mock calls and instances between every test
   // clearMocks: false,

   // Indicates whether the coverage information should be collected while executing the test
   // collectCoverage: false,

   // An array of glob patterns indicating a set of files for which coverage information should be collected
   // collectCoverageFrom: null,

   // The directory where Jest should output its coverage files
   coverageDirectory: &#39;coverage&#39;,

   // An array of regexp pattern strings used to skip coverage collection
   // coveragePathIgnorePatterns: [
   //   &amp;quot;\\\\node_modules\\\\&amp;quot;
   // ],

   // A list of reporter names that Jest uses when writing coverage reports
   // coverageReporters: [
   //   &amp;quot;json&amp;quot;,
   //   &amp;quot;text&amp;quot;,
   //   &amp;quot;lcov&amp;quot;,
   //   &amp;quot;clover&amp;quot;
   // ],

   // An object that configures minimum threshold enforcement for coverage results
   // coverageThreshold: null,

   // Make calling deprecated APIs throw helpful error messages
   // errorOnDeprecated: false,

   // Force coverage collection from ignored files usin a array of glob patterns
   // forceCoverageMatch: [],

   // A path to a module which exports an async function that is triggered once before all test suites
   // globalSetup: null,

   // A path to a module which exports an async function that is triggered once after all test suites
   // globalTeardown: null,

   // A set of global variables that need to be available in all test environments
   // globals: {},

   // An array of directory names to be searched recursively up from the requiring module&#39;s location
   // moduleDirectories: [
   //   &amp;quot;node_modules&amp;quot;
   // ],

   // An array of file extensions your modules use
-  // moduleFileExtensions: [
-  //   &amp;quot;js&amp;quot;,
-  //   &amp;quot;json&amp;quot;,
-  //   &amp;quot;jsx&amp;quot;,
-  //   &amp;quot;node&amp;quot;
-  // ],
+  moduleFileExtensions: [
+    &amp;quot;ts&amp;quot;,
+    &amp;quot;tsx&amp;quot;,
+    &amp;quot;js&amp;quot;,
+    &amp;quot;json&amp;quot;,
+    &amp;quot;jsx&amp;quot;,
+    &amp;quot;node&amp;quot;
+  ],

   // A map from regular expressions to module names that allow to stub out resources with a single module
   // moduleNameMapper: {},

   // An array of regexp pattern strings, matched against all module paths before considered &#39;visible&#39; to the module loader
   // modulePathIgnorePatterns: [],

   // Activates notifications for test results
   // notify: false,

   // An enum that specifies notification mode. Requires { notify: true }
   // notifyMode: &amp;quot;always&amp;quot;,

   // A preset that is used as a base for Jest&#39;s configuration
   // preset: null,

   // Run tests from one or more projects
   // projects: null,

   // Use this configuration option to add custom reporters to Jest
   // reporters: undefined,

   // Automatically reset mock state between every test
   // resetMocks: false,

   // Reset the module registry before running each individual test
   // resetModules: false,

   // A path to a custom resolver
   // resolver: null,

   // Automatically restore mock state between every test
   // restoreMocks: false,

   // The root directory that Jest should scan for tests and modules within
   // rootDir: null,

   // A list of paths to directories that Jest should use to search for files in
   // roots: [
   //   &amp;quot;&amp;lt;rootDir&amp;gt;&amp;quot;
   // ],

   // Allows you to use a custom runner instead of Jest&#39;s default test runner
   // runner: &amp;quot;jest-runner&amp;quot;,

   // The paths to modules that run some code to configure or set up the testing environment before each test
   // setupFiles: [],

   // The path to a module that runs some code to configure or set up the testing framework before each test
   // setupTestFrameworkScriptFile: null,

   // A list of paths to snapshot serializer modules Jest should use for snapshot testing
   // snapshotSerializers: [],

   // The test environment that will be used for testing
   // testEnvironment: &amp;quot;jest-environment-jsdom&amp;quot;,

   // Options that will be passed to the testEnvironment
   // testEnvironmentOptions: {},

   // Adds a location field to test results
   // testLocationInResults: false,

   // The glob patterns Jest uses to detect test files
   // testMatch: [
   //   &amp;quot;**/__tests__/**/*.js?(x)&amp;quot;,
   //   &amp;quot;**/?(*.)+(spec|test).js?(x)&amp;quot;
   // ],

   // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
   // testPathIgnorePatterns: [
   //   &amp;quot;\\\\node_modules\\\\&amp;quot;
   // ],

   // The regexp pattern Jest uses to detect test files
   // testRegex: &amp;quot;&amp;quot;,

   // This option allows the use of a custom results processor
   // testResultsProcessor: null,

   // This option allows use of a custom test runner
   // testRunner: &amp;quot;jasmine2&amp;quot;,

   // This option sets the URL for the jsdom environment. It is reflected in properties such as location.href
   testURL: &#39;http://localhost/&#39;,

   // Setting this value to &amp;quot;fake&amp;quot; allows the use of fake timers for functions such as &amp;quot;setTimeout&amp;quot;
   // timers: &amp;quot;real&amp;quot;,

   // A map from regular expressions to paths to transformers
-  // transform: null,
+  transform: {
+    &#39;^.+\\.jsx?$&#39;: &#39;babel-jest&#39;,
+    &#39;^.+\\.tsx?$&#39;: &#39;babel-jest&#39;,
+  },

   // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
   // transformIgnorePatterns: [
   //   &amp;quot;\\\\node_modules\\\\&amp;quot;
   // ],

   // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
   // unmockedModulePathPatterns: undefined,

   // Indicates whether each individual test should be reported during the run
   // verbose: null,

   // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
   // watchPathIgnorePatterns: [],

   // Whether to use watchman for file crawling
   // watchman: true,
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でTypeScriptへの移行完了。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その10: Code Splitting、Flow、Jest、Enzyme</title>
          <link>https://www.kaitoy.xyz/2018/11/07/creating-react-redux-app-from-scratch-10/</link>
          <pubDate>Wed, 07 Nov 2018 23:41:30 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/11/07/creating-react-redux-app-from-scratch-10/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/02/creating-react-redux-app-from-scratch-09/&#34;&gt;前回&lt;/a&gt;は&lt;a href=&#34;https://reacttraining.com/react-router/&#34;&gt;React Router&lt;/a&gt;をセットアップした。&lt;/p&gt;

&lt;p&gt;今回は残りの要素をまとめてかたづける。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;code-splitting&#34;&gt;Code Splitting&lt;/h1&gt;

&lt;p&gt;webpackでリソースをバンドルすると、一回の通信でアプリの要素全てをロードできるので効率いいような気がするけど、アプリの規模が大きくなってくるとバンドルサイズが大きくなって、初期ロード時間が長くなり、つまり初期画面の表示に時間がかかるようになってしまう。
そもそも、いつもアプリの全画面をみるとは限らないので、いつもアプリの全要素をロードするのは無駄。&lt;/p&gt;

&lt;p&gt;そんな問題に対応する技術が&lt;a href=&#34;https://webpack.js.org/guides/code-splitting/&#34;&gt;Code Splitting&lt;/a&gt;。
バンドルを分割し、(理想的には)必要な時に必要な分だけロードする技術。&lt;/p&gt;

&lt;p&gt;Code Splittingのやりかたはいくつかあるが、&lt;a href=&#34;https://reactjs.org/docs/code-splitting.html#import&#34;&gt;ダイナミックインポート&lt;/a&gt;と&lt;a href=&#34;https://reactjs.org/docs/code-splitting.html#reactlazy&#34;&gt;React.lazy&lt;/a&gt;と&lt;a href=&#34;https://reactjs.org/docs/code-splitting.html#suspense&#34;&gt;React Suspense&lt;/a&gt;とwebpackの&lt;a href=&#34;https://webpack.js.org/guides/code-splitting/#prefetching-preloading-modules&#34;&gt;プリフェッチディレクティブ&lt;/a&gt;を使ったやつを、フォントモジュールに適用してみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-import React from &#39;react&#39;;
+import React, { Suspense } from &#39;react&#39;;
 import { Route, Redirect } from &#39;react-router-dom&#39;;
 import Home from &#39;./Home&#39;;
-import Fonts from &#39;../fonts&#39;;

+const Fonts = React.lazy(() =&amp;gt; import(/* webpackPrefetch: true */ &#39;../fonts&#39;));

 const App = () =&amp;gt; (
   &amp;lt;div&amp;gt;
     &amp;lt;Route exact path=&amp;quot;/&amp;quot; render={() =&amp;gt; &amp;lt;Redirect to=&amp;quot;/home&amp;quot; /&amp;gt;} /&amp;gt;
     &amp;lt;Route exact path=&amp;quot;/home&amp;quot; component={Home} /&amp;gt;
-    &amp;lt;Fonts /&amp;gt;
+    &amp;lt;Suspense fallback={&amp;lt;div /&amp;gt;}&amp;gt;
+      &amp;lt;Fonts /&amp;gt;
+    &amp;lt;/Suspense&amp;gt;
   &amp;lt;/div&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;コード変更はこれだけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import()&lt;/code&gt;がダイナミックインポートで、&lt;a href=&#34;https://github.com/tc39/proposal-dynamic-import&#34;&gt;ECMAScriptで現在策定中&lt;/a&gt;の機能。
これを使えるようにするためには、Babelのプラグインを追加する必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D @babel/plugin-syntax-dynamic-import
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [
       &amp;quot;@babel/preset-env&amp;quot;,
       {
         &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
       }
     ],
     &amp;quot;@babel/preset-react&amp;quot;
   ],
-  &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;]
+  &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;, &amp;quot;@babel/plugin-syntax-dynamic-import&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ダイナミックインポートの設定も完了。
これでフォントモジュールはメインのバンドルとは別ファイルになり、初期画面の表示時にはロードされず、ブラウザの空き時間に非同期にロードされるようになる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;flow&#34;&gt;Flow&lt;/h1&gt;

&lt;p&gt;Reactに限らない話だけど、JavaScriptは動的型付け言語なので、特に規模が大き目なアプリを開発するとなると保守性が悪くなりがちで辛い。
ので、できれば静的型付けでやりたい。&lt;/p&gt;

&lt;p&gt;JavaScriptを静的型付けにするには、&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;と&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;という二つの選択肢がある。
今回、FlowがReactと同じくFacebook製なので、Reactと相性がいいかと思ってFlowを選択したけど、人気やエコシステムの充実度から見るとTypeScriptのほうがよかった気がする。
ので、Flowについてはさらっと書く。&lt;/p&gt;

&lt;h2 id=&#34;flow導入&#34;&gt;Flow導入&lt;/h2&gt;

&lt;p&gt;Flowは、ソースに型情報を付けて静的型チェック可能にしつつ、実行時には型情報を取り去って普通のJavaScriptとして実行できるようにする仕組み。&lt;/p&gt;

&lt;p&gt;型チェックするツールは&lt;a href=&#34;https://www.npmjs.com/package/flow-bin&#34;&gt;flow-bin&lt;/a&gt;パッケージで配布されていて、型情報の除去は&lt;a href=&#34;https://www.npmjs.com/package/babel-preset-flow&#34;&gt;@babel/preset-flow&lt;/a&gt;を使ってBabelでできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D flow-bin @babel/preset-flow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [
       &amp;quot;@babel/preset-env&amp;quot;,
       {
         &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
       }
     ],
+    &amp;quot;@babel/preset-flow&amp;quot;,
     &amp;quot;@babel/preset-react&amp;quot;
   ],
   &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;, &amp;quot;@babel/plugin-syntax-dynamic-import&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;yarn flow&lt;/code&gt;でFlowを実行できるようになった。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;$ yarn flow version
yarn run v1.7.0
$ C:\Users\kaitoy\Desktop\bin\pleiades\workspace\react-redux-scaffold\node_modules\.bin\flow version
Flow, a static type checker for JavaScript, version 0.77.0
Done in 0.38s.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、&lt;code&gt;yarn flow init&lt;/code&gt;でFlowの設定ファイル&lt;code&gt;.flowconfig&lt;/code&gt;を生成して、型チェックしたいファイルの頭に&lt;code&gt;// @flow&lt;/code&gt;と書けばとりあえず機能する。&lt;/p&gt;

&lt;h2 id=&#34;flowの型アノテーション&#34;&gt;Flowの型アノテーション&lt;/h2&gt;

&lt;p&gt;それだけでもだいぶ型推論してくれてチェックが利くけど、&lt;a href=&#34;https://flow.org/en/docs/types/&#34;&gt;型アノテーション&lt;/a&gt;を書いていくとよりいい。
ただ、アノテートするとESLintとけんかするので、それ対策として&lt;a href=&#34;https://github.com/gajus/eslint-plugin-flowtype&#34;&gt;eslint-plugin-flowtype&lt;/a&gt;を入れる必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D babel-eslint eslint-plugin-flowtype
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.eslintrc.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; module.exports = {
   env: {
     browser: true,
   },
+  parser: &#39;babel-eslint&#39;,
-  extends: [&#39;airbnb&#39;, &#39;prettier&#39;],
+  extends: [&#39;airbnb&#39;, &#39;plugin:flowtype/recommended&#39;, &#39;prettier&#39;],
+  plugins: [&#39;flowtype&#39;],
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;例として、Reactコンポーネントのpropsに型を付けてみる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// @flow

import React from &#39;react&#39;;
import Dialog from &#39;@material-ui/core/Dialog&#39;;
import DialogTitle from &#39;@material-ui/core/DialogTitle&#39;;
import PropTypes from &#39;prop-types&#39;;

// Propsという型の定義
// text(string型)とopen(boolean型)というプロパティを持つオブジェクト
type Props = {
  text: string,
  open: boolean,
};

// Props型を受け取る関数
const MyDialog = ({ text, open }: Props) =&amp;gt; (
  &amp;lt;Dialog open={open}&amp;gt;
    &amp;lt;DialogTitle&amp;gt;{text}&amp;lt;/DialogTitle&amp;gt;
  &amp;lt;/Dialog&amp;gt;
);

MyDialog.propTypes = {
  text: PropTypes.string.isRequired,
  open: PropTypes.bool.isRequired,
};

export default MyDialog;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで型を付けておくと、MyDialogに渡すpropsを間違った場合にFlowがエラーにしてくれる。
prop-typesによる型定義と冗長な感じに見えるけど、Flowは静的に型チェックするのに対し、prop-typesはアプリの動作中に型チェックしてくれるので、両方書いておくのがよさそう。
(Flowの型定義からprop-typesの定義を生成してくれる&lt;a href=&#34;https://github.com/atlassian/babel-plugin-react-flow-props-to-prop-types&#34;&gt;babel-plugin-react-flow-props-to-prop-types&lt;/a&gt;というのがあるけど、サポートされていない型があるし、メンテされていないし、微妙。)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;上のコードで、&lt;code&gt;type&lt;/code&gt;というキーワードで型を定義しているんだけど、Reactとかの3rdパーティライブラリの型情報(&lt;a href=&#34;https://flow.org/en/docs/libdefs/&#34;&gt;libdef&lt;/a&gt;と呼ばれるもの)は、ライブラリ開発者などが作ったものが公開されていて、インストールして利用できる。&lt;/p&gt;

&lt;p&gt;libdefはそれようの&lt;a href=&#34;https://github.com/flow-typed/flow-typed/tree/master/definitions&#34;&gt;リポジトリ&lt;/a&gt;で管理されていて、&lt;a href=&#34;https://github.com/flow-typed/flow-typed/blob/master/README.md&#34;&gt;flow-typed&lt;/a&gt;で引っ張れる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D flow-typed
yarn flow-typed --ignoreDeps dev install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、package.jsonに書かれている依存(devDependenciesを除く)を見て、必要なlibdefをダウンロードしてきて、プロジェクトルートの&lt;code&gt;flow-typed&lt;/code&gt;というディレクトリにインストールしてくれる。&lt;/p&gt;

&lt;p&gt;例えばさっきのReactコンポーネントのコードに、ReactのAPIの型の一つである&lt;code&gt;Node&lt;/code&gt;を書くと以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; // @flow

 import React from &#39;react&#39;;
+import type { Node } from &#39;react&#39;;
 import Dialog from &#39;@material-ui/core/Dialog&#39;;
 import DialogTitle from &#39;@material-ui/core/DialogTitle&#39;;
 import PropTypes from &#39;prop-types&#39;;

 // Propsという型の定義
 // text(string型)とopen(boolean型)というプロパティを持つオブジェクト
 type Props = {
   text: string,
   open: boolean,
 };

 // Props型を受け取る関数
-const MyDialog = ({ text, open }: Props) =&amp;gt; (
+const MyDialog = ({ text, open }: Props): Node =&amp;gt; (
   &amp;lt;Dialog open={open}&amp;gt;
     &amp;lt;DialogTitle&amp;gt;{text}&amp;lt;/DialogTitle&amp;gt;
   &amp;lt;/Dialog&amp;gt;
 );

 MyDialog.propTypes = {
   text: PropTypes.string.isRequired,
   open: PropTypes.bool.isRequired,
 };

 export default MyDialog;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因みに&lt;code&gt;flow-typed&lt;/code&gt;ディレクトリの中身はコミットすることが推奨されている。
なんか違和感あるんだけど…&lt;/p&gt;

&lt;h1 id=&#34;jest&#34;&gt;Jest&lt;/h1&gt;

&lt;p&gt;Reactプロジェクトでユニットテストを書くなら、&lt;a href=&#34;https://jestjs.io/ja/&#34;&gt;Jest&lt;/a&gt;一択でいいっぽい。
JestもReactと開発元が同じFacebookで、Reactと相性がいいはずだし、Reactプロジェクト以外でもJestは人気。&lt;/p&gt;

&lt;p&gt;ゼロ設定で使えるように作られていて、導入の敷居が低いのが特徴。
また多機能で、アサーション、モック、カバレージ測定辺りは組み込まれていてすぐ使える。&lt;/p&gt;

&lt;p&gt;もともとは(今も?)&lt;a href=&#34;https://jasmine.github.io/&#34;&gt;Jasmine&lt;/a&gt;ベースで、APIが似た感じなので、Jasmineとか&lt;a href=&#34;https://mochajs.org/&#34;&gt;Mocha&lt;/a&gt;に慣れた人には特に使いやすい。&lt;/p&gt;

&lt;h2 id=&#34;jestインストール&#34;&gt;Jestインストール&lt;/h2&gt;

&lt;p&gt;ReactプロジェクトでJestを使うには以下のパッケージを入れる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/jest&#34;&gt;jest&lt;/a&gt;: 本体&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/babel-jest&#34;&gt;babel-jest&lt;/a&gt;: BabelでトランスパイルするコードをJestでテストするためのBabelプラグイン&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/react-test-renderer&#34;&gt;react-test-renderer&lt;/a&gt;: ReactコンポーネントをピュアなJavaScriptオブジェクトにレンダリングするライブラリ。&lt;a href=&#34;https://jestjs.io/docs/en/snapshot-testing&#34;&gt;スナップショットテスト&lt;/a&gt;などに使う。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.npmjs.com/package/babel-core/v/7.0.0-bridge.0&#34;&gt;babel-core@^7.0.0-bridge&lt;/a&gt;: babel-jestをBabel 7で使うためのモジュール。&lt;a href=&#34;https://github.com/facebook/jest/tree/master/packages/babel-jest#usage&#34;&gt;現時点では必要&lt;/a&gt;だけど、その内いらなくなるであろう。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D jest babel-jest react-test-renderer babel-core@^7.0.0-bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jestはv23.6.0が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;npm scriptにjestを追加しておくといい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   &amp;quot;scripts&amp;quot;: {
     &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.css&amp;quot;,
     &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
+    &amp;quot;test&amp;quot;: &amp;quot;jest&amp;quot;,
     &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jestセットアップ&#34;&gt;Jestセットアップ&lt;/h2&gt;

&lt;p&gt;Jestの設定ファイルである&lt;a href=&#34;https://jestjs.io/docs/en/configuration&#34;&gt;jest.config.js&lt;/a&gt;をプロジェクトルートに生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn test --init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;プロンプトでいくつかのことを聞かれるが、「Choose the test environment that will be used for testing」に&lt;code&gt;jsdom&lt;/code&gt;で答えるのがポイント。ブラウザで動かすアプリなので。&lt;/p&gt;

&lt;p&gt;設定ファイルはとりあえずおおむね生成されたままでいいけど、一点、v23.4.2時点では、テスト実行時に「SecurityError: localStorage is not available for opaque origins」というエラーが出る&lt;a href=&#34;https://github.com/facebook/jest/issues/6769#issuecomment-408352345&#34;&gt;問題がある&lt;/a&gt;ので、testURLを「&lt;code&gt;http://localhost/&lt;/code&gt;」に設定しておく必要がある。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jest.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// For a detailed explanation regarding each configuration property, visit:
// https://jestjs.io/docs/en/configuration.html

module.exports = {
  // All imported modules in your tests should be mocked automatically
  // automock: false,

  // Stop running tests after the first failure
  // bail: false,

  // Respect &amp;quot;browser&amp;quot; field in package.json when resolving modules
  // browser: false,

  // The directory where Jest should store its cached dependency information
  // cacheDirectory: &amp;quot;C:\\Users\\kaitoy\\AppData\\Local\\Temp\\jest&amp;quot;,

  // Automatically clear mock calls and instances between every test
  // clearMocks: false,

  // Indicates whether the coverage information should be collected while executing the test
  // collectCoverage: false,

  // An array of glob patterns indicating a set of files for which coverage information should be collected
  // collectCoverageFrom: null,

  // The directory where Jest should output its coverage files
  coverageDirectory: &#39;coverage&#39;,

  // An array of regexp pattern strings used to skip coverage collection
  // coveragePathIgnorePatterns: [
  //   &amp;quot;\\\\node_modules\\\\&amp;quot;
  // ],

  // A list of reporter names that Jest uses when writing coverage reports
  // coverageReporters: [
  //   &amp;quot;json&amp;quot;,
  //   &amp;quot;text&amp;quot;,
  //   &amp;quot;lcov&amp;quot;,
  //   &amp;quot;clover&amp;quot;
  // ],

  // An object that configures minimum threshold enforcement for coverage results
  // coverageThreshold: null,

  // Make calling deprecated APIs throw helpful error messages
  // errorOnDeprecated: false,

  // Force coverage collection from ignored files usin a array of glob patterns
  // forceCoverageMatch: [],

  // A path to a module which exports an async function that is triggered once before all test suites
  // globalSetup: null,

  // A path to a module which exports an async function that is triggered once after all test suites
  // globalTeardown: null,

  // A set of global variables that need to be available in all test environments
  // globals: {},

  // An array of directory names to be searched recursively up from the requiring module&#39;s location
  // moduleDirectories: [
  //   &amp;quot;node_modules&amp;quot;
  // ],

  // An array of file extensions your modules use
  // moduleFileExtensions: [
  //   &amp;quot;js&amp;quot;,
  //   &amp;quot;json&amp;quot;,
  //   &amp;quot;jsx&amp;quot;,
  //   &amp;quot;node&amp;quot;
  // ],

  // A map from regular expressions to module names that allow to stub out resources with a single module
  // moduleNameMapper: {},

  // An array of regexp pattern strings, matched against all module paths before considered &#39;visible&#39; to the module loader
  // modulePathIgnorePatterns: [],

  // Activates notifications for test results
  // notify: false,

  // An enum that specifies notification mode. Requires { notify: true }
  // notifyMode: &amp;quot;always&amp;quot;,

  // A preset that is used as a base for Jest&#39;s configuration
  // preset: null,

  // Run tests from one or more projects
  // projects: null,

  // Use this configuration option to add custom reporters to Jest
  // reporters: undefined,

  // Automatically reset mock state between every test
  // resetMocks: false,

  // Reset the module registry before running each individual test
  // resetModules: false,

  // A path to a custom resolver
  // resolver: null,

  // Automatically restore mock state between every test
  // restoreMocks: false,

  // The root directory that Jest should scan for tests and modules within
  // rootDir: null,

  // A list of paths to directories that Jest should use to search for files in
  // roots: [
  //   &amp;quot;&amp;lt;rootDir&amp;gt;&amp;quot;
  // ],

  // Allows you to use a custom runner instead of Jest&#39;s default test runner
  // runner: &amp;quot;jest-runner&amp;quot;,

  // The paths to modules that run some code to configure or set up the testing environment before each test
  // setupFiles: [],

  // The path to a module that runs some code to configure or set up the testing framework before each test
  // setupTestFrameworkScriptFile: null,

  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
  // snapshotSerializers: [],

  // The test environment that will be used for testing
  // testEnvironment: &amp;quot;jest-environment-jsdom&amp;quot;,

  // Options that will be passed to the testEnvironment
  // testEnvironmentOptions: {},

  // Adds a location field to test results
  // testLocationInResults: false,

  // The glob patterns Jest uses to detect test files
  // testMatch: [
  //   &amp;quot;**/__tests__/**/*.js?(x)&amp;quot;,
  //   &amp;quot;**/?(*.)+(spec|test).js?(x)&amp;quot;
  // ],

  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
  // testPathIgnorePatterns: [
  //   &amp;quot;\\\\node_modules\\\\&amp;quot;
  // ],

  // The regexp pattern Jest uses to detect test files
  // testRegex: &amp;quot;&amp;quot;,

  // This option allows the use of a custom results processor
  // testResultsProcessor: null,

  // This option allows use of a custom test runner
  // testRunner: &amp;quot;jasmine2&amp;quot;,

  // This option sets the URL for the jsdom environment. It is reflected in properties such as location.href
  testURL: &#39;http://localhost/&#39;,

  // Setting this value to &amp;quot;fake&amp;quot; allows the use of fake timers for functions such as &amp;quot;setTimeout&amp;quot;
  // timers: &amp;quot;real&amp;quot;,

  // A map from regular expressions to paths to transformers
  // transform: null,

  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
  // transformIgnorePatterns: [
  //   &amp;quot;\\\\node_modules\\\\&amp;quot;
  // ],

  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
  // unmockedModulePathPatterns: undefined,

  // Indicates whether each individual test should be reported during the run
  // verbose: null,

  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
  // watchPathIgnorePatterns: [],

  // Whether to use watchman for file crawling
  // watchman: true,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、例によって、(主にJestのグローバル変数のために、)JestのテストコードとESLintがけんかするので、ESLintをなだめるために&lt;a href=&#34;https://www.npmjs.com/package/eslint-plugin-jest&#34;&gt;eslint-plugin-jest&lt;/a&gt;を入れる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D eslint-plugin-jest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;.eslintrc.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; module.exports = {
   env: {
     browser: true,
+    &#39;jest/globals&#39;: true,
   },
   parser: &#39;babel-eslint&#39;,
   extends: [&#39;airbnb&#39;, &#39;plugin:flowtype/recommended&#39;, &#39;prettier&#39;],
-  plugins: [&#39;flowtype&#39;],
+  plugins: [&#39;flowtype&#39;, &#39;jest&#39;],
 };
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;jestのテスト作成&#34;&gt;Jestのテスト作成&lt;/h2&gt;

&lt;p&gt;Jestのテストは、&lt;code&gt;jest.config.js&lt;/code&gt;の&lt;code&gt;testMatch&lt;/code&gt;にマッチするJavaScriptファイルに書く。
デフォルトでは&lt;code&gt;__test__&lt;/code&gt;ディレクトリ以下に置けばいい。&lt;/p&gt;

&lt;p&gt;テストコードはよくある感じの&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%98%E3%82%A4%E3%83%93%E3%82%A2%E9%A7%86%E5%8B%95%E9%96%8B%E7%99%BA&#34;&gt;BDD&lt;/a&gt;風に書けばいいと思う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/__tests__/reducers/reducers.test.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { hoge } from &#39;../../reducers/reducers&#39;;
import { hogeButtonClicked } from &#39;../../actions/actions&#39;;

const initialState = {
  clicked: false,
};

describe(&#39;reducers&#39;, () =&amp;gt; {
  describe(&#39;hoge()&#39;, () =&amp;gt; {
    test(&#39;returns a state with clicked:true when the action is HOGE_BUTTON_CLICKED&#39;, () =&amp;gt; {
      const state = hogeButtonClicked(initialState, hogeButtonClicked());
      expect(state.clicked).toBe(true);
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;スナップショットテスト&#34;&gt;スナップショットテスト&lt;/h2&gt;

&lt;p&gt;Jestの目玉のひとつは&lt;a href=&#34;https://jestjs.io/docs/ja/snapshot-testing&#34;&gt;スナップショットテスト&lt;/a&gt;。
Reactコンポーネントのレンダリング結果が以前と変わってないかをテストできる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/__tests__/components/HogeButton.test.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import renderer from &#39;react-test-renderer&#39;;
import HogeButton from &#39;../../components/HogeButton&#39;;

describe(&#39;components&#39;, () =&amp;gt; {
  describe(&#39;HogeButton&#39;, () =&amp;gt; {
    test(&#39;renders correctly&#39;, () =&amp;gt; {
      const tree = renderer.create(
        &amp;lt;HogeButton variant=&amp;quot;contained&amp;quot; onClick={() =&amp;gt; {}}&amp;gt;
          HOGE
        &amp;lt;/HogeButton&amp;gt;
      ).toJSON();
      expect(tree).toMatchSnapshot();
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このテストの初回実行時には、&lt;code&gt;src/__tests__/components/__snapshots__/HogeButton.test.jsx.snap&lt;/code&gt;というスナップショットファイルが生成される。
これはテキスト形式で、以下のような人が読み解ける内容。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/__tests__/components/__snapshots__/HogeButton.test.jsx.snap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`components HogeButton renders correctly 1`] = `
&amp;lt;button
  className=&amp;quot;MuiButtonBase-root-25 MuiButton-root-1 MuiButton-contained-10 MuiButton-raised-13&amp;quot;
  disabled={false}
  onBlur={[Function]}
  onClick={[Function]}
  onFocus={[Function]}
  onKeyDown={[Function]}
  onKeyUp={[Function]}
  onMouseDown={[Function]}
  onMouseLeave={[Function]}
  onMouseUp={[Function]}
  onTouchEnd={[Function]}
  onTouchMove={[Function]}
  onTouchStart={[Function]}
  tabIndex=&amp;quot;0&amp;quot;
  type=&amp;quot;button&amp;quot;
&amp;gt;
  &amp;lt;span
    className=&amp;quot;MuiButton-label-2&amp;quot;
  &amp;gt;
    HOGE
  &amp;lt;/span&amp;gt;
  &amp;lt;span
    className=&amp;quot;MuiTouchRipple-root-28&amp;quot;
  /&amp;gt;
&amp;lt;/button&amp;gt;
`;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;スナップショットファイルはコミットしてバージョン管理して、変更があったときには差分を確認する。&lt;/p&gt;

&lt;h1 id=&#34;enzyme&#34;&gt;Enzyme&lt;/h1&gt;

&lt;p&gt;Reactのユニットテストをよりいい感じに書けるようにしてくれるユーティリティライブラリが&lt;a href=&#34;https://airbnb.io/enzyme/&#34;&gt;Enzyme&lt;/a&gt;。
Airbnb製。
Reactコンポーネントをレンダリングして、jQueryみたいなAPIで&lt;a href=&#34;https://airbnb.io/enzyme/docs/api/selector.html&#34;&gt;セレクタ&lt;/a&gt;を指定したりしてエレメントを取得し、アサートするようなテストが書ける。&lt;/p&gt;

&lt;p&gt;Enzymeによるレンダリングには以下の3種類があり、テスト内容によって使い分ける。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://airbnb.io/enzyme/docs/api/shallow.html&#34;&gt;Shallow Rendering&lt;/a&gt;: 浅くレンダリングして、子コンポーネントに影響を受けないテストができる。Reactの&lt;a href=&#34;https://reactjs.org/docs/state-and-lifecycle.html&#34;&gt;ライフサイクルメソッド&lt;/a&gt;も呼んでくれる。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://airbnb.io/enzyme/docs/api/mount.html&#34;&gt;Full Rendering&lt;/a&gt;: &lt;a href=&#34;https://github.com/jsdom/jsdom&#34;&gt;jsdom&lt;/a&gt;などを使って完全なDOMツリーとしてレンダリングする。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://airbnb.io/enzyme/docs/api/render.html&#34;&gt;Static Rendering&lt;/a&gt;: 静的なHTMLに出力して、それをパースする。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Enzymeはv3から本体とアダプタという構成になっていて、Reactのバージョンによってアダプタを使い分ける。
(&lt;a href=&#34;https://preactjs.com/&#34;&gt;preact&lt;/a&gt;とか&lt;a href=&#34;https://infernojs.org/&#34;&gt;Inferno&lt;/a&gt;のアダプタもある。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D enzyme enzyme-adapter-react-16
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Enzymeはv3.7.0が入った。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/FormidableLabs/enzyme-matchers/tree/master/packages/jest-enzyme&#34;&gt;jest-enzyme&lt;/a&gt;も入れるとアサーションがいい感じに書けてよりいいかもしれない。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Full Renderingをやってみる。&lt;/p&gt;

&lt;p&gt;ContainedButtonがクリックされたとき、&lt;code&gt;onClick&lt;/code&gt;に指定した関数が呼ばれることを確認するテストは以下のように書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/__tests__/components/HogeButton.test.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import renderer from &#39;react-test-renderer&#39;;
+import Enzyme, { mount } from &#39;enzyme&#39;;
+import Adapter from &#39;enzyme-adapter-react-16&#39;;
 import HogeButton from &#39;../../components/HogeButton&#39;;

+beforeAll(() =&amp;gt; {
+  Enzyme.configure({ adapter: new Adapter() });
+});

 describe(&#39;components&#39;, () =&amp;gt; {
   describe(&#39;HogeButton&#39;, () =&amp;gt; {
     test(&#39;renders correctly&#39;, () =&amp;gt; {
       const tree = renderer.create(
         &amp;lt;HogeButton variant=&amp;quot;contained&amp;quot; onClick={() =&amp;gt; {}}&amp;gt;
           HOGE
         &amp;lt;/HogeButton&amp;gt;
       ).toJSON();
       expect(tree).toMatchSnapshot();
     });
+
+    test(&amp;quot;calls the passed handler when it&#39;s clicked&amp;quot;, () =&amp;gt; {
+      const handler = jest.fn();
+      const wrapper = mount(&amp;lt;HogeButton onClick={handler} /&amp;gt;);
+      wrapper.find(&#39;button&#39;).simulate(&#39;click&#39;);
+      expect(handler).toHaveBeenCalledTimes(1);
+    });
   });
 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;mount&lt;/code&gt;がFull RenderingのAPIで、内部で&lt;code&gt;react-test-renderer&lt;/code&gt;を使っているみたいなんだけど、&lt;code&gt;mount&lt;/code&gt;のために&lt;code&gt;react-test-renderer&lt;/code&gt;をimportする必要はない。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上で全10回に渡るReact―Redux環境のセットアップ体験記が完結。
の予定だったけど、&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/26/creating-react-redux-app-from-scratch-11/&#34;&gt;次回&lt;/a&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;をやる。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その9: React Router</title>
          <link>https://www.kaitoy.xyz/2018/11/02/creating-react-redux-app-from-scratch-09/</link>
          <pubDate>Fri, 02 Nov 2018 13:45:56 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/11/02/creating-react-redux-app-from-scratch-09/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/&#34;&gt;前回&lt;/a&gt;は&lt;a href=&#34;https://redux-saga.js.org/&#34;&gt;Redux Saga&lt;/a&gt;をセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;フロントエンドのルーティング&#34;&gt;フロントエンドのルーティング&lt;/h1&gt;

&lt;p&gt;Webアプリケーションにおけるルーティングとは、クライアントがリクエストしたURLに対して、返すべきリソースを選択する処理。
昔はバックエンド(i.e. サーバサイド)でやってたけど、バックエンドでリソースを返すということは、ページ遷移が発生するということなので、ネイティブアプリケーションに比べてUXが落ちてしまう。&lt;/p&gt;

&lt;p&gt;一方、ページ遷移を発生させないようにAjaxでサーバとやりとりしつつ、ちまちまDOMをいじるのは大変。
DOMをごっそり書き換えて、ページ遷移なしに画面を切り替えることはできるけど、ナイーブにやると以下のような問題がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;URLと画面の紐づけがなく、URLを指定して直接開けない&lt;/li&gt;
&lt;li&gt;ブラウザの進む、戻るが使えない&lt;/li&gt;
&lt;li&gt;宣言的に書けない&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;こういった問題に対応するため、フロントエンドでのルーティング技術が生まれた。&lt;/p&gt;

&lt;p&gt;フロントエンドのルーティングでは、URLが変わってもリクエストはサーバに飛ばない。
代わりに、フロントエンドフレームワークがそのURLを見て、適切な画面を選んでレンダリングする。&lt;/p&gt;

&lt;h2 id=&#34;ハッシュベースのルーティング&#34;&gt;ハッシュベースのルーティング&lt;/h2&gt;

&lt;p&gt;URLが変わってもリクエストがサーバに飛ばないとは何事か。&lt;/p&gt;

&lt;p&gt;それを実現するやりかたは2通りある。
古くはハッシュ(#、&lt;a href=&#34;https://en.wikipedia.org/wiki/Fragment_identifier&#34;&gt;フラグメント識別子&lt;/a&gt;)をつかったやり方。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;http://example.com/&lt;/code&gt;でUIをサーブしているとすると、&lt;code&gt;http://example.com/#foo&lt;/code&gt;とか、&lt;code&gt;http://example.com/#bar&lt;/code&gt;で別々のページの状態を表現する。
ハッシュ以降が変わってもブラウザがサーバにリクエストを投げることはないので、クライアント側でハンドリングできる。
(因みに、ハッシュを含んだURLをブラウザのアドレスバーに入れても、ハッシュを除いたURLでリクエストが送られる。この挙動の根拠となる規格はRFCなどを調べても見つからなかったけど…)&lt;/p&gt;

&lt;p&gt;ハッシュの書き換えは、JavaScriptで以下のようにしてできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;location.hash = newHash;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こういう処理を、例えばWeb UIのボタンをクリックしたときなんかに実行してURLを変えて、その上で画面を更新してやればいい。&lt;/p&gt;

&lt;p&gt;そのあと、ブラウザの戻るボタンなんかを押されると書き換える前のURLにもどるわけだけど、これを検知するために&lt;code&gt;setInterval()&lt;/code&gt;とかで定期的に&lt;code&gt;location.hash&lt;/code&gt;を監視してたりした。&lt;/p&gt;

&lt;h2 id=&#34;history-apiによるルーティング&#34;&gt;History APIによるルーティング&lt;/h2&gt;

&lt;p&gt;ハッシュベースのルーティングは見るからにしょぼい。
URLのハッシュ以降しか使えないのもしょぼいし、内部の処理も泥臭い。&lt;/p&gt;

&lt;p&gt;これが、HTML 5で&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/History&#34;&gt;History API&lt;/a&gt;がでて変わった。
History APIはJavaScriptのAPIで、ブラウザの履歴を操作できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const state = { hoge: &amp;quot;hogeee&amp;quot; };
history.pushState(state, &amp;quot;&amp;quot;, &amp;quot;/foo/bar&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じのを実行すると、URLが&lt;code&gt;/foo/bar&lt;/code&gt;に変わる。(が、もちろんサーバにはリクエストは飛ばない。)
で、ブラウザの戻るボタンを押すと、&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Events/popstate&#34;&gt;popstate&lt;/a&gt;イベントが発生するので、それにイベントハンドラを登録しておけば、もとのURLに戻った時にも適時画面を書き換えられる。
popstateイベントからは、&lt;code&gt;pushState()&lt;/code&gt;に渡したstateオブジェクトを取得できる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ところで、ブラウザのアドレスバーに&lt;code&gt;/foo/bar&lt;/code&gt;を直打ちするとどうなるかというと、普通にWebサーバを設定しておくと、&lt;code&gt;/foo/bar/index.html&lt;/code&gt;を返そうとして、無いので404エラーになっちゃう。
ので、サーバ設定では、どのURLも同じリソース(e.g. &lt;code&gt;/index.html&lt;/code&gt;)をしといて、そこからJavaScriptを呼んで、URLを読み取って、画面を描いてやればいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;HTML 5が普及するにつれ、このようなHistory APIを使ったフロントエンドルーティングをするフレームワークやライブラリが色々出てきた。んだろうと思う。&lt;/p&gt;

&lt;h1 id=&#34;react-router&#34;&gt;React Router&lt;/h1&gt;

&lt;p&gt;Reactのエコシステムとしては、&lt;a href=&#34;https://reacttraining.com/react-router/&#34;&gt;React Router&lt;/a&gt;がフロントエンドルーティングを実現してくれる。&lt;/p&gt;

&lt;p&gt;React Routerは、宣言的にフロントエンドルーティングを実現できるReactコンポーネントのライブラリ。&lt;/p&gt;

&lt;p&gt;Reduxとともに使う場合は、&lt;a href=&#34;https://github.com/supasate/connected-react-router&#34;&gt;Connected React Router&lt;/a&gt;を使う。
Connected React Routerには&lt;a href=&#34;https://www.npmjs.com/package/history&#34;&gt;history&lt;/a&gt;が必要。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add react-router-dom connected-react-router history
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;React Routerはv4.3.1、Connected React Routerはv5.0.1が入った。&lt;/p&gt;

&lt;h1 id=&#34;connected-react-router導入&#34;&gt;Connected React Router導入&lt;/h1&gt;

&lt;p&gt;まずはConnected React Routerの&lt;a href=&#34;https://github.com/supasate/connected-react-router#usage&#34;&gt;Usage&lt;/a&gt;を参考に、ReduxのReducerにrouterを追加し、MiddlewareにrouterMiddlewareを追加して、historyのインスタンスをStoreとつなぐ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { combineReducers } from &#39;redux&#39;;
+import { connectRouter } from &#39;connected-react-router&#39;;
 import * as reducers from &#39;./reducers&#39;;

-const rootReducer = combineReducers(reducers);
-export default rootReducer;
+const createRootReducer = (history) =&amp;gt;
+  combineReducers({
+    router: connectRouter(history),
+    ...reducers,
+  });
+export default createRootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { createStore, applyMiddleware } from &#39;redux&#39;;
 import createSagaMiddleware from &#39;redux-saga&#39;;
+import { createBrowserHistory } from &#39;history&#39;;
+import { routerMiddleware } from &#39;connected-react-router&#39;;
 import { logger } from &#39;redux-logger&#39;;
 import rootSaga from &#39;./sagas/rootSaga&#39;;
-import rootReducer from &#39;./reducers/rootReducer&#39;;
+import createRootReducer from &#39;./reducers/rootReducer&#39;;

 const sagaMiddleware = createSagaMiddleware();
+export const history = createBrowserHistory();

 export default function configureStore(initialState = {}) {
   const middlewares = [];
   if (process.env.NODE_ENV === `development`) {
     middlewares.push(logger);
   }
+  middlewares.push(routerMiddleware(history));
   middlewares.push(sagaMiddleware);

   const store = createStore(
-    rootReducer,
+    createRootReducer(history),
     initialState,
     applyMiddleware(...middlewares),
   );
   sagaMiddleware.run(rootSaga);
   return store;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、Connected React RouterのConnectedRouterコンポーネントを&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/#provider&#34;&gt;React ReduxのProvider&lt;/a&gt;の下に追加する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/index.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import ReactDOM from &#39;react-dom&#39;;
 import { Provider } from &#39;react-redux&#39;;
+import { ConnectedRouter } from &#39;connected-react-router&#39;;
 import App from &#39;./components/App&#39;;
-import configureStore from &#39;./configureStore&#39;;
+import configureStore, { history } from &#39;./configureStore&#39;;

 const store = configureStore();
 const root = document.getElementById(&#39;root&#39;);

 if (root) {
   ReactDOM.render(
     &amp;lt;Provider store={store}&amp;gt;
-      &amp;lt;App /&amp;gt;
+      &amp;lt;ConnectedRouter history={history}&amp;gt;
+        &amp;lt;App /&amp;gt;
+      &amp;lt;/ConnectedRouter&amp;gt;
     &amp;lt;/Provider&amp;gt;,
     root,
   );
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。
これで、Appコンポーネント以下でReact Routerのコンポーネントを使えるようになった。&lt;/p&gt;

&lt;h1 id=&#34;react-router導入&#34;&gt;React Router導入&lt;/h1&gt;

&lt;p&gt;React Routerの&lt;a href=&#34;https://reacttraining.com/react-router/core/api/Redirect&#34;&gt;Redirect&lt;/a&gt;コンポーネントと&lt;a href=&#34;https://reacttraining.com/react-router/core/api/Route&#34;&gt;Route&lt;/a&gt;コンポーネントを使って、&lt;code&gt;/&lt;/code&gt;にアクセスしたら&lt;code&gt;/home&lt;/code&gt;にリダイレクトして、&lt;code&gt;/home&lt;/code&gt;で今までと同じ画面をレンダリングするようにする。&lt;/p&gt;

&lt;p&gt;まず、App.jsxをHome.jsxにリネームして、Homeコンポーネントに変える。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/Home.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import styled from &#39;styled-components&#39;;
 import HogeButton from &#39;../containers/HogeButton&#39;;
-import Fonts from &#39;../fonts&#39;;

 const Wrapper = styled.div`
   font-size: 5rem;
 `;

-const App = () =&amp;gt; (
+const Home = () =&amp;gt; (
   &amp;lt;Wrapper&amp;gt;
     &amp;lt;HogeButton variant=&amp;quot;contained&amp;quot;&amp;gt;
       HOGE
     &amp;lt;/HogeButton&amp;gt;
-    &amp;lt;Fonts /&amp;gt;
   &amp;lt;/Wrapper&amp;gt;
 );

-export default App;
+export default Home;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、App.jsxはルーティングを定義するコンポーネントとして作り直す。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import { Route, Redirect } from &#39;react-router-dom&#39;;
import Home from &#39;./Home&#39;;
import Fonts from &#39;../fonts&#39;;

const App = () =&amp;gt; (
  &amp;lt;div&amp;gt;
    &amp;lt;Route exact path=&amp;quot;/&amp;quot; render={() =&amp;gt; &amp;lt;Redirect to=&amp;quot;/home&amp;quot; /&amp;gt;} /&amp;gt;
    &amp;lt;Route exact path=&amp;quot;/home&amp;quot; component={Home} /&amp;gt;
    &amp;lt;Fonts /&amp;gt;
  &amp;lt;/div&amp;gt;
);

export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;h1 id=&#34;webpack-dev-serverのhistory-api-fallback&#34;&gt;webpack-dev-serverのHistory API Fallback&lt;/h1&gt;

&lt;p&gt;あとは、上に書いたような404エラーを防ぐために、webpack-dev-serverの&lt;a href=&#34;https://webpack.js.org/configuration/dev-server/#devserver-historyapifallback&#34;&gt;History API Fallback&lt;/a&gt;を有効にしてやる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.dev.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; const path = require(&#39;path&#39;);
 const webpackMerge = require(&#39;webpack-merge&#39;);
 const webpackCommon = require(&#39;./webpack.common.js&#39;);

 module.exports = webpackMerge(webpackCommon, {
   mode: &#39;development&#39;,
   devServer: {
     contentBase: path.join(__dirname, &#39;public&#39;),
     compress: true,
     hot: true,
     port: 3000,
     publicPath: &#39;http://localhost:3000/&#39;,
+    historyApiFallback: true,
   },
 });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておくと、&lt;code&gt;/index.html&lt;/code&gt;以外にリクエストが来た場合、404エラーを返す代わりに&lt;code&gt;/index.html&lt;/code&gt;を返してくれるようになる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/07/creating-react-redux-app-from-scratch-10/&#34;&gt;次回&lt;/a&gt;は&lt;a href=&#34;https://webpack.js.org/guides/code-splitting/&#34;&gt;Code Splitting&lt;/a&gt;と&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;と&lt;a href=&#34;https://jestjs.io/ja/&#34;&gt;Jest&lt;/a&gt;と&lt;a href=&#34;https://airbnb.io/enzyme/&#34;&gt;Enzyme&lt;/a&gt;。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その8: Redux-Saga</title>
          <link>https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/</link>
          <pubDate>Sun, 07 Oct 2018 13:26:22 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/&#34;&gt;前回&lt;/a&gt;は&lt;a href=&#34;https://redux.js.org/basics/usagewithreact&#34;&gt;React Redux&lt;/a&gt;をセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reduxのmiddleware&#34;&gt;ReduxのMiddleware&lt;/h1&gt;

&lt;p&gt;Redux単体では同期的なデータフローしか実装できない。
つまり、Actionを発生させたら、即座にディスパッチされ、stateが更新される。
一方、非同期なフローとは、REST APIを呼んでその結果でstateを更新するような処理。
REST API呼び出しが非同期なわけだが、これをReduxのピュアなフローのどこで実行するのかというと、&lt;a href=&#34;https://redux.js.org/advanced/middleware&#34;&gt;Middleware&lt;/a&gt;で実行する。&lt;/p&gt;

&lt;p&gt;MiddlewareはStoreの&lt;code&gt;dispatch()&lt;/code&gt;をラップして、Actionをトラップして副作用を含む任意の処理をするための機能。
Middlewareの仕組みについては&lt;a href=&#34;https://qiita.com/pirosikick/items/d7f9e5e197a2e8aad62f&#34;&gt;この記事&lt;/a&gt;が分かりやすい。&lt;/p&gt;

&lt;p&gt;Middlewareには例えば、発生したActionの内容と、それによるstateの変化をログに出力する&lt;a href=&#34;https://github.com/evgenyrodionov/redux-logger&#34;&gt;redux-logger&lt;/a&gt;がある。
デバッグに有用そうなので入れておく。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux-logger
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v3.0.6が入った。&lt;/p&gt;

&lt;p&gt;Middlewareは、Reduxの&lt;code&gt;applyMiddleware()&lt;/code&gt;というAPIを使って、&lt;code&gt;createStore()&lt;/code&gt;実行時に適用できる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;-import { createStore } from &#39;redux&#39;;
+import { createStore, applyMiddleware } from &#39;redux&#39;;
+import { logger } from &#39;redux-logger&#39;;
 import rootReducer from &#39;./reducers/rootReducer&#39;;

 export default function configureStore(initialState = {}) {
+  const middlewares = [];
+  if (process.env.NODE_ENV === `development`) {
+    middlewares.push(logger);
+  }
+
   const store = createStore(
     rootReducer,
     initialState,
+    applyMiddleware(...middlewares),
   );
   return store;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。
これで、HOGEボタンをクリックしたときにコンソールに以下のようなログが出るようになる。
(ログは&lt;code&gt;yarn start&lt;/code&gt;とかの開発モードの時だけでる。)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;action HOGE_BUTTON_CLICKED @ 23:19:35.190
 prev state Object { hoge: {…} }
 action Object { type: &amp;quot;HOGE_BUTTON_CLICKED&amp;quot;, payload: undefined }
 next state Object { hoge: {…} }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;非同期処理&#34;&gt;非同期処理&lt;/h1&gt;

&lt;p&gt;非同期処理をするためのMiddlewareには&lt;a href=&#34;https://github.com/reduxjs/redux-thunk&#34;&gt;redux-thunk&lt;/a&gt;とか&lt;a href=&#34;https://github.com/redux-utilities/redux-promise&#34;&gt;redux-promise&lt;/a&gt;とかがあるけど、なかでもGitHubのスター数が一番多い&lt;a href=&#34;https://redux-saga.js.org/&#34;&gt;Redux Saga&lt;/a&gt;を使うことにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux-saga
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v0.16.2が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;因みに次にスター数が多いのがredux-thunkで、これはActionをfunctionオブジェクトで書けるようにするMiddleware。
そのfunctionの中で非同期処理をすることで、非同期なReduxフローを実現できる。
redux-sagaはredux-thunkに比べて以下の特長を持つ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;コールバック地獄に悩まされることが無い&lt;/li&gt;
&lt;li&gt;Actionをプレーン且つピュアに保てるのでテストしやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;redux-sagaの使い方&#34;&gt;Redux Sagaの使い方&lt;/h1&gt;

&lt;p&gt;Redux Sagaでは、非同期処理はSagaというコンポーネントに書く。
Sagaでは、&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;ディスパッチされるActionをWatcherが監視し、&lt;/li&gt;
&lt;li&gt;特定のActionが来たらWorkerを起動し、&lt;/li&gt;
&lt;li&gt;Workerが非同期処理などのTaskを実行し、&lt;/li&gt;
&lt;li&gt;その結果を通知するActionをディスパッチする、&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;といった処理を実行する。&lt;/p&gt;

&lt;p&gt;これらの処理は、Saga Middlewareから呼ばれる&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Generator&#34;&gt;ジェネレータ関数&lt;/a&gt;のなかで、EffectというオブジェクトをSaga Middlewareに返すことで、Saga Middlewareに指示して実行させる。
このEffectを生成する&lt;a href=&#34;https://redux-saga.js.org/docs/api/&#34;&gt;API&lt;/a&gt;がRedux Sagaからいろいろ提供されている。&lt;/p&gt;

&lt;p&gt;上記処理の1~4はそれぞれ以下のAPIで実装できる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;take(pattern)&lt;/code&gt;: ディスパッチされるActionを監視して、&lt;code&gt;pattern&lt;/code&gt;にマッチしたら取得するEffectを生成する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork(fn, ...args)&lt;/code&gt;: 渡された関数&lt;code&gt;fn&lt;/code&gt;をノンブロッキングで呼び出すEffectを生成する。&lt;code&gt;fn&lt;/code&gt;はジェネレータか&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;を返す関数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;call(fn, ...args)&lt;/code&gt;: 渡された関数&lt;code&gt;fn&lt;/code&gt;を同期的に呼び出すEffectを生成する。&lt;code&gt;fn&lt;/code&gt;はジェネレータか&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;を返す関数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;put(action)&lt;/code&gt;: Actionオブジェクトの&lt;code&gt;action&lt;/code&gt;をディスパッチするEffectを生成する。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;rest-api呼び出し&#34;&gt;REST API呼び出し&lt;/h1&gt;

&lt;p&gt;非同期実行で最もよくあるのがREST API呼び出しであろう。
REST API呼び出し処理は&lt;code&gt;call()&lt;/code&gt;で実行するわけだけど、&lt;code&gt;call()&lt;/code&gt;にはPromiseを返す必要があるので、使うライブラリはそこを考慮しないといけない。&lt;/p&gt;

&lt;p&gt;ざっと調べたところ、&lt;a href=&#34;https://www.npmjs.com/package/axios&#34;&gt;axios&lt;/a&gt;、&lt;a href=&#34;https://www.npmjs.com/package/superagent&#34;&gt;SuperAgent&lt;/a&gt;、&lt;a href=&#34;https://www.npmjs.com/package/r2&#34;&gt;r2&lt;/a&gt;あたりが選択肢。
最も人気のあるaxiosを使うことにする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add axios
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v0.18.0が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;REST API呼び出しのコードは&lt;code&gt;src/services/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/services/api.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import axios from &#39;axios&#39;;

export const HOGE_URL = &#39;https://httpbin.org/get&#39;;

export function getHoge() {
  return axios.get(HOGE_URL);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;getHoge()&lt;/code&gt;はGETリクエストを送ってPromiseオブジェクトを返す。
このPromiseオブジェクトはレスポンスボディやステータスコードを保持する&lt;a href=&#34;https://github.com/axios/axios#response-schema&#34;&gt;Response&lt;/a&gt;オブジェクトに解決される。&lt;/p&gt;

&lt;h1 id=&#34;rest-api呼び出しを表現するaction&#34;&gt;REST API呼び出しを表現するAction&lt;/h1&gt;

&lt;p&gt;REST API呼び出しをする場合、呼び出し開始、呼び出し成功、呼び出し失敗の3種類のActionで表現するのが一つの&lt;a href=&#34;https://redux.js.org/advanced/asyncactions&#34;&gt;プラクティス&lt;/a&gt;。
これら3種類を、同一のtypeのActionのプロパティ値を変えて表現するやりかたもあるけど、ここでは別々のtypeのアクションとする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/actions/actionTypes.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; export const HOGE_BUTTON_CLICKED = &#39;HOGE_BUTTON_CLICKED&#39;;
+export const HOGE_FETCH_SUCCEEDED = &#39;HOGE_FETCH_SUCCEEDED&#39;;
+export const HOGE_FETCH_FAILED = &#39;HOGE_FETCH_FAILED&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/actions/actions.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import {
   HOGE_BUTTON_CLICKED,
+  HOGE_FETCH_SUCCEEDED,
+  HOGE_FETCH_FAILED,
 } from &#39;./actionTypes&#39;;

 export function hogeButtonClicked() {
   return {
     type: HOGE_BUTTON_CLICKED,
   };
 }
+
+export function hogeFetchSucceeded(payload, meta) {
+  return {
+    type: HOGE_FETCH_SUCCEEDED,
+    payload,
+    meta,
+  };
+}
+
+export function hogeFetchFailed(payload) {
+  return {
+    type: HOGE_FETCH_FAILED,
+    error: true,
+    payload,
+  };
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;sagaの実装&#34;&gt;Sagaの実装&lt;/h1&gt;

&lt;p&gt;Sagaのソースは&lt;code&gt;src/sagas/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;が来たら&lt;code&gt;getHoge()&lt;/code&gt;を実行するSagaは以下のような感じ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/sagas/hoge.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { call, fork, put, take } from &#39;redux-saga/effects&#39;;
import { getHoge } from &#39;../services/apis&#39;;
import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;
import { hogeFetchSucceeded, hogeFetchFailed } from &#39;../actions/actions&#39;;

// Task
function* fetchHoge() {
  try {
    const response = yield call(getHoge);
    const payload = response.data;
    const meta = { statusCode: response.status, statusText: response.statusText };
    yield put(hogeFetchSucceeded(payload, meta));
  } catch (ex) {
    yield put(hogeFetchFailed(ex));
  }
}

// Watcher
export function* watchHogeButtonClicked(): Generator&amp;lt;any, void, Object&amp;gt; {
  while (true) {
    const action = yield take(HOGE_BUTTON_CLICKED);
    yield fork(fetchHoge, action); // actionはfetchHogeの引数に渡される。使ってないけど…
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Watcherは&lt;code&gt;take&lt;/code&gt;して&lt;code&gt;fork&lt;/code&gt;するのを無限ループで回すのが常なので、これをもうちょっときれいに書けるAPIが用意されていて、以下のように書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { takeEvery } from &#39;redux-saga/effects&#39;

// Watcher
export function* watchHogeButtonClicked(): Generator&amp;lt;any, void, Object&amp;gt; {
  yield takeEvery(HOGE_BUTTON_CLICKED, fetchHoge)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この場合、&lt;code&gt;fetchHoge()&lt;/code&gt;の最後の引数に&lt;code&gt;take&lt;/code&gt;したActionオブジェクトが渡される。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、今後Watcherはモジュールを分けていくつも書いていくことになるので、それらをまとめて起動するためのモジュール&lt;code&gt;rootSaga.js&lt;/code&gt;を作って、そこで各Watcherを&lt;code&gt;import&lt;/code&gt;して&lt;code&gt;call()&lt;/code&gt;したい。
&lt;code&gt;call()&lt;/code&gt;はブロッキングなAPIなので、パラレルに実行するために&lt;code&gt;all()&lt;/code&gt;を使う。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/sagas/rootSaga.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { call, all } from &#39;redux-saga/effects&#39;;
import { watchHogeButtonClicked } from &#39;./hoge&#39;;

export default function* rootSaga() {
  yield all([
    call(watchHogeButtonClicked),
    // call(watchAnotherAction),
    // call(watchYetAnotherAction),
  ]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そもそもブロッキングな&lt;code&gt;call()&lt;/code&gt;を使うのがだめなので、代わりに&lt;code&gt;fork()&lt;/code&gt;を使ってもいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/sagas/rootSaga.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { fork } from &#39;redux-saga/effects&#39;;
import { watchHogeButtonClicked } from &#39;./hoge&#39;;

export default function* rootSaga() {
  yield fork(watchHogeButtonClicked);
  // yield fork(watchAnotherAction);
  // yield fork(watchYetAnotherAction);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;どっちがいいんだろう。&lt;/p&gt;

&lt;h1 id=&#34;saga-middlewareの追加と起動&#34;&gt;Saga Middlewareの追加と起動&lt;/h1&gt;

&lt;p&gt;Saga Middlewareは以下のように追加して起動する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { createStore, applyMiddleware } from &#39;redux&#39;;
+import createSagaMiddleware from &#39;redux-saga&#39;;
 import { logger } from &#39;redux-logger&#39;;
+import rootSaga from &#39;./sagas/rootSaga&#39;;
 import rootReducer from &#39;./reducers/rootReducer&#39;;

+const sagaMiddleware = createSagaMiddleware();

 export default function configureStore(initialState = {}) {
   const middlewares = [];
   if (process.env.NODE_ENV === `development`) {
     middlewares.push(logger);
   }
+  middlewares.push(sagaMiddleware);

   const store = createStore(
     rootReducer,
     initialState,
     applyMiddleware(...middlewares),
   );
+  sagaMiddleware.run(rootSaga);
   return store;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/11/02/creating-react-redux-app-from-scratch-09/&#34;&gt;次回&lt;/a&gt;は&lt;a href=&#34;https://reacttraining.com/react-router/&#34;&gt;React Router&lt;/a&gt;。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その7: React Redux</title>
          <link>https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/</link>
          <pubDate>Mon, 01 Oct 2018 07:54:53 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/&#34;&gt;前回&lt;/a&gt;はReduxをセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;react-redux&#34;&gt;React Redux&lt;/h1&gt;

&lt;p&gt;前回はReduxをセットアップして、ActionをStoreにディスパッチしてstateを更新できるようになった。
今回はこれをReactにつなぐ。&lt;/p&gt;

&lt;p&gt;使うのは&lt;a href=&#34;https://redux.js.org/basics/usagewithreact&#34;&gt;React Redux&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add react-redux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v5.1.1が入った。&lt;/p&gt;

&lt;h1 id=&#34;presentational-components-と-container-components&#34;&gt;Presentational Components と Container Components&lt;/h1&gt;

&lt;p&gt;React Reduxの使い方を理解するには、&lt;a href=&#34;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0&#34;&gt;Presentational Components と Container Components&lt;/a&gt; という概念を知らないといけない。
これはReactコンポーネントを役割別に分ける考え方で、それぞれ以下のような特徴をもつ。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Presentational Components&lt;/th&gt;
&lt;th&gt;Container Components&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;主な役割&lt;/td&gt;
&lt;td&gt;DOMをレンダリングする&lt;/td&gt;
&lt;td&gt;データを取得したりstateを更新したりする(Reduxとつなぐ)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Reduxとの関連&lt;/td&gt;
&lt;td&gt;無し&lt;/td&gt;
&lt;td&gt;有り&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;データの読み込み&lt;/td&gt;
&lt;td&gt;propsから読む&lt;/td&gt;
&lt;td&gt;Reduxのstateオブジェクトから読む&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;データの更新&lt;/td&gt;
&lt;td&gt;propsで渡されたコールバックを呼ぶ&lt;/td&gt;
&lt;td&gt;ReduxのActionをディスパッチする&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;作り方&lt;/td&gt;
&lt;td&gt;自前で書く&lt;/td&gt;
&lt;td&gt;React Reduxで生成する&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;要するに、普通にReactで作ったUIコンポーネントを、React Reduxで生成するContainer ComponentでラップしてやることでReduxのStoreとつなぐことができる。&lt;/p&gt;

&lt;h1 id=&#34;connect&#34;&gt;connect()&lt;/h1&gt;

&lt;p&gt;Container Componentの生成にはReact Reduxの&lt;a href=&#34;https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&#34;&gt;connect()&lt;/a&gt;というAPIを使う。&lt;/p&gt;

&lt;p&gt;React Reduxを使う場合、Reduxのstateの更新に応じてReactコンポーネントに新しいpropsを渡して再レンダリングすることになるが、この新しいpropsを作ってコンポーネントに渡す処理を定義するのが&lt;code&gt;connect()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;の第一引数には、ReduxのstateのプロパティとReactコンポーネントのpropsのプロパティとのマッピングをする関数である&lt;code&gt;mapStateToProps()&lt;/code&gt;を渡す。
&lt;code&gt;mapStateToProps()&lt;/code&gt;はstateの更新に応じて呼び出され、引数にstate(と現在のprops)が渡される。
&lt;code&gt;mapStateToProps()&lt;/code&gt;が返すオブジェクトはReactコンポーネントに渡されるpropsにマージされる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;の第二引数には、Storeの&lt;code&gt;dispatch()&lt;/code&gt;を呼び出す処理とReactコンポーネントのpropsのプロパティとのマッピングをする関数である&lt;code&gt;mapDispatchToProps()&lt;/code&gt;を渡す。
&lt;code&gt;mapDispatchToProps()&lt;/code&gt;の引数には&lt;code&gt;dispatch()&lt;/code&gt;が渡される。
&lt;code&gt;mapDispatchToProps()&lt;/code&gt;が返すオブジェクトはReactコンポーネントに渡されるpropsにマージされる。&lt;/p&gt;

&lt;p&gt;(&lt;code&gt;mapDispatchToProps()&lt;/code&gt;は第二引数に&lt;code&gt;props&lt;/code&gt;を受け取ることもできて、この場合、propsの更新に反応して呼び出されるコールバックになる。)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;connect()&lt;/code&gt;を実行すると関数が返ってくる。
この関数にReactコンポーネント(Presentational Component)を渡して実行すると、Storeに接続されたReactコンポーネント(Container Component)が返ってくる。&lt;/p&gt;

&lt;h2 id=&#34;connect-の使い方&#34;&gt;connect()の使い方&lt;/h2&gt;

&lt;p&gt;前回作ったStoreをHOGEボタン(これはPresentational Component)につなげるContainer Componentを書いてみる。
Container Componentのソースは&lt;code&gt;src/containers/&lt;/code&gt;に入れる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/containers/HogeButton.jsx&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import Button from &#39;@material-ui/core/Button&#39;;
import { connect } from &#39;react-redux&#39;;
import { hogeButtonClicked } from &#39;../actions/actions&#39;;

function mapStateToProps(state) {
  return {
    clicked: state.hoge.clicked
  };
}

function mapDispatchToProps(dispatch) {
  return {
    onClick: function() {
      dispatch(hogeButtonClicked());
    }
  };
}

const HogeButton = connect(
  mapStateToProps,
  mapDispatchToProps,
)(Button);

export default HogeButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;p&gt;HOGEボタンをクリックすると、以下の流れで状態が遷移する。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;hogeButtonClicked()&lt;/code&gt;が呼ばれて&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;アクションが生成されてdispatchされる。&lt;/li&gt;
&lt;li&gt;Storeの中で&lt;code&gt;state.hoge.clicked&lt;/code&gt;が更新される。&lt;/li&gt;
&lt;li&gt;stateの更新に反応して&lt;code&gt;mapStateToProps()&lt;/code&gt;が呼び出され、その戻り値がpropsにマージされる。&lt;/li&gt;
&lt;li&gt;新しいpropsを使って、新たにHOGEボタンがレンダリングされる。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;connect-のシンプルな書き方&#34;&gt;connect()のシンプルな書き方&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;mapDispatchToProps&lt;/code&gt;は実はプレーンオブジェクトでもいい。
この場合、オブジェクトのキーと値はそれぞれ、propsのプロパティ名とAction Creatorにする。
(Action Creatorは&lt;code&gt;connect()&lt;/code&gt;が&lt;code&gt;dispatch()&lt;/code&gt;でラップしてくれる。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const mapDispatchToProps ⁼ {
  onClick: hogeButtonClicked,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、&lt;code&gt;mapStateToProps&lt;/code&gt;と&lt;code&gt;mapDispatchToProps&lt;/code&gt;はexportするわけでも再利用するわけでもないので、&lt;code&gt;connect()&lt;/code&gt;の中に直接書いてしまってもいい。
この場合、&lt;code&gt;mapStateToProps&lt;/code&gt;はアロー関数で書いて、&lt;code&gt;return&lt;/code&gt;は省略してしまうのがいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HogeButton = connect(
  (state) =&amp;gt; ({
    clicked: state.hoge.clicked
  }),
  {
    onClick: hogeButtonClicked,
  },
)(Button);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;さらに、&lt;code&gt;mapStateToProps&lt;/code&gt;が受け取る&lt;code&gt;state&lt;/code&gt;は、&lt;code&gt;hoge&lt;/code&gt;プロパティしか興味ないので、オブジェクト分割代入をするのがいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const HogeButton = connect(
  ({hoge}) =&amp;gt; ({
    clicked: hoge.clicked
  }),
  {
    onClick: hogeButtonClicked,
  },
)(Button);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;まとめると、以下のように書けるということ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/containers/HogeButton.jsx&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import Button from &#39;@material-ui/core/Button&#39;;
import { connect } from &#39;react-redux&#39;;
import { hogeButtonClicked } from &#39;../actions/actions&#39;;

const HogeButton = connect(
  ({hoge}) =&amp;gt; ({
    clicked: hoge.clicked
  }),
  {
    onClick: hogeButtonClicked,
  },
)(Button);

export default HogeButton;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;参考: &lt;a href=&#34;https://qiita.com/taneba/items/4d45d1075137a7dae10e&#34;&gt;シンプルなreact-reduxのconnectの書き方&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;reselect&#34;&gt;reselect&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;mapStateToProps&lt;/code&gt;はstateが更新されるたびに呼ばれるので、中で複雑な計算してたりするとアプリ全体のパフォーマンスに影響を与える。&lt;/p&gt;

&lt;p&gt;このような問題に対応するため、stateの特定のサブツリーが更新された時だけ&lt;code&gt;mapStateToProps&lt;/code&gt;の先の計算を実行できるようにするライブラリがある。
それが&lt;a href=&#34;https://github.com/reduxjs/reselect&#34;&gt;relesect&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;reselectは重要なライブラリだとは思うけど、とりあえずほって先に進む。&lt;/p&gt;

&lt;h1 id=&#34;hogebuttonのアプリへの組み込み&#34;&gt;HogeButtonのアプリへの組み込み&lt;/h1&gt;

&lt;p&gt;作ったHogeButtonは、普通のコンポーネントと同じように使える。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import styled from &#39;styled-components&#39;;
-import Button from &#39;@material-ui/core/Button&#39;;
+import HogeButton from &#39;../containers/HogeButton&#39;;
 import Fonts from &#39;../fonts&#39;;

 const Wrapper = styled.div`
   font-size: 5rem;
 `;

 const App = () =&amp;gt; (
   &amp;lt;Wrapper&amp;gt;
-    &amp;lt;Button variant=&amp;quot;contained&amp;quot;&amp;gt;
+    &amp;lt;HogeButton variant=&amp;quot;contained&amp;quot;&amp;gt;
       HOGE
-    &amp;lt;/Button&amp;gt;
+    &amp;lt;/HogeButton&amp;gt;
     &amp;lt;Fonts /&amp;gt;
   &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;provider&#34;&gt;Provider&lt;/h1&gt;

&lt;p&gt;全てのContainer ComponentsがReduxのStoreの変更をサブスクライブする必要があるので、それらに&lt;a href=&#34;https://redux.js.org/basics/usagewithreact#passing-the-store&#34;&gt;Storeを渡してやらないといけない&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Storeをpropsに渡して、子コンポーネントにバケツリレーさせたりして行きわたらせることも可能だけど面倒すぎる。
ので、React Reduxがもっと簡単にやる仕組みを提供してくれている。
それが&lt;a href=&#34;https://github.com/reduxjs/react-redux/blob/master/docs/api.md#provider&#34;&gt;Provider&lt;/a&gt;というコンポーネント。&lt;/p&gt;

&lt;p&gt;Providerの子コンポーネントはStoreにアクセスして&lt;code&gt;connect()&lt;/code&gt;を使えるようになる。
ざっくり全体をProviderで囲ってやるのがいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/index.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import ReactDOM from &#39;react-dom&#39;;
+import { Provider } from &#39;react-redux&#39;;
 import App from &#39;./components/App&#39;;
+import configureStore from &#39;./configureStore&#39;;

+const store = configureStore();
 const root = document.getElementById(&#39;root&#39;);

 if (root) {
   ReactDOM.render(
-    &amp;lt;App /&amp;gt;,
+    &amp;lt;Provider store={store}&amp;gt;
+      &amp;lt;App /&amp;gt;
+    &amp;lt;/Provider&amp;gt;,
     root,
   );
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/07/creating-react-redux-app-from-scratch-08/&#34;&gt;次回&lt;/a&gt;は、ReduxにMiddlewareを追加して、非同期処理を実装する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その6: Redux</title>
          <link>https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/</link>
          <pubDate>Wed, 26 Sep 2018 23:03:04 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/&#34;&gt;前回&lt;/a&gt;はMaterial-UIをセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reactの状態管理&#34;&gt;Reactの状態管理&lt;/h1&gt;

&lt;p&gt;Reactによるプログラミングをするとき、小さいUIコンポーネントをたくさん作って、それらを組み合わせてVirtual DOMツリーを作っておいて、そこにpropsをほうりこんでレンダリングする、という感じになる。
また、レンダリングした後はコンポーネントのstateをいじって状態を変化させる。&lt;/p&gt;

&lt;p&gt;このpropsやstateの扱いをReactの状態管理という。
propsやstateを適当にアドホックに設定してると、結局jQuery使ってるのとそんなに変わらなくなって辛くなるので、Reactの開発元であるFacebookは&lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;Flux&lt;/a&gt;というアーキテクチャを提案している。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/flux/raw/master/docs/img/flux-diagram-white-background.png&#34; alt=&#34;Flux&#34; title=&#34;Flux&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Fluxでは、単一の(またはドメイン毎くらいの単位の)オブジェクトでアプリケーション全体の状態(state)を表し、これをStoreに保持する。
ReactはStoreが保持するstateを受け取り、それをもとにViewをレンダリングする。
Viewに対するユーザの操作(など)はActionというオブジェクトで表現され、Dispatcherに渡され、Dispatcherに登録されたcallbackを通してstateを変化させる。&lt;/p&gt;

&lt;p&gt;データが常に一方向に流れて見通しがよく、各コンポーネントの独立性が高いのが特徴。
各コンポーネントは、受け取ったデータをピュアに処理すればよく、リアクティブにファンクショナルに実装できる。&lt;/p&gt;

&lt;h1 id=&#34;redux&#34;&gt;Redux&lt;/h1&gt;

&lt;p&gt;Fluxの実装、というか発展形がRedux。&lt;/p&gt;

&lt;p&gt;ReduxではFluxのDispatcher辺りがReducerに置き換わっている。
ReducerはActionと現在のstateから次のstateを計算する純粋関数。&lt;/p&gt;

&lt;p&gt;また、ReduxからはViewが切り離されていて、Actionによってstateを更新する状態管理ライブラリの役割に徹している。
ReactコンポーネントのイベントハンドラからActionオブジェクトを生成したり、更新したstateをReactに渡したりするつなぎ目は、別途&lt;a href=&#34;https://github.com/reduxjs/react-redux&#34;&gt;React Redux&lt;/a&gt;というライブラリが担当する。&lt;/p&gt;

&lt;p&gt;ReduxとReact Reduxについては、Qiitaの「&lt;a href=&#34;https://qiita.com/mpyw/items/a816c6380219b1d5a3bf&#34;&gt;たぶんこれが一番分かりやすいと思います React + Redux のフロー図解&lt;/a&gt;」という記事が分かりやすい。&lt;/p&gt;

&lt;p&gt;今回はReduxを導入する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add redux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Redux v4.0.1が入った。&lt;/p&gt;

&lt;p&gt;以降、現時点で唯一のUIコンポーネントであるHOGEボタンの状態管理を実装してみる。&lt;/p&gt;

&lt;h2 id=&#34;action&#34;&gt;Action&lt;/h2&gt;

&lt;p&gt;まず&lt;a href=&#34;https://redux.js.org/basics/actions&#34;&gt;Action&lt;/a&gt;を実装する。&lt;/p&gt;

&lt;p&gt;Actionオブジェクトはどんな形式でもいいけど、普通は&lt;a href=&#34;https://github.com/redux-utilities/flux-standard-action&#34;&gt;Flux Standard Action&lt;/a&gt;(FSA)にする。
FSAは以下のプロパティを持つプレーンオブジェクト。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type: Action種別を示す文字列定数。必須。&lt;/li&gt;
&lt;li&gt;payload: Actionの情報を示す任意の型の値。任意。&lt;/li&gt;
&lt;li&gt;error: Actionがエラーを表すものかを示す boolean プロパティ。エラーなら true にして、payload にエラーオブジェクトをセットする。任意。&lt;/li&gt;
&lt;li&gt;meta: その他の情報を入れる任意の型の値。任意。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Actionのコードは、Actionのtypeに入れる値を定義する&lt;code&gt;actionTypes.js&lt;/code&gt;と、Action Creator(i.e. Actionオブジェクトを生成する関数)を定義する&lt;code&gt;actions.js&lt;/code&gt;からなり、ともに&lt;code&gt;src/actions/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;HOGEボタンをクリックしたときのAction、&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;を定義してみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/actions/actionTypes.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;export const HOGE_BUTTON_CLICKED = &#39;HOGE_BUTTON_CLICKED&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/actions/actions.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import {
  HOGE_BUTTON_CLICKED,
} from &#39;./actionTypes&#39;;

export function hogeButtonClicked() {
  return {
    type: HOGE_BUTTON_CLICKED,
  };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じ。&lt;/p&gt;

&lt;h2 id=&#34;reducer&#34;&gt;Reducer&lt;/h2&gt;

&lt;p&gt;次は&lt;a href=&#34;https://redux.js.org/basics/reducers&#34;&gt;Reducer&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Reducerは、上記Action Creatorが生成するActionオブジェクトに対応して起動し、Store(後述)から現在のstateオブジェクトを受け取って、Actionオブジェクトのpayloadの値(など)に応じて新しいstateオブジェクトを作る。&lt;/p&gt;

&lt;p&gt;Reducerを書く前に、stateオブジェクトの構造を設計しておくことが推奨されている。
UIコンポーネント毎にプロパティを分けて、コンポーネント構造と同様の階層構造にしておけばだいたいよさそう。&lt;/p&gt;

&lt;p&gt;HOGEボタンに一つ、クリックしたかどうかの状態(&lt;code&gt;clicked&lt;/code&gt;)を持たせるとすると、stateオブジェクトは以下のようになる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;{
  hoge: {
    clicked: false,
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Reducerはピュアじゃないといけないので、内部で&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0&#34;&gt;副作用&lt;/a&gt;を起こしてはいけない。
副作用とは、具体的には以下のようなもの。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;引数で与えられたオブジェクトを変更する。&lt;/li&gt;
&lt;li&gt;REST APIへのリクエストを送る。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(ログの出力も厳密には副作用なんだろうけど、それは許されてる気がする。)&lt;/p&gt;

&lt;p&gt;また、ピュアであるためには&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E5%8F%82%E7%85%A7%E9%80%8F%E9%81%8E%E6%80%A7&#34;&gt;参照透過性&lt;/a&gt;を持たないといけなくて、つまり同じ引数に対しては同じ戻り値を返さないといけないので、内部で&lt;code&gt;Date.now()&lt;/code&gt;とか&lt;code&gt;Math.random()&lt;/code&gt;とかを呼ぶのもダメ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Reducerのコードは&lt;code&gt;src/reducers/&lt;/code&gt;に置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;が発生したら、&lt;code&gt;hoge&lt;/code&gt;の&lt;code&gt;clicked&lt;/code&gt;を&lt;code&gt;true&lt;/code&gt;にするReducer(&lt;code&gt;hoge()&lt;/code&gt;)は以下の感じに書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;

const initialState = {
  hoge: {
    clicked: false,
  },
};

export const hoge = (state = initialState, action) =&amp;gt; {
  switch (action.type) {
    case HOGE_BUTTON_CLICKED:
      const newHoge = {
        hoge: {
          clicked: true,
        },
      };
      return Object.assign({}, state, newHoge);
    default:
      return state;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hoge()&lt;/code&gt;のポイントはたくさんある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;state&lt;/code&gt;と&lt;code&gt;action&lt;/code&gt;を引数に取る。前者が現在の状態を表すstateオブジェクトで、後者がActionオブジェクト。&lt;/li&gt;
&lt;li&gt;戻り値は新しい状態を表すstateオブジェクト。&lt;/li&gt;
&lt;li&gt;actionオブジェクトはどのActionを表すものかは分からないので、&lt;code&gt;action.type&lt;/code&gt;を見て&lt;code&gt;HOGE_BUTTON_CLICKED&lt;/code&gt;だけを処理するようにする。

&lt;ul&gt;
&lt;li&gt;知らないActionだったら(i.e. &lt;code&gt;default&lt;/code&gt;句のなかに来たら)、受け取ったstateオブジェクトをそのまま返す。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;アプリケーションの初期化時には&lt;code&gt;state&lt;/code&gt;に&lt;code&gt;undefined&lt;/code&gt;が渡されるので、それに備え、初期状態である&lt;code&gt;initialState&lt;/code&gt;をデフォルト引数に設定する。&lt;/li&gt;
&lt;li&gt;渡されたstateオブジェクトを変更してはいけないので、&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&#34;&gt;Object.assgin()&lt;/a&gt;に空オブジェクト&lt;code&gt;{}&lt;/code&gt;とともに&lt;code&gt;state&lt;/code&gt;を渡してコピーする。

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Object.assgin()&lt;/code&gt;の代わりに&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E5%88%86%E5%89%B2%E4%BB%A3%E5%85%A5&#34;&gt;オブジェクト分割代入&lt;/a&gt;を使う方法も&lt;a href=&#34;https://redux.js.org/recipes/usingobjectspreadoperator&#34;&gt;ある&lt;/a&gt;。この場合&lt;a href=&#34;https://babeljs.io/docs/en/babel-plugin-transform-object-rest-spread&#34;&gt;babel-plugin-transform-object-rest-spread&lt;/a&gt;が必要。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Object.assign()&lt;/code&gt;の第三引数に&lt;code&gt;newHoge&lt;/code&gt;で上書きするようにしている。

&lt;ul&gt;
&lt;li&gt;今はstateオブジェクトのプロパティが&lt;code&gt;hoge&lt;/code&gt;一つだけなので単に&lt;code&gt;newHoge&lt;/code&gt;をreturnしても結果は一緒。なので無駄なことをしてるようにも見えるけど、stateオブジェクトのプロパティが増えた場合に&lt;code&gt;hoge&lt;/code&gt;以外に影響を与えないための計らい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;これはこれでいい感じに見えるけど、&lt;code&gt;hoge()&lt;/code&gt;が&lt;code&gt;hoge&lt;/code&gt;プロパティしか扱わないのに、stateオブジェクト全体を渡しているのがイケていない。
(まあ今はstateオブジェクトには&lt;code&gt;hoge&lt;/code&gt;プロパティしかないんだけど、他のプロパティが色々増えてくるとイケてない感が高まる。)
&lt;code&gt;hoge&lt;/code&gt;プロパティがstateオブジェクト構造のどこにあるかを&lt;code&gt;hoge()&lt;/code&gt;が気にしないといけないのもイケてない。
&lt;code&gt;hoge()&lt;/code&gt;には&lt;code&gt;hoge&lt;/code&gt;プロパティだけを見てほしい。&lt;/p&gt;

&lt;p&gt;ということで、普通はReducerは分割して書いて、それぞれのReducerにstateオブジェクトを分割して渡してやる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/reducers.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import { HOGE_BUTTON_CLICKED } from &#39;../actions/actionTypes&#39;;

-const initialState = {
-  hoge: {
-    clicked: false,
-  },
-};

-export const hoge = (state = initialState, action) =&amp;gt; {
+export const hoge = (state = { clicked: false }, action) =&amp;gt; {
   switch (action.type) {
     case HOGE_BUTTON_CLICKED:
       const newHoge = {
-        hoge: {
-          clicked: true,
-        },
+        clicked: true,
       };
       return Object.assign({}, state, newHoge);
     default:
       return state;
   }
 }

+export const rootReducer = (state = {}, action) =&amp;gt; {
+  return {
+    hoge: hoge(state.hoge, action),
+  }
+}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな感じで、&lt;code&gt;rootReducer&lt;/code&gt;がstateオブジェクトを分割して子Reducerを呼び出す。
孫Reducerとか曾孫Reducerとかがあってもいい。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;rootReducer&lt;/code&gt;は別のファイルに書くと見やすくなるし、Reduxの&lt;a href=&#34;https://redux.js.org/api/combinereducers&#34;&gt;combineReducers()&lt;/a&gt;というヘルパー関数を使うともっと楽に書ける。
上記&lt;code&gt;reducers.js&lt;/code&gt;からは&lt;code&gt;rootReducer&lt;/code&gt;を削除して、&lt;code&gt;rootReducer.js&lt;/code&gt;に以下のように書く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { combineReducers } from &#39;redux&#39;;
import hoge from &#39;./reducers&#39;;

const rootReducer = combineReducers({
  hoge,
});
export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このように&lt;code&gt;combineReducers()&lt;/code&gt;で作った&lt;code&gt;rootReducer&lt;/code&gt;は、上で自前で書いた&lt;code&gt;rootReducer&lt;/code&gt;と全く同じ動きをする。&lt;/p&gt;

&lt;p&gt;さらに簡単に、以下のようにも書ける。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/reducers/rootReducer.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { combineReducers } from &#39;redux&#39;;
import * as reducers from &#39;./reducers&#39;;

const rootReducer = combineReducers(reducers);
export default rootReducer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておけば、Reducerの追加は&lt;code&gt;reducers.js&lt;/code&gt;に関数を追加するだけでよくなる。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/redux-utilities/redux-actions&#34;&gt;redux-actions&lt;/a&gt;を使うとさらに記述を簡略化できるみたいだけど、逆に何が何だか分からなくなりそうだったので、慣れるまでは使わないでおく。&lt;/p&gt;

&lt;h2 id=&#34;store&#34;&gt;Store&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://redux.js.org/basics/store&#34;&gt;Store&lt;/a&gt;は以下のような特徴を持つオブジェクト。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState()&lt;/code&gt;でstateオブジェクトを返す。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;でActionをディスパッチできる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;でActionのディスパッチをサブスクライブできる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;StoreはrootReducerを&lt;a href=&#34;https://redux.js.org/api/createstore&#34;&gt;createStore()&lt;/a&gt;に渡すことで作れる。
&lt;code&gt;createStore()&lt;/code&gt;を呼ぶコードはモジュールにしておくのがいい。
後で膨らんでくるので。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/configureStore.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createStore } from &#39;redux&#39;;
import rootReducer from &#39;./reducers/rootReducer&#39;;

export default function configureStore(initialState = {}) {
  const store = createStore(
    rootReducer,
    initialState,
  );
  return store;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でReduxのコンポーネントが一通りそろって、状態管理システムができた。
試しに動かしてみる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/try.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { hogeButtonClicked } from &#39;./actions/actions&#39;;
import configureStore from &#39;./configureStore&#39;;

const store = configureStore();
console.log(store.getState()); // =&amp;gt; { hoge: {clicked: false} }

store.subscribe(() =&amp;gt; {
  console.log(store.getState());
});

store.dispatch(hogeButtonClicked()); // =&amp;gt; { hoge: {clicked: true} }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;するとReducer(&lt;code&gt;hoge()&lt;/code&gt;)が実行され、stateオブジェクトが更新されることが分かる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/10/01/creating-react-redux-app-from-scratch-07/&#34;&gt;次回&lt;/a&gt;は、今回作ったStoreをReactコンポーネントにつなぐ。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その5: Material-UIとWebフォント</title>
          <link>https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/</link>
          <pubDate>Thu, 06 Sep 2018 23:33:31 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/&#34;&gt;前回&lt;/a&gt;はCSS周りの処理系をセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;既成reactコンポーネント&#34;&gt;既成Reactコンポーネント&lt;/h1&gt;

&lt;p&gt;前回まででHTMLもCSSもReactコンポーネント単位で書けるようになったんだけど、実際、自分で1からコンポーネントを書くのは、特にデザインセンスがない人にとっては辛い。
かっこいいUIコンポーネントを作りたいならデザイナーの協力が必要だけど、個人の開発などそれができない状況も多い。&lt;/p&gt;

&lt;p&gt;という問題を抱えた人たち向けなのかはわからないが、既成のReactコンポーネントセットが色々OSSで提供されている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://material-ui.com/&#34;&gt;Material-UI&lt;/a&gt;: Googleの&lt;a href=&#34;https://material.io/design/&#34;&gt;マテリアルデザイン&lt;/a&gt;のReact実装。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://react.semantic-ui.com/&#34;&gt;Semantic UI React&lt;/a&gt;: &lt;a href=&#34;https://semantic-ui.com/&#34;&gt;Semantic UI&lt;/a&gt;のReactバインディング。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ant.design/docs/react/introduce&#34;&gt;antd&lt;/a&gt;: &lt;a href=&#34;https://ant.design/&#34;&gt;Ant Design&lt;/a&gt;のReact実装。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blueprintjs.com/&#34;&gt;Blueprint&lt;/a&gt;: 複雑でデータ量の多いUI向けに作られたReact UIツールキット。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://react-bootstrap.github.io/&#34;&gt;React-Bootstrap&lt;/a&gt;: &lt;a href=&#34;https://getbootstrap.com/&#34;&gt;Bootstrap&lt;/a&gt;のReactバインディング。現時点ではv4未対応。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://grommet.io/&#34;&gt;Grommet&lt;/a&gt;: HPEによるエンタープライズレディなデザインシステム。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.microsoft.com/en-us/fabric#/components&#34;&gt;Office UI Fabric React&lt;/a&gt;: OfficeなどのMicrosoft製品に使われているReactコンポーネントセット。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;今回はこの中でも圧倒的に人気なMaterial-UIを導入する。&lt;/p&gt;

&lt;h1 id=&#34;material-ui&#34;&gt;Material-UI&lt;/h1&gt;

&lt;p&gt;Material-UIは簡単に使える。
とりあえずコアパッケージをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add @material-ui/core
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v3.5.1が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとはパッケージに入っている色々なコンポーネントをMaterial-UIのドキュメント見ながら使えばいいだけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import styled from &#39;styled-components&#39;;
+import Button from &#39;@material-ui/core/Button&#39;;

 const Wrapper = styled.div`
   font-size: 5rem;
 `;

 const App = () =&amp;gt; (
   &amp;lt;Wrapper&amp;gt;
-    HOGE
+    &amp;lt;Button variant=&amp;quot;contained&amp;quot;&amp;gt;
+      HOGE
+    &amp;lt;/Button&amp;gt;
   &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでただのテキストがボタンになった。&lt;/p&gt;

&lt;h1 id=&#34;css-web-fonts&#34;&gt;CSS Web Fonts&lt;/h1&gt;

&lt;p&gt;前節でいちおうMaterial-UI使えたけど、フォントをケアしてやるともう少しかっこよくなる。
Material-UIは&lt;a href=&#34;https://fonts.google.com/specimen/Roboto&#34;&gt;Robotoフォント&lt;/a&gt;を想定して作られているが、これはブラウザにデフォルトで入ってはいないので、そのままだとArialとかにフォールバックされちゃう。
のでRobotoフォントを導入する。&lt;/p&gt;

&lt;p&gt;フォントは&lt;a href=&#34;https://www.w3schools.com/css/css3_fonts.asp&#34;&gt;CSS Web Fonts&lt;/a&gt;の機能である&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/@font-face&#34;&gt;@font-face&lt;/a&gt;で、フォントファイルをブラウザにロードさせることで導入できる。
&lt;code&gt;@font-face&lt;/code&gt;で読み込むフォントファイル(i.e. &lt;code&gt;url()&lt;/code&gt;関数で指定するファイル)はwebpackでバンドルできる。&lt;/p&gt;

&lt;p&gt;Robotoフォントのフォントファイルはnpmで配布されていて、Yarnでプロジェクトにインストールできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add typeface-roboto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;フォントファイルの種類は、OTFとかTTFとかWOFFとかWOFF2とかいろいろあるけど、&lt;a href=&#34;https://www.6666666.jp/design/20160218/&#34;&gt;この記事&lt;/a&gt;などをみるに、WOFFだけ使えばよさげ。&lt;/p&gt;

&lt;p&gt;フォントファイルのバンドルは&lt;a href=&#34;https://github.com/webpack-contrib/url-loader&#34;&gt;url-loader&lt;/a&gt;を使う方法と&lt;a href=&#34;https://github.com/webpack-contrib/file-loader&#34;&gt;file-loader&lt;/a&gt;を使う方法とがある。&lt;/p&gt;

&lt;h2 id=&#34;url-loaderを使う方法&#34;&gt;url-loaderを使う方法&lt;/h2&gt;

&lt;p&gt;url-loaderを使う場合は、url-loaderとフォールバック用のfile-loaderをインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn add -D url-loader file-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackのローダ設定は以下のようなのを追加すればいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;(前略)
   module: {
     rules: [
(中略)
-      }
+      },
+      {
+        test: /\.(png|woff|woff2|eot|ttf|svg)$/,
+        include: [path.resolve(__dirname, &#39;node_modules/typeface-roboto&#39;)],
+        loader: &#39;url-loader&#39;,
+        options: {
+          limit: 100000,
+        },
+      },
     ],
   },
(後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとは、typeface-robotoパッケージ内のフォントファイルを指すようにCSSに@font-faceを書けばいい。
例えば、weightが300のWOFFファイルを読むなら以下のような感じ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/fonts.css&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;@font-face {
  font-family: &#39;Roboto&#39;;
  font-style: normal;
  font-display: swap;
  font-weight: 300;
  src: local(&#39;Roboto Light&#39;), local(&#39;Roboto-Light&#39;),
    url(&#39;../node_modules/typeface-roboto/files/roboto-latin-300.woff&#39;) format(&#39;woff&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これをどこかのJavaScriptでインポートしてやればいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/index.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import ReactDOM from &#39;react-dom&#39;;
 import App from &#39;./components/App&#39;;
+import &#39;./fonts.css&#39;;

 const root = document.getElementById(&#39;root&#39;);

 if (root) {
   ReactDOM.render(
     &amp;lt;App /&amp;gt;,
     root,
   );
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;けど、styled-componentsを使っている場合はurl-loaderは使えないみたいで、代わりにfile-loaderを使う必要がある。&lt;/p&gt;

&lt;h2 id=&#34;file-loaderを使う方法-styled-components&#34;&gt;file-loaderを使う方法 (styled-components)&lt;/h2&gt;

&lt;p&gt;file-loaderを使う場合は、file-loaderだけインストールすればいい。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yarn add -D file-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackのローダ設定は以下のようなのを追加すればいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;(前略)
   module: {
     rules: [
(中略)
-      }
+      },
+      {
+        test: /\.(png|woff|woff2|eot|ttf|svg)$/,
+        include: [path.resolve(__dirname, &#39;node_modules&#39;)],
+        loader: &#39;file-loader&#39;,
+      },
     ],
   },
(後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、&lt;a href=&#34;https://github.com/styled-components/styled-components/issues/233&#34;&gt;ここ&lt;/a&gt;を参考にしてフォントファイルを読みこむ。injectGlobalというstyled-componentsのAPIを使えとあるけど、injectGlobalはstyled-components v4で&lt;a href=&#34;https://www.styled-components.com/docs/api#createglobalstyle&#34;&gt;createGlobalStyle&lt;/a&gt;に代わったので、以下のように書く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/fonts.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import { createGlobalStyle } from &#39;styled-components&#39;;
import roboto300 from &#39;../node_modules/typeface-roboto/files/roboto-latin-300.woff&#39;;

const Fonts = createGlobalStyle`
  /* roboto-300normal - latin */
  @font-face {
    font-family: &#39;Roboto&#39;;
    font-style: normal;
    font-display: swap;
    font-weight: 300;
    src:
      local(&#39;Roboto Light&#39;),
      local(&#39;Roboto-Light&#39;),
      url(&#39;${roboto300}&#39;) format(&#39;woff&#39;);
  }
`;

export default Fonts;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここでexportされる&lt;code&gt;Fonts&lt;/code&gt;はReactコンポーネントになっているので、それをどこかのJSXに追加してやればいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import styled from &#39;styled-components&#39;;
 import Button from &#39;@material-ui/core/Button&#39;;
+import Fonts from &#39;../fonts&#39;;

 const Wrapper = styled.div`
   font-size: 5rem;
 `;

 const App = () =&amp;gt; (
   &amp;lt;Wrapper&amp;gt;
     &amp;lt;Button variant=&amp;quot;contained&amp;quot;&amp;gt;
       HOGE
     &amp;lt;/Button&amp;gt;
+    &amp;lt;Fonts /&amp;gt;
   &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/26/creating-react-redux-app-from-scratch-06/&#34;&gt;次回&lt;/a&gt;はようやくReduxを導入する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その4: CSS ModulesとPostCSSとstylelintとstyled-components</title>
          <link>https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/</link>
          <pubDate>Wed, 29 Aug 2018 23:50:53 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/&#34;&gt;前回&lt;/a&gt;はPrettierとESLintをセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;css&#34;&gt;CSS&lt;/h1&gt;

&lt;p&gt;前回までで作った環境で、Reactを使ってHTMLのDOMツリーを構築することができるようになったが、これは基本的にUIに表示する情報の構造しか定義しない。
UIの見た目(スタイル)を決めるのはCSSなので、それをアプリに組み込むことを考えないといけない。&lt;/p&gt;

&lt;p&gt;組み込み方には現時点で大きく3通りある。&lt;/p&gt;

&lt;h2 id=&#34;cssを別途設計する&#34;&gt;CSSを別途設計する&lt;/h2&gt;

&lt;p&gt;一つ目はCSSを別途設計する方法。&lt;/p&gt;

&lt;p&gt;Reactコンポーネントからレンダリングされる要素にclassが付くようにしておいて、設計したCSSをbundle.jsとは別途読み込んでスタイルを適用することにはる。&lt;/p&gt;

&lt;p&gt;この場合、CSSのスタイル定義はすべてグローバルなので、設計効率やメンテナンス効率を維持しつつ、各コンポーネントに意図したスタイルが適用されるようにするため、テクニックを凝らしてCSSクラスを設計する必要がある。
例えば&lt;a href=&#34;https://en.bem.info/&#34;&gt;BEM&lt;/a&gt; (2009年3月誕生)、&lt;a href=&#34;http://oocss.org/&#34;&gt;OOCSS&lt;/a&gt; (2009年3月誕生)、&lt;a href=&#34;https://smacss.com/ja&#34;&gt;SMACSS&lt;/a&gt; (2011年9月誕生)、&lt;a href=&#34;https://github.com/hiloki/flocss&#34;&gt;FLOCSS&lt;/a&gt; (2014年4月誕生)など。&lt;/p&gt;

&lt;p&gt;CSS自体は、素のCSSを書くことはあまりなく、普通は&lt;a href=&#34;https://sass-lang.com/&#34;&gt;Sass&lt;/a&gt;などのAltCSSや&lt;a href=&#34;https://postcss.org/&#34;&gt;PostCSS&lt;/a&gt;を使って書く。&lt;/p&gt;

&lt;p&gt;さらに、&lt;a href=&#34;https://github.com/stylelint/stylelint&#34;&gt;stylelint&lt;/a&gt;でリンティングすることで、CSSの品質を上げられる。
リンティングルールは、stylelintプロジェクトから提供されている&lt;a href=&#34;https://github.com/stylelint/stylelint-config-recommended&#34;&gt;stylelint-config-recommended&lt;/a&gt;か&lt;a href=&#34;https://github.com/stylelint/stylelint-config-standard&#34;&gt;stylelint-config-standard&lt;/a&gt;を使えば十分。
後者がGoogleやAirbnbのCSSスタイルガイドを反映していていい感じ。&lt;/p&gt;

&lt;p&gt;書いたCSSは、webpackの&lt;a href=&#34;https://github.com/webpack-contrib/css-loader&#34;&gt;css-loader&lt;/a&gt;で読み込める。
webpackはJavaScriptの&lt;code&gt;import &#39;./App.css&#39;;&lt;/code&gt;みたいなコードを見つけると、css-loaderに処理を渡す。
css-loaderは、&lt;code&gt;import&lt;/code&gt;文で指定されたCSSファイルだけでなく、&lt;code&gt;@import&lt;/code&gt;や&lt;code&gt;url()&lt;/code&gt;で定義される依存関係をたどって関連するCSSを一通り読み込む。&lt;/p&gt;

&lt;p&gt;読み込んだCSSは、webpackの&lt;a href=&#34;https://github.com/webpack-contrib/style-loader&#34;&gt;style-loader&lt;/a&gt;を使ってDOMに適用できる。
style-loaderは、読み込んだCSSを&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;タグで囲ってHTMLのヘッダに挿入してくれる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;CSSの処理にはPostCSSを使うとして、プロジェクトに以下のパッケージを追加する。
(PostCSSについては&lt;a href=&#34;https://qiita.com/morishitter/items/4a04eb144abf49f41d7d&#34;&gt;Qiitaの記事&lt;/a&gt;が参考になった。)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;css-loader: CSSを読み込むためのwebpackのローダ。&lt;/li&gt;
&lt;li&gt;style-loader: CSSをDOMに追加するためのwebpackのローダ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/postcss/postcss-loader&#34;&gt;postcss-loader&lt;/a&gt;: PostCSSを実行するためのwebpackのローダ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://preset-env.cssdb.org/&#34;&gt;postcss-preset-env&lt;/a&gt;: CSSのエッジな機能を使うためのPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/postcss/autoprefixer&#34;&gt;autoprefixer&lt;/a&gt;: CSSプロパティにベンダプレフィックスを追加してくれるPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/luisrudge/postcss-flexbugs-fixes&#34;&gt;postcss-flexbugs-fixes&lt;/a&gt;: &lt;a href=&#34;https://www.w3schools.com/css/css3_flexbox.asp&#34;&gt;Flexbox&lt;/a&gt;のバグを修正してくれるPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/cssnano/cssnano&#34;&gt;cssnano&lt;/a&gt;: CSSをミニファイしてくれるPostCSSプラグイン。&lt;/li&gt;
&lt;li&gt;stylelint: CSSのリンタ。&lt;/li&gt;
&lt;li&gt;stylelint-config-standard: stylelintのルール設定集。&lt;/li&gt;
&lt;li&gt;stylelint-config-prettier: &lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;が施すコード整形とコンフリクトするルールを無効にするstylelintルール設定集。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D css-loader style-loader postcss-loader postcss-preset-env autoprefixer postcss-flexbugs-fixes cssnano stylelint stylelint-config-standard stylelint-config-prettier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;PostCSSとstylelintの設定は、それぞれpostcss.config.jsとstylelint.config.jsを書いてプロジェクトルートに置けばいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;postcss.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  plugins: {
    stylelint: {},
    &#39;postcss-preset-env&#39;: {},
    autoprefixer: {},
    &#39;postcss-flexbugs-fixes&#39;: {},
    cssnano: {},
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;stylelint.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  extends: [&#39;stylelint-config-standard&#39;, &#39;stylelint-config-prettier&#39;],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;stylelintはPostCSSのプラグインとしてPostCSSから実行する構成。&lt;/p&gt;

&lt;p&gt;stylelint.config.jsで、stylelint-config-prettierはextendsの最後に書く必要があることに注意。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackにもローダの設定を追加する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
+      {
+        test: /\.css$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        use: [
+          &#39;style-loader&#39;,
+          {
+            loader: &#39;css-loader&#39;,
+            options: {
+              importLoaders: 1,
+            },
+          },
+          &#39;postcss-loader&#39;,
+        ],
+      },
     ],
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで追加した設定は、&lt;code&gt;&amp;lt;プロジェクトルート&amp;gt;/src&lt;/code&gt;ディレクトリ内の&lt;code&gt;.css&lt;/code&gt;ファイルが&lt;code&gt;import&lt;/code&gt;されたら、postcss-loader、css-loader、style-loaderの順にそのファイルを処理する、というもの。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;実際のCSSは普通に書いて、JavaScriptからimportしてやればいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.css&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.normal {
  font-size: 5rem;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
+import &#39;./App.css&#39;

 const App = () =&amp;gt; (
-  &amp;lt;div&amp;gt;
+  &amp;lt;div className=&amp;quot;normal&amp;quot;&amp;gt;
     HOGE
   &amp;lt;/div&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JSXでHTML要素にclass属性を付けるには、classNameプロパティを使うことに注意。&lt;/p&gt;

&lt;p&gt;これでHOGEに&lt;code&gt;font-size: 5rem&lt;/code&gt;が適用され、文字が大きくなる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でCSSを適用できた。&lt;/p&gt;

&lt;p&gt;これはこれで十分で柔軟なやりかただけど、BEMなどでCSSクラスの設計を頑張る手間がある。
UIコンポーネントの構造とスタイルの構造を1対1対応させるなら、もっと楽な方法がある。&lt;/p&gt;

&lt;h2 id=&#34;css-modules&#34;&gt;CSS Modules&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/css-modules/css-modules&#34;&gt;CSS Modules&lt;/a&gt;は2015年9月に&lt;a href=&#34;https://postd.cc/css-modules/&#34;&gt;発表&lt;/a&gt;された技術で、一つのCSSファイルを一つのモジュールと考え、モジュールごとにCSSクラス名の名前空間を自動生成し、スタイルの影響範囲をモジュールに閉じ込めてくれるもの。
(実際には、子要素に継承されるプロパティもあるので完全に閉じ込められるわけではない。)&lt;/p&gt;

&lt;p&gt;ReactによるUIコンポーネントごとにCSSモジュールを作り、コンポーネント単位でスタイリングすることを意図した技術であり、コンポーネント内で閉じたCSSクラス設計をすればいいだけになり、BEMとかを考えなくてよくなる。&lt;/p&gt;

&lt;p&gt;CSS Modulesを使うには、&lt;a href=&#34;https://github.com/gajus/babel-plugin-react-css-modules&#34;&gt;babel-plugin-react-css-modules&lt;/a&gt;というBabelのプラグインをセットアップすればいい。
まずはそれをプロジェクトにインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D babel-plugin-react-css-modules
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Babelの設定を修正してインストールしたbabel-plugin-react-css-modulesを使うようにする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [
       &amp;quot;@babel/preset-env&amp;quot;,
       {
         &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
       }
     ],
     &amp;quot;@babel/preset-react&amp;quot;
-  ]
+  ],
+  &amp;quot;plugins&amp;quot;: [&amp;quot;react-css-modules&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackのcss-loaderのオプションを追加して、CSS Modulesを有効にする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
       {
         test: /\.css$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         use: [
           &#39;style-loader&#39;,
           {
             loader: &#39;css-loader&#39;,
             options: {
               importLoaders: 1,
+              modules: true,
+              localIdentName: &#39;[path]___[name]__[local]___[hash:base64:5]&#39;,
             },
           },
           &#39;postcss-loader&#39;,
         ],
       },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;modules&lt;/code&gt;がCSS Modulesを有効化するスイッチ。
&lt;code&gt;localIdentName&lt;/code&gt;はモジュール化したCSSクラスの命名規則で、babel-plugin-react-css-modulesの設定と合っている必要がある。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとは、コンポーネントの方で&lt;code&gt;className&lt;/code&gt;プロパティを&lt;code&gt;styleName&lt;/code&gt;プロパティに変えればいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
 import &#39;./App.css&#39;

 const App = () =&amp;gt; (
-  &amp;lt;div className=&amp;quot;normal&amp;quot;&amp;gt;
+  &amp;lt;div styleName=&amp;quot;normal&amp;quot;&amp;gt;
     HOGE
   &amp;lt;/div&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でCSS Modulesの設定は完了。
App.cssに書いたクラス名はcss-loaderによって変換され、App.jsxに書いたstyleNameはbabel-plugin-react-css-modulesによって変換され、どちらも&lt;code&gt;src-components-___App__normal___1fxGx&lt;/code&gt;になるようになる。&lt;/p&gt;

&lt;h2 id=&#34;css-in-js&#34;&gt;CSS in JS&lt;/h2&gt;

&lt;p&gt;3つめはCSS in JS。&lt;/p&gt;

&lt;p&gt;これは2014年11月に&lt;a href=&#34;https://speakerdeck.com/vjeux/react-css-in-js&#34;&gt;提唱された&lt;/a&gt;技術で、UIコンポーネントとそのスタイルを両方一つのJavaScriptファイルに書いて、完全に一体化させるというもの。&lt;/p&gt;

&lt;p&gt;CSS in JSはCSS Modulesの陰でしばらく目立たなかったが、2016年に&lt;a href=&#34;https://www.styled-components.com/&#34;&gt;styled-components&lt;/a&gt;という実装がリリースされて注目され、その後いくつかの実装が生まれた。
styled-componentsは2017年ころからCSS Modulesに代わって人気になり、&lt;a href=&#34;https://postd.cc/stop-using-css-in-javascript-for-web-development-fa/&#34;&gt;CSS Modules陣営からの反撃&lt;/a&gt;もあったものの、今日まで支持を増やしている模様。
SassやPostCSSなど既存のCSSエコシステムを切り捨てているのと、React限定なのが気になるところではあるが、時流に乗って使ってみることにする。&lt;/p&gt;

&lt;p&gt;なお、CSS in JSはCSS Modulesとセットアップ方法がかなり異なるので、本稿前節までの変更はいったん全部破棄する。&lt;/p&gt;

&lt;p&gt;styled-componentsを使う場合、プロジェクトに追加する必要があるのは二つだけ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;styled-components: styled-components本体。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/styled-components/babel-plugin-styled-components&#34;&gt;babel-plugin-styled-components&lt;/a&gt;: styled-componentsのサポートを強化するBabelプラグイン。実際には必須ではないけど、バンドルサイズを削減出来たり、SSRしやすくなったりする。ベンダプレフィックスの付与とかミニファイもしてくれる。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add styled-components
yarn add -D babel-plugin-styled-components
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;styled-componentsはv4.1.1が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Babelの設定は以下のように修正する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
   &amp;quot;presets&amp;quot;: [
     [
       &amp;quot;@babel/preset-env&amp;quot;,
       {
         &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
       }
     ],
     &amp;quot;@babel/preset-react&amp;quot;
-  ]
+  ],
+  &amp;quot;plugins&amp;quot;: [&amp;quot;styled-components&amp;quot;]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;App.jsxは、styled-componentsのstyledというAPIを使ってWrapperコンポーネント(スタイル付きdiv)を定義し、これをdivと置き換える。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; import React from &#39;react&#39;;
+import styled from &#39;styled-components&#39;;

+const Wrapper = styled.div`
+  font-size: 5rem;
+`;

 const App = () =&amp;gt; (
-  &amp;lt;div&amp;gt;
+  &amp;lt;Wrapper&amp;gt;
     HOGE
-  &amp;lt;/div&amp;gt;
+  &amp;lt;/Wrapper&amp;gt;
 );

 export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけ。CSS Modulesに比べて大分シンプル。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;styled.div&lt;/code&gt;でスタイルを記述している部分は見慣れない構文だけど、ECMAScript 2015で追加されたタグ付きテンプレートリテラルという構文で、テンプレート文字列の一種。
ここに書くスタイルの構文はCSSと全く一緒。
JavaScriptの構文としては単なる文字列なので、変数を使ったり、if文とかで動的に変えたり、数値を計算したり、自由に書ける。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ややややこしいが、&lt;a href=&#34;https://www.styled-components.com/docs/tooling#stylelint&#34;&gt;stylelintによるリンティング&lt;/a&gt;もできる。
以下のパッケージをプロジェクトに追加する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;stylelint: CSSのリンタ。(既出)&lt;/li&gt;
&lt;li&gt;stylelint-config-standard: stylelintのルール設定集。(既出)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/styled-components/stylelint-processor-styled-components&#34;&gt;stylelint-processor-styled-components&lt;/a&gt;: スタイル付きコンポーネントからスタイル定義を抽出するstylelintのカスタムプロセッサ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/styled-components/stylelint-config-styled-components&#34;&gt;stylelint-config-styled-components&lt;/a&gt;: stylelint-processor-styled-componentsを使うのに必要なstylelint設定集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/emilgoldsmith/stylelint-custom-processor-loader&#34;&gt;stylelint-custom-processor-loader&lt;/a&gt;: stylelintでカスタムプロセッサを使う場合に必要なwebpackのローダ。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D stylelint stylelint-config-standard stylelint-processor-styled-components stylelint-config-styled-components stylelint-custom-processor-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;stylelintの設定は以下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;stylelint.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  processors: [&#39;stylelint-processor-styled-components&#39;],
  extends: [&#39;stylelint-config-standard&#39;, &#39;stylelint-config-styled-components&#39;],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackの設定にstylelint-custom-processor-loaderの設定を追加する。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
+      {
+        test: /\.(js|jsx)$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        enforce: &#39;pre&#39;,
+        loader: &#39;stylelint-custom-processor-loader&#39;,
+      },
     ],
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これでstyled-componentsにstylelintを適用できた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/09/06/creating-react-redux-app-from-scratch-05/&#34;&gt;次回&lt;/a&gt;は&lt;a href=&#34;https://material-ui.com/&#34;&gt;Material-UI&lt;/a&gt;を導入する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その3: PrettierとESLint</title>
          <link>https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/</link>
          <pubDate>Thu, 23 Aug 2018 00:19:09 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/&#34;&gt;前回&lt;/a&gt;はReactをセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;フォーマッタとリンタ&#34;&gt;フォーマッタとリンタ&lt;/h1&gt;

&lt;p&gt;プロジェクトにフォーマッタとリンタを導入する。&lt;/p&gt;

&lt;p&gt;フォーマッタはソースの体裁を整えるツール。
フォーマッタを使うことで体裁が統一され、ソースが読みやすくなり、品質向上につながる。&lt;/p&gt;

&lt;p&gt;リンタはソースを静的解析して、潜在的なバグ、構造的な問題、体裁の問題を検出して警告してくれるツール。
フォーマッタは体裁だけ整えるのに対し、リンタは論理構造にも制約を課せるので、コーディングスタイルがより統一できたり、ミスをしやすい論理構造が無くなったりして、品質向上につながる。&lt;/p&gt;

&lt;p&gt;JavaScriptのような動的型付け言語では、実行時まで顕在化しないバグを作りこみやすく、また実行時エラーの原因解析が静的型付け言語に比べて難しいので、フォーマッタとリンタでプログラム実行前に問題をできるだけ取り除いておくのが重要。
またチーム開発では、コードレビューでコーディンスタイルを見る必要がなくなり、効率化につながる。&lt;/p&gt;

&lt;h2 id=&#34;prettier&#34;&gt;Prettier&lt;/h2&gt;

&lt;p&gt;フォーマッタには&lt;a href=&#34;https://prettier.io/&#34;&gt;Prettier&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;Prettierは&lt;a href=&#34;https://jlongster.com/A-Prettier-Formatter&#34;&gt;2017年1月&lt;/a&gt;にリリースされた新しいツール。
構文解析をして&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8&#34;&gt;AST&lt;/a&gt;を構築し、そこからフォーマット済みコードを出力するので、従来のツールよりも厳密な整形(e.g. 行の最大長を考慮した整形)ができる。&lt;/p&gt;

&lt;p&gt;また、opinionated(独断的)であることも特徴で、Prettierプロジェクトが推奨するフォーマットをほぼ強制し、設定がほとんどない。
このため導入が簡単だけど、かゆいところに手が届かないこともある。&lt;/p&gt;

&lt;p&gt;JavaScriptの他、JSX、CSS、Markdown、GraphQLのフォーマットにも対応している。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;まずプロジェクトにインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D prettier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;v1.15.2が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://prettier.io/docs/en/options.html&#34;&gt;設定&lt;/a&gt;は&lt;code&gt;prettier.config.js&lt;/code&gt;という&lt;a href=&#34;https://prettier.io/docs/en/configuration.html&#34;&gt;ファイル&lt;/a&gt;を書いてプロジェクトルートに置けばいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prettier.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  printWidth: 100, // 行の最大長
  tabWidth: 2, // インデント長
  singleQuote: true, // 文字列をシングルクオートで囲う
  trailingComma: &#39;all&#39;, // オブジェクトのプロパティとか関数の引数を複数行で書いたときに、全行の末尾にカンマをつける
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、フォーマット対象外のファイルを指定するファイルである&lt;code&gt;.prettierignore&lt;/code&gt;をプロジェクトルートに置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.prettierignore&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node_modules/
dist/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node_modulesはnpmパッケージが入るディレクトリ。
実際はnode_modulesはデフォルトで無視されるから書かなくていいんだけど。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://prettier.io/docs/en/ignore.html&#34;&gt;prettier-ignoreコメント&lt;/a&gt;を書くことで、ソースを部分的にフォーマット対象外とすることもできる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;最後に、npmスクリプトを書く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   &amp;quot;scripts&amp;quot;: {
+    &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.css&amp;quot;,
     &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
     &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;yarn format&lt;/code&gt;を実行するとプロジェクト内ソースを一通りフォーマットできる。&lt;/p&gt;

&lt;h2 id=&#34;eslint&#34;&gt;ESLint&lt;/h2&gt;

&lt;p&gt;リンタにはデファクトスタンダードの&lt;a href=&#34;https://eslint.org/&#34;&gt;ESLint&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;ESLintは2013年6月にリリースされたそこそこ歴史のあるツール。
リンティングルールがプラガブルで、豊富なルールを細かく制御できるのが特徴。
フォーマッタとしての機能もあるけど、そこはPrettierにまかせることにする。&lt;/p&gt;

&lt;p&gt;JavaScriptもJSXもリンティングできる。&lt;/p&gt;

&lt;p&gt;リンティングルールはAirbnbによる&lt;a href=&#34;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb&#34;&gt;eslint-config-airbnb&lt;/a&gt;が有名なのでこれを使う。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ESLintを導入するために、以下のパッケージをプロジェクトにインストールする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;eslint: ESLint本体。&lt;/li&gt;
&lt;li&gt;eslint-loader: webpackからESLintを実行するやつ。&lt;/li&gt;
&lt;li&gt;eslint-config-airbnb: ESLintルール設定集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/benmosher/eslint-plugin-import&#34;&gt;eslint-plugin-import&lt;/a&gt;: eslint-config-airbnbのピア依存。import文を処理するためのESLintプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/evcohen/eslint-plugin-jsx-a11y&#34;&gt;eslint-plugin-jsx-a11y&lt;/a&gt;: eslint-config-airbnbのピア依存。JSXを処理するためのESLintプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yannickcr/eslint-plugin-react&#34;&gt;eslint-plugin-react&lt;/a&gt;: eslint-config-airbnbのピア依存。React特有のリンティングルールを追加するESLintプラグイン。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/prettier/eslint-config-prettier&#34;&gt;eslint-config-prettier&lt;/a&gt;: Prettierが施すコード整形とコンフリクトするルールを無効にするESLintルール設定集。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ピア依存をインストールするのにはちょっとコツがいるので、&lt;a href=&#34;https://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb#eslint-config-airbnb-1&#34;&gt;eslint-config-airbnbのドキュメント&lt;/a&gt;を参照すべし。&lt;/p&gt;

&lt;p&gt;今回は以下のコマンドでインストールした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D &amp;quot;eslint@&amp;gt;=1.6.0 &amp;lt;5.0.0&amp;quot; eslint-loader eslint-config-airbnb &amp;quot;eslint-plugin-import@^2.12.0&amp;quot; &amp;quot;eslint-plugin-jsx-a11y@^6.0.3&amp;quot; &amp;quot;eslint-plugin-react@^7.9.1&amp;quot; eslint-config-prettier
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ESlintはv4.19.1が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eslint.org/docs/user-guide/configuring&#34;&gt;ESlintの設定&lt;/a&gt;は、設定ファイルである&lt;code&gt;.eslintrc.js&lt;/code&gt;をプロジェクトルートに置けばいい。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.eslintrc.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;module.exports = {
  env: {
    browser: true,
  },
  extends: [&#39;airbnb&#39;, &#39;prettier&#39;],
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;アプリの実行環境はブラウザなので&lt;code&gt;env.browser&lt;/code&gt;をtrueにしている。
これにより、ブラウザ環境でデフォルトで使えるグローバル変数(e.g. &lt;code&gt;document&lt;/code&gt;)を使うときにESLintに怒られないようになる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;extends&lt;/code&gt;は&lt;code&gt;eslint-config-airbnb&lt;/code&gt;と&lt;code&gt;eslint-config-prettier&lt;/code&gt;のルール設定を取り込むように書いている。
&lt;code&gt;prettier&lt;/code&gt;が最後でなければいけないことに注意。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;また、&lt;a href=&#34;https://eslint.org/docs/user-guide/configuring#ignoring-files-and-directories&#34;&gt;リンティング対象外のファイルを指定するファイル&lt;/a&gt;をプロジェクトルートに置く。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.eslintignore&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;node_modules/*
dist/*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node_modulesはnpmパッケージが入るディレクトリ。
実際はnode_modulesはデフォルトで無視されるから書かなくていいんだけど。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments&#34;&gt;eslint-disableコメント&lt;/a&gt;を書くことで、ソースを部分的にリンティング対象外としたり、特定のルールを無効化することもできる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;webpackからESLintを実行し、エラーがなくならない限りビルド成功できないようにする。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   module: {
     rules: [
+      {
+        test: /\.(js|jsx)$/,
+        include: [path.resolve(__dirname, &#39;src&#39;)],
+        enforce: &#39;pre&#39;,
+        loader: &#39;eslint-loader&#39;,
+        options: {
+          configFile: &#39;./.eslintrc.js&#39;,
+          failOnError: true,
+        },
       },
       {
         test: /\.(js|jsx)$/,
         include: [path.resolve(__dirname, &#39;src&#39;)],
         loader: &#39;babel-loader&#39;,
       },
     ],
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;あとはnpmスクリプト書くだけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; (前略)
   &amp;quot;scripts&amp;quot;: {
     &amp;quot;format&amp;quot;: &amp;quot;prettier --write **/*.jsx **/*.js **/*.css&amp;quot;,
+    &amp;quot;lint&amp;quot;: &amp;quot;eslint **/*.jsx **/*.js&amp;quot;,
     &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
     &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
   },
 (後略)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで、&lt;code&gt;yarn lint&lt;/code&gt;を実行するとプロジェクト内ソースを一通りリンティングできる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上で、フォーマッタとリンタを導入できた。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/29/creating-react-redux-app-from-scratch-04/&#34;&gt;次回&lt;/a&gt;はCSS周りの処理系を追加する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その2: React</title>
          <link>https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/</link>
          <pubDate>Wed, 22 Aug 2018 08:21:28 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/</guid>
          <description>

&lt;p&gt;&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;を学ぶために、開発環境というかプロジェクトテンプレートをスクラッチから作っている。
(最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/&#34;&gt;前回&lt;/a&gt;はNode.jsとYarnとBabelとwebpackをセットアップした。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;reactとは&#34;&gt;Reactとは&lt;/h1&gt;

&lt;p&gt;以前にも同じような事を書いたけど、改めてReactについて書く。
ちょっとコーディングの詳細にも触れながら。&lt;/p&gt;

&lt;p&gt;ReactはViewを記述するためのライブラリで、特徴は&lt;a href=&#34;https://reactjs.org/docs/faq-internals.html&#34;&gt;Virtual DOM&lt;/a&gt;と&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;virtual-dom&#34;&gt;Virtual DOM&lt;/h2&gt;

&lt;p&gt;Virtual DOMはDOMを仮想化するもので、JavaScriptからVirtual DOMでUIを記述してやると、それが実DOMに効率的に反映されるようになっている。&lt;/p&gt;

&lt;h2 id=&#34;jsx&#34;&gt;JSX&lt;/h2&gt;

&lt;p&gt;Virtual DOMはJSXというHTMLみたいな言語で記述できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(
  &amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こんな風に書くと、idが&lt;code&gt;root&lt;/code&gt;であるHTML要素の中に、&lt;code&gt;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;/code&gt;がレンダリングされる。
上記コードの&lt;code&gt;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&lt;/code&gt;の部分がJSX。&lt;/p&gt;

&lt;h2 id=&#34;コンポーネント&#34;&gt;コンポーネント&lt;/h2&gt;

&lt;p&gt;JSXではコンポーネントを定義して新たなタグとして使うことができるので、再利用できるコンポーネントを作って、それらを組み合わせてUIを構築することで、効率的な開発ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// Welcomeコンポーネントの定義
function Welcome() {
  return &amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;;
}

// Welcomeコンポーネントのレンダリング
ReactDOM.render(
  &amp;lt;Welcome /&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記コードではコンポーネントをfunctionで定義しているが、アロー関数で書いても全く一緒。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const Welcome = () =&amp;gt; (
  &amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;;
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;関数の代わりにclassで定義することもできる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;class Welcome extends React.Component {
  render() {
    return &amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;関数による定義とclassによる定義はおおむね変わらないが、&lt;a href=&#34;https://reactjs.org/docs/state-and-lifecycle.html&#34;&gt;stateとライフサイクルメソッド&lt;/a&gt;を使いたいときはclassにする必要がある。&lt;/p&gt;

&lt;p&gt;関数で定義したコンポーネントをFunction Component、クラスのものをClass Componentと呼ぶ。
(前者は昔はStateless Functional ComponentとかSFCとかFunctional Componentと呼ばれていた。後者はStateful Componentと呼ばれることもあるけど、&lt;a href=&#34;https://reactjs.org/docs/hooks-intro.html&#34;&gt;React Hooks&lt;/a&gt;が出た今、Class Componentの方が適切な呼び方だろう。)&lt;/p&gt;

&lt;h2 id=&#34;props&#34;&gt;props&lt;/h2&gt;

&lt;p&gt;コンポーネントはレンダリングの際に&lt;code&gt;props&lt;/code&gt;というパラメータを受け取って使うことができるので、上手く設計すれば汎用的なコンポーネントが書ける。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

// Welcomeコンポーネントの定義 (props付き)
function Welcome(props) {
  return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
}

// Welcomeコンポーネントのレンダリング (props付き)
ReactDOM.render(
  &amp;lt;Welcome name=&amp;quot;Kaitoy&amp;quot; /&amp;gt;,
  document.getElementById(&#39;root&#39;)
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;props&lt;/code&gt;はイミュータブルにしてコンポーネント内で変更しない(i.e. コンポーネントをpureにする)のが定石。&lt;/p&gt;

&lt;h2 id=&#34;prop-types&#34;&gt;prop-types&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/facebook/prop-types&#34;&gt;prop-types&lt;/a&gt;を使うと、コンポーネントに渡される&lt;code&gt;props&lt;/code&gt;に期待する型を定義することができる。&lt;/p&gt;

&lt;p&gt;前節で作ったWelcomeコンポーネントの&lt;code&gt;props&lt;/code&gt;の&lt;code&gt;name&lt;/code&gt;はStringオブジェクトを受け取ることを期待するので、prop-typesを以下のように定義する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Welcome(props) {
  return &amp;lt;h1&amp;gt;Hello, {props.name}&amp;lt;/h1&amp;gt;;
}

Welcome.propTypes = {
  name: PropTypes.string.isRequired,
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておくと、実行時に型チェックが走り、型が合わないとコンソールに警告がでるようになる。&lt;/p&gt;

&lt;h1 id=&#34;reactのインストール&#34;&gt;Reactのインストール&lt;/h1&gt;

&lt;p&gt;上記のコードを実行するためのライブラリを一通りプロジェクトに追加する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add react react-dom prop-types
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reactはv16.6.3が入った。&lt;/p&gt;

&lt;h1 id=&#34;ソース構成&#34;&gt;ソース構成&lt;/h1&gt;

&lt;p&gt;ソースを入れる&lt;code&gt;src&lt;/code&gt;ディレクトリの構成は、&lt;a href=&#34;https://qiita.com/numanomanu/items/af97312f34cf1388cee6#%E5%AE%9F%E9%9A%9B%E3%81%AE%E3%83%97%E3%83%AD%E3%83%80%E3%82%AF%E3%83%88%E3%81%AE%E3%83%95%E3%82%A9%E3%83%AB%E3%83%80%E6%A7%8B%E6%88%90&#34;&gt;Qiitaの記事&lt;/a&gt;を参考に以下のようにする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;react-redux-scaffold/

&lt;ul&gt;
&lt;li&gt;src/

&lt;ul&gt;
&lt;li&gt;actions/&lt;/li&gt;
&lt;li&gt;components/&lt;/li&gt;
&lt;li&gt;containers/&lt;/li&gt;
&lt;li&gt;reducers/&lt;/li&gt;
&lt;li&gt;sagas/&lt;/li&gt;
&lt;li&gt;services/&lt;/li&gt;
&lt;li&gt;index.jsx&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;今のところ使うのは&lt;code&gt;index.jsx&lt;/code&gt;と&lt;code&gt;components&lt;/code&gt;だけ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;index.jsx&lt;/code&gt;は&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/#webpack%E8%A8%AD%E5%AE%9A%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB&#34;&gt;前回&lt;/a&gt;書いた通り、webpackが初めにロードするファイル。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;components&lt;/code&gt;にはReactのコンポーネントを入れる。&lt;/p&gt;

&lt;p&gt;その他のディレクトリについては追って説明する。&lt;/p&gt;

&lt;h1 id=&#34;reactコンポーネント作成&#34;&gt;Reactコンポーネント作成&lt;/h1&gt;

&lt;p&gt;最初のReactコンポーネントとして、適当なものを作る。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/components/App.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;

const App = () =&amp;gt; (
  &amp;lt;div&amp;gt;
    HOGE
  &amp;lt;/div&amp;gt;
);

export default App;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で、これを&lt;code&gt;index.jsx&lt;/code&gt;でインポートしてレンダリングしてやる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;src/index.jsx&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./components/App&#39;;

const root = document.getElementById(&#39;root&#39;);

if (root) {
  ReactDOM.render(
    &amp;lt;App /&amp;gt;,
    root,
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これで&lt;code&gt;yarn build&lt;/code&gt;すると&lt;code&gt;dist/bundle.js&lt;/code&gt;が生成される。&lt;/p&gt;

&lt;p&gt;実践的なコンポーネント構成の考え方については、公式の&lt;a href=&#34;https://reactjs.org/docs/thinking-in-react.html&#34;&gt;Thinking in React&lt;/a&gt;が参考になる。&lt;/p&gt;

&lt;h1 id=&#34;htmlファイル作成&#34;&gt;HTMLファイル作成&lt;/h1&gt;

&lt;p&gt;bundle.jsを読み込むHTMLファイルを作る。&lt;/p&gt;

&lt;p&gt;HTMLファイルを書くときは、「&lt;a href=&#34;https://hail2u.net/documents/html-best-practices.html&#34;&gt;普通のHTMLの書き方&lt;/a&gt;」の1～3章とか、「&lt;a href=&#34;https://qiita.com/miya0001/items/8fff46c201bf9eaeba4a&#34;&gt;フロントエンドチェックリスト&lt;/a&gt;」のHead、HTML辺りが参考になる。
まあ開発時にしか使わないだろうから実際は適当でいいし、なんなら&lt;a href=&#34;https://webpack.js.org/plugins/html-webpack-plugin/&#34;&gt;HtmlWebpackPlugin&lt;/a&gt;で自動生成してもいい。&lt;/p&gt;

&lt;p&gt;作るファイルは、&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/#webpack-dev-server%E8%A8%AD%E5%AE%9A&#34;&gt;webpackの設定に書いた&lt;/a&gt;通り、&lt;code&gt;public/index.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;内容は以下。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;public/index.html&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot; /&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;x-ua-compatible&amp;quot; content=&amp;quot;ie=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;React Redux&amp;lt;/title&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;React Redux Scaffold&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;root&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;noscript&amp;gt;
      You need to enable JavaScript to run this app.
    &amp;lt;/noscript&amp;gt;
    &amp;lt;script src=&amp;quot;./bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;ポイントは2点。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;の最初に&lt;code&gt;id=root&lt;/code&gt;の&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;を書く&lt;/p&gt;

&lt;p&gt;上で書いた&lt;code&gt;index.jsx&lt;/code&gt;で、&lt;code&gt;id&lt;/code&gt;が&lt;code&gt;root&lt;/code&gt;の要素を取得して&lt;code&gt;ReactDOM.render()&lt;/code&gt;に渡しているので、この&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;要素のなかに全てのWeb UIがレンダリングされることになる。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;の最後に&lt;code&gt;&amp;lt;script src=&amp;quot;./bundle.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;を書く&lt;/p&gt;

&lt;p&gt;この&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;要素により、bundle.jsがWebサーバからダウンロードされて実行される。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でReactは一通り。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yarn start&lt;/code&gt;してブラウザで&lt;code&gt;http://localhost:3000&lt;/code&gt;にアクセスするとHOGEと表示されるはず。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/23/creating-react-redux-app-from-scratch-03/&#34;&gt;次回&lt;/a&gt;はフォーマッタとリンタを導入する。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>React &#43; Reduxアプリケーションプロジェクトのテンプレートを作る ― その1: Node.jsとYarnとBabelとwebpack</title>
          <link>https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/</link>
          <pubDate>Sun, 19 Aug 2018 15:27:19 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/</guid>
          <description>

&lt;p&gt;昔、&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo Toolkit&lt;/a&gt;を使ってFlashなUIをJavaScriptに書き換えた時以来、仕事でWeb UIを触ることはなかったんだけど、最近になってWeb UIを書かなければいけなくなるような気がして再学習を始めた。&lt;/p&gt;

&lt;p&gt;題材は&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt; (と&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;)。
今一番人気のフロントエンドフレームワークで、&lt;a href=&#34;https://www.kaitoy.xyz/2015/12/21/hello-react/&#34;&gt;昔触ったこともある&lt;/a&gt;ので。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/&#34;&gt;前回の記事でReactが生まれた経緯を学んだ&lt;/a&gt;ので、今回から実習に入る。&lt;/p&gt;

&lt;p&gt;(2018/11/21更新)&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;プロジェクト作成&#34;&gt;プロジェクト作成&lt;/h1&gt;

&lt;p&gt;ちょっと&lt;a href=&#34;https://github.com/facebook/create-react-app&#34;&gt;Create React App&lt;/a&gt;を触ってみたけど使わないことにした。
すぐ開発始められるのはよかったんだけど、裏でなにが起こっているかわからな過ぎて肌に合わないし、使うライブラリが結構固定されちゃいそうだったし、トラブルシュート(特にライブラリのバグを踏んだ時)が大変そうだったので。&lt;/p&gt;

&lt;p&gt;代わりに、&lt;a href=&#34;https://reactjs.org/docs/create-a-new-react-app.html#creating-a-toolchain-from-scratch&#34;&gt;公式&lt;/a&gt;で紹介されているブログ記事である&lt;a href=&#34;https://blog.usejournal.com/creating-a-react-app-from-scratch-f3c693b84658&#34;&gt;Creating a React App… From Scratch.&lt;/a&gt;を見ながら、スクラッチからプロジェクトを作ることにした。&lt;/p&gt;

&lt;p&gt;環境はWindows 10 Home。&lt;/p&gt;

&lt;p&gt;最終的な成果は&lt;a href=&#34;https://github.com/kaitoy/react-redux-scaffold&#34;&gt;GitHub&lt;/a&gt;に置いた。&lt;/p&gt;

&lt;h2 id=&#34;node-jsインストール&#34;&gt;Node.jsインストール&lt;/h2&gt;

&lt;p&gt;なにはともあれ&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Node.jsのバージョン管理には以前は&lt;a href=&#34;https://github.com/marcelklehr/nodist&#34;&gt;nodist&lt;/a&gt;使っていたんだけど、こいつは2年ほど前に開発が止まっているので、代わりに&lt;a href=&#34;https://github.com/coreybutler/nvm-windows&#34;&gt;nvm for Windows&lt;/a&gt;を入れた。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nvm install&lt;/code&gt;で任意のバージョンのNode.jsをインストール出来て、&lt;code&gt;nvm use&lt;/code&gt;で使うNode.jsのバージョンを切り替えられる。&lt;/p&gt;

&lt;p&gt;今回使うNode.jsのバージョンは、現時点でLTS版の最新である8.11.4にする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;C:\&amp;gt;nvm install 8.11.4
Downloading node.js version 8.11.4 (64-bit)...
Complete
Creating C:\Users\kaitoy\AppData\Roaming\nvm\temp

Downloading npm version 5.6.0... Complete
Installing npm v5.6.0...

Installation complete. If you want to use this version, type

nvm use 8.11.4

C:\&amp;gt;nvm use 8.11.4
Now using node v8.11.4 (64-bit)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;yarnインストール&#34;&gt;Yarnインストール&lt;/h2&gt;

&lt;p&gt;パッケージマネージャには&lt;a href=&#34;https://yarnpkg.com/lang/ja/&#34;&gt;Yarn&lt;/a&gt;を使う。&lt;/p&gt;

&lt;p&gt;Yarnちょっとバギーだとか、npm 5がlockファイルをサポートしてYarnの優位性が減ったとか、&lt;a href=&#34;https://github.com/mixmaxhq/deyarn&#34;&gt;Yarnからnpmに戻るためのツール&lt;/a&gt;が出てきたりしてるけど、現時点では深く考えずにYarnでいいと思う。&lt;/p&gt;

&lt;p&gt;YarnはWindows環境ではMSIファイルを&lt;a href=&#34;https://yarnpkg.com/ja/docs/install#windows-stable&#34;&gt;ダウンロード&lt;/a&gt;して実行すればインストールできる。&lt;/p&gt;

&lt;p&gt;(npmでもインストールできるけど邪道。)&lt;/p&gt;

&lt;p&gt;Yarnはv1.7.0を使う。&lt;/p&gt;

&lt;h2 id=&#34;package-json生成&#34;&gt;package.json生成&lt;/h2&gt;

&lt;p&gt;プロジェクトの構成情報を記述するファイルであるpackage.jsonをYarnで生成する。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;C:\&amp;gt;mkdir react-redux-scaffold

C:\&amp;gt;cd react-redux-scaffold

C:\react-redux-scaffold&amp;gt;yarn init
yarn init v1.7.0
question name (react-redux-scaffold):
question version (1.0.0):
question description: React Redux Scaffold
question entry point (index.js): src/index.jsx
question repository url: https://github.com/kaitoy/react-redux-scaffold.git
question author: kaitoy
question license (MIT):
question private:
success Saved package.json
Done in 40.38s.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;できたのがこれ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;react-redux-scaffold&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;React Redux Scaffold&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;src/index.jsx&amp;quot;,
  &amp;quot;repository&amp;quot;: &amp;quot;https://github.com/kaitoy/react-redux-scaffold.git&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;kaitoy&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以降、カレントディレクトリは&lt;code&gt;C:\react-redux-scaffold&lt;/code&gt;として、プロンプト表示は省略する。&lt;/p&gt;

&lt;h1 id=&#34;ビルド環境セットアップ&#34;&gt;ビルド環境セットアップ&lt;/h1&gt;

&lt;p&gt;ビルド環境としてトランスパイラとかモジュールバンドラとかをセットアップする。&lt;/p&gt;

&lt;h2 id=&#34;babel&#34;&gt;Babel&lt;/h2&gt;

&lt;p&gt;トランスパイラはデファクトスタンダードの&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;を使う。
&lt;a href=&#34;https://babeljs.io/blog/2018/08/27/7.0.0&#34;&gt;2018年8月&lt;/a&gt;に出たv７。&lt;/p&gt;

&lt;p&gt;Babelのプラグインはとりあえず最低限入れるとして、以下のnpmパッケージをプロジェクトにインストールする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/en/babel-core&#34;&gt;@babel/core&lt;/a&gt;: Babel本体。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/en/babel-preset-react&#34;&gt;@babel/preset-react&lt;/a&gt;: Reactの&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;とか&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;とかを処理するプラグイン集。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://babeljs.io/docs/en/babel-preset-env&#34;&gt;@babel/preset-env&lt;/a&gt;: ES 2015+をES 5にトランスパイルするプラグイン集。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これらのパッケージは実行時には要らないので&lt;code&gt;yarn add -D&lt;/code&gt;コマンドで開発時依存としてインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D @babel/core @babel/preset-react @babel/preset-env
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Babelはv7.1.6が入った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;で、Babelの&lt;a href=&#34;https://babeljs.io/docs/en/babelrc&#34;&gt;設定ファイル&lt;/a&gt;を書いてプロジェクトルートに置いておく。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;presets&amp;quot;: [&amp;quot;@babel/preset-env&amp;quot;, &amp;quot;@babel/preset-react&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;polyfill&#34;&gt;Polyfill&lt;/h2&gt;

&lt;p&gt;BabelはES 2015+で追加された構文の変換はしてくれるけど、追加されたグローバルオブジェクト(e.g. &lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise&#34;&gt;Promise&lt;/a&gt;)とかメソッド(e.g. Object.assignとかArray.prototype.includes)とかを補完してくれるわけではない。
そこを補完してくれるのが&lt;a href=&#34;https://en.wikipedia.org/wiki/Polyfill_%28programming%29&#34;&gt;Polyfill&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;少なくとも後で導入する&lt;a href=&#34;https://redux-saga.js.org/&#34;&gt;redux-saga&lt;/a&gt;が使う&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Statements/function*&#34;&gt;ジェネレータ&lt;/a&gt;がPolyfillを必要とする(ないと&lt;code&gt;ReferenceError: regeneratorRuntime is not defined&lt;/code&gt;というエラーが出る)ので、今の時点で入れておくことにする。&lt;/p&gt;

&lt;p&gt;Polyfillの実装はいくつかあるけど、定番っぽい&lt;a href=&#34;https://babeljs.io/docs/en/babel-polyfill/&#34;&gt;@babel/polyfill&lt;/a&gt;を使う。
こちらは実行時依存としてインストールする。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add @babel/polyfill
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;@babel/polyfill&lt;/code&gt;のアプリへのロード方法は&lt;a href=&#34;https://babeljs.io/docs/en/babel-polyfill#usage-in-node-browserify-webpack&#34;&gt;いくつかある&lt;/a&gt;けど、今回使うwebpack(後述)の場合、&lt;code&gt;useBuiltIns: &#39;usage&#39;&lt;/code&gt;というオプションを使うのがよさそう。
これを使うと、ソースに&lt;code&gt;@babel/polyfill&lt;/code&gt;のimportを書かなくても、必要に応じて必要なPolifillをロードしてくれる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt; {
-  &amp;quot;presets&amp;quot;: [&amp;quot;@babel/preset-env&amp;quot;, &amp;quot;@babel/preset-react&amp;quot;]
+  &amp;quot;presets&amp;quot;: [
+    [
+      &amp;quot;@babel/preset-env&amp;quot;,
+      {
+        &amp;quot;useBuiltIns&amp;quot;: &amp;quot;usage&amp;quot;
+      }
+    ],
+    &amp;quot;@babel/preset-react&amp;quot;
+  ]
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;webpack&#34;&gt;webpack&lt;/h2&gt;

&lt;p&gt;モジュールバンドラは現時点で一番人気の&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;を使う。
(&lt;a href=&#34;https://parceljs.org/&#34;&gt;Parcel&lt;/a&gt;の方がナウいはナウいけど。)&lt;/p&gt;

&lt;p&gt;webpackは、タスクランナーの機能も備えたモジュールバンドラみたいな感じで、バンドルしたいファイルの形式とか実行したいタスクに応じた&lt;a href=&#34;https://webpack.js.org/loaders/&#34;&gt;ローダー&lt;/a&gt;を設定することでプロジェクトのビルドを定義できる。&lt;/p&gt;

&lt;p&gt;ちょっと古いけど&lt;a href=&#34;https://qiita.com/chuck0523/items/caacbf4137642cb175ec&#34;&gt;この記事&lt;/a&gt;を読むとwebpackの理解が深まる。&lt;/p&gt;

&lt;p&gt;こちらもとりあえず最低限のローダーをセットアップするとして、以下のnpmパッケージをプロジェクトにインストールする。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;webpack: webpack本体。&lt;/li&gt;
&lt;li&gt;webpack-cli: webpackのコマンドラインインターフェース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpack/webpack-dev-server&#34;&gt;webpack-dev-server&lt;/a&gt;: webpackから起動できる開発用 HTTP サーバ。ライブリロードしてくれる。(&lt;a href=&#34;https://github.com/webpack-contrib/webpack-serve&#34;&gt;webpack-serve&lt;/a&gt;の方がモダンではある。)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.js.org/loaders/babel-loader/&#34;&gt;babel-loader&lt;/a&gt;: Babelを実行してくれるやつ。Babel 7で使うにはv8以降である必要がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D webpack webpack-cli webpack-dev-server babel-loader
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;webpackはv4.26.0が入った。&lt;/p&gt;

&lt;h3 id=&#34;webpack設定ファイル&#34;&gt;webpack設定ファイル&lt;/h3&gt;

&lt;p&gt;webpackの設定は&lt;a href=&#34;https://webpack.js.org/configuration/&#34;&gt;設定ファイル&lt;/a&gt;を書いてプロジェクトルートに置けばいい。
設定は結構複雑だけど、v1の時よりかは若干書きやすくなったし、公式のマニュアルとかローダーのマニュアル見てれば書くのは難しくない。
&lt;a href=&#34;https://generatewebpackconfig.netlify.com/&#34;&gt;設定ファイルを生成してくれるサイト&lt;/a&gt;もある。&lt;/p&gt;

&lt;p&gt;とりあえず適当に書くとこんな感じ。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const packageJson = require(&#39;./package.json&#39;);

module.exports = {
  mode: &#39;development&#39;,
  entry: [`./${packageJson.main}`],
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;,
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        include: [path.resolve(__dirname, &#39;src&#39;)],
        loader: &#39;babel-loader&#39;,
      },
    ],
  },
  resolve: {
    extensions: [&#39;*&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
    modules: [&#39;node_modules&#39;],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;この設定の意味は、&lt;code&gt;entry&lt;/code&gt;に指定された&lt;code&gt;./src/index.jsx&lt;/code&gt;を読んで、&lt;code&gt;.js&lt;/code&gt;か&lt;code&gt;.jsx&lt;/code&gt;を拡張子としたモジュールファイルやノードモジュールをロードするコードがあったら、babel-loaderでBabelを呼んでトランスパイルして、バンドルした結果は&lt;code&gt;&amp;lt;プロジェクトルート&amp;gt;/dist/bundle.js&lt;/code&gt;に吐き出す。
というだけ。
(&lt;a href=&#34;https://nodejs.org/docs/latest/api/modules.html#modules_dirname&#34;&gt;__dirname&lt;/a&gt;はNode.jsが値を入れてくれる変数で、webpack.config.jsのあるディレクトリの絶対パスが入ってる。)&lt;/p&gt;

&lt;p&gt;モジュールファイルをロードするコードというのは、&lt;code&gt;import App from &#39;./components/App&#39;;&lt;/code&gt;みたいなやつ。
webpackはこのコードを読んだら、&lt;code&gt;./components&lt;/code&gt;ディレクトリのなかを見て、&lt;code&gt;App&lt;/code&gt;か&lt;code&gt;App.js&lt;/code&gt;か&lt;code&gt;App.jsx&lt;/code&gt;というファイルを探してロードする。
また、ノードモジュールをロードするコードというのは&lt;code&gt;import React from &#39;react&#39;;&lt;/code&gt;みたいなやつで、webpackはこのコードを読んだら、プロジェクトの&lt;code&gt;node_modules/react/package.json&lt;/code&gt;の&lt;code&gt;main&lt;/code&gt;プロパティの値に書いてあるファイルをロードする。
という挙動が上記webpack.config.jsの&lt;code&gt;resolve&lt;/code&gt;に定義してある。
(モジュールロードの詳細は&lt;a href=&#34;https://webpack.js.org/concepts/module-resolution/&#34;&gt;公式のドキュメントのModule Resolution&lt;/a&gt;に書いてある。)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;.babelrc&lt;/code&gt;に&lt;code&gt;useBuiltIns: &#39;usage&#39;&lt;/code&gt;を付けたので、webpack.config.jsに&lt;code&gt;@babel/preset-env&lt;/code&gt;を書く必要はない。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;については後述。&lt;/p&gt;

&lt;h3 id=&#34;webpack-dev-server設定&#34;&gt;webpack-dev-server設定&lt;/h3&gt;

&lt;p&gt;webpack-dev-serverの設定もwebpack.config.jsに書く。&lt;/p&gt;

&lt;p&gt;以下を&lt;code&gt;resolve&lt;/code&gt;の次辺りに書き足せばいい。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  devServer: {
    contentBase: path.join(__dirname, &#39;public&#39;),
    compress: true,
    hot: true,
    port: 3000,
    publicPath: &#39;http://localhost:3000/&#39;,
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この設定でwebpack-dev-serverを実行すると、&lt;code&gt;http://localhost:3000/&lt;/code&gt;へのアクセスに&lt;code&gt;public/index.html&lt;/code&gt;を返すWebサーバを起動できる。
Webサーバが起動するときにプロジェクトがインメモリでビルドされ、メモリからbundle.jsがサーブされる。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hot&lt;/code&gt;をtrueにしておくと&lt;a href=&#34;https://webpack.js.org/concepts/hot-module-replacement/&#34;&gt;Hot Module Replacement&lt;/a&gt;が有効になる。
これによって、webpack-dev-serverの起動中にソースを編集すると、自動で再ビルドし、動的にモジュール単位でロードし、ブラウザをリロードしてくれるようになる。
Hot Module Replacementを有効にするときは&lt;code&gt;publicPath&lt;/code&gt;をフルURLで書かないといけない。&lt;/p&gt;

&lt;p&gt;webpack-dev-serverの他の設定については&lt;a href=&#34;https://webpack.js.org/configuration/dev-server/&#34;&gt;公式のマニュアルのDevServer&lt;/a&gt;を見るべし。&lt;/p&gt;

&lt;h3 id=&#34;webpackのmode&#34;&gt;webpackのmode&lt;/h3&gt;

&lt;p&gt;webpackにはビルドの&lt;a href=&#34;https://webpack.js.org/concepts/#mode&#34;&gt;mode&lt;/a&gt;という概念があり、modeを切り替えることで適切な最適化を適用してくれる。&lt;/p&gt;

&lt;p&gt;modeにはdevelopmentとproduction(とnone)があり、productionにしておくと、&lt;a href=&#34;https://webpack.js.org/plugins/uglifyjs-webpack-plugin/&#34;&gt;UglifyJsPlugin&lt;/a&gt;とかを適用して、出力するバンドルファイルのサイズを小さくしてくれたりする。
(v1のころはUglifyJsPluginとかは全部自分でwebpack.config.jsに指定していた記憶があるので、楽になった。)&lt;/p&gt;

&lt;h3 id=&#34;webpack-config-jsの分割&#34;&gt;webpack.config.jsの分割&lt;/h3&gt;

&lt;p&gt;modeを切り替えるのにwebpack.config.jsを書き換えるのはイケてないので、developmentとproductionでファイルを分割して使い分けるようにする。&lt;/p&gt;

&lt;p&gt;developmentとproductionはほとんどが共通の設定なので、共通部分をwebpack.common.jsに書いて、developmentとproductionに固有な設定だけをそれぞれwebpack.dev.jsとwebpack.prod.jsに書く。
webpack.common.jsは、&lt;a href=&#34;https://github.com/survivejs/webpack-merge&#34;&gt;webpack-merge&lt;/a&gt;でwebpack.dev.jsとwebpack.prod.jsにマージする。
というのが&lt;a href=&#34;https://webpack.js.org/guides/production/&#34;&gt;公式&lt;/a&gt;で紹介されているプラクティス。&lt;/p&gt;

&lt;p&gt;まずwebpack-mergeをプロジェクトにインストール。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;yarn add -D webpack-merge
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分割したファイルは以下の感じ。全部プロジェクトルートに置いておく。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;webpack.common.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const packageJson = require(&#39;./package.json&#39;);

module.exports = {
  entry: [`./${packageJson.main}`],
  output: {
    path: path.resolve(__dirname, &#39;dist&#39;),
    filename: &#39;bundle.js&#39;,
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        include: [path.resolve(__dirname, &#39;src&#39;)],
        loader: &#39;babel-loader&#39;,
      },
    ],
  },
  resolve: {
    extensions: [&#39;*&#39;, &#39;.js&#39;, &#39;.jsx&#39;],
    modules: [&#39;node_modules&#39;],
  },
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.dev.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const path = require(&#39;path&#39;);
const webpackMerge = require(&#39;webpack-merge&#39;);
const webpackCommon = require(&#39;./webpack.common.js&#39;);

module.exports = webpackMerge(webpackCommon, {
  mode: &#39;development&#39;,
  devServer: {
    contentBase: path.join(__dirname, &#39;public&#39;),
    compress: true,
    hot: true,
    port: 3000,
    publicPath: &#39;http://localhost:3000/&#39;,
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webpack.prod.js&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;const webpackMerge = require(&#39;webpack-merge&#39;);
const webpackCommon = require(&#39;./webpack.common.js&#39;);

module.exports = webpackMerge(webpackCommon, {
  mode: &#39;production&#39;,
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;npmスクリプト&#34;&gt;npmスクリプト&lt;/h3&gt;

&lt;p&gt;webpackによるビルドは次のコマンドで実行できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;node_modules\.bin\webpack --config webpack.prod.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、webpack-dev-serverは次のコマンドで起動できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cmd&#34;&gt;node_modules\.bin\webpack-dev-server --hot --config webpack.dev.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--hot&lt;/code&gt;はHot Module Replacementに必要なオプション。&lt;/p&gt;

&lt;p&gt;コマンドが長くて面倒なのは、&lt;a href=&#34;https://docs.npmjs.com/misc/scripts&#34;&gt;npmスクリプト&lt;/a&gt;で楽にできる。
package.jsonの&lt;code&gt;main&lt;/code&gt;の次辺りに以下を書き足せばいい。
(npmスクリプトは実行時に&lt;code&gt;node_modules\.bin&lt;/code&gt;にPATHを通してくれるので、それを省略できる。)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;build&amp;quot;: &amp;quot;webpack --config webpack.prod.js&amp;quot;,
    &amp;quot;start&amp;quot;: &amp;quot;webpack-dev-server --hot --config webpack.dev.js&amp;quot;
  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こうしておくと、&lt;code&gt;yarn build&lt;/code&gt;でビルド、&lt;code&gt;yarn start&lt;/code&gt;でwebpack-dev-server起動できる。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;以上でビルド環境セットアップはいったん完了とする。
&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/22/creating-react-redux-app-from-scratch-02/&#34;&gt;次回&lt;/a&gt;はReactが動くところらへんまで。&lt;/p&gt;
</description>
        </item>
      
    
      
        <item>
          <title>Webアプリケーションフロントエンド年代記 - 2018年夏編</title>
          <link>https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/</link>
          <pubDate>Thu, 16 Aug 2018 23:44:39 JST</pubDate>
          <author>Kaito Yamada</author>
          <guid>https://www.kaitoy.xyz/2018/08/16/chronicle-of-frontend-2018/</guid>
          <description>

&lt;p&gt;Webアプリケーションの、主にフロントエンド周りに関連する歴史をまとめた。&lt;/p&gt;

&lt;p&gt;



&lt;script async src=&#34;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&#34;&gt;&lt;/script&gt;
&lt;ins class=&#34;adsbygoogle&#34;
     style=&#34;display:block&#34;
     data-ad-client=&#34;ca-pub-6244473643910448&#34;
     data-ad-slot=&#34;1845600530&#34;
     data-ad-format=&#34;auto&#34;&gt;&lt;/ins&gt;
&lt;script&gt;
(adsbygoogle = window.adsbygoogle || []).push({});
&lt;/script&gt;
&lt;/p&gt;

&lt;h1 id=&#34;静的サイト&#34;&gt;静的サイト&lt;/h1&gt;

&lt;p&gt;まずは原初の話から。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1990年代前半&lt;/strong&gt;、まだWebアプリケーションという言葉が無かった時代。
静的にHTMLファイルを配信するだけのWebサイト(静的サイト)だけがあった。
静的サイトでは、HTTPサーバーに複数のHTMLファイルを置いておいて、クライアントのHTTPリクエストのURLのパスによって配信するHTMLファイルを変える。&lt;/p&gt;

&lt;p&gt;例えば、HTTPサーバーを&lt;a href=&#34;https://httpd.apache.org/&#34;&gt;httpd&lt;/a&gt;で立てて、ドキュメントルートを&lt;code&gt;/var/www/html&lt;/code&gt;に設定して、以下のようにファイルを配置したとする。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;/var/www/html/
    |
    +-- index.html
    |
    +-- sub/
          |
          +-- hoge.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;この場合、ブラウザで&lt;code&gt;http://&amp;lt;HTTPサーバアドレス&amp;gt;/index.html&lt;/code&gt;にアクセスすれば&lt;code&gt;/var/www/html/index.html&lt;/code&gt;が配信されてレンダリングされて表示される。
&lt;code&gt;http://&amp;lt;HTTPサーバアドレス&amp;gt;/sub/hoge.html&lt;/code&gt;にアクセスすれば&lt;code&gt;/var/www/html/sub/hoge.html&lt;/code&gt;が配信される。&lt;/p&gt;

&lt;p&gt;古のWebサイトは、こんな感じにコンテンツごとにHTMLファイルを書いてサーバに置いておいて、その間にリンクを張って辿れるようにすることで構成されていた。&lt;/p&gt;

&lt;p&gt;まあ今も大体そんな感じだけど。&lt;/p&gt;

&lt;h1 id=&#34;動的html生成-プログラムでhtmlを書き出す&#34;&gt;動的HTML生成 (プログラムでHTMLを書き出す)&lt;/h1&gt;

&lt;p&gt;静的サイトだと表現できることが非常に限られるので、クライアントからのリクエストの内容をサーバが解釈し、DBの情報やなんかをもとにサーバ側でHTMLドキュメントを動的に生成し、クライアントに返す、ということをするようになった。&lt;/p&gt;

&lt;p&gt;原始的(&lt;strong&gt;1990年代中盤から後半&lt;/strong&gt;)には、プログラム中で一連のHTMLドキュメントを出力する方法がとられた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void doGet(
  HttpServletRequest request, HttpServletResponse response
) throws IOException, ServletException {

  response.setContentType(&amp;quot;text/html;&amp;quot;);
  PrintWriter out = response.getWriter();

  out.println(&amp;quot;&amp;lt;html&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;head&amp;gt;&amp;quot;);
  out.println(&amp;quot;    &amp;lt;title&amp;gt;Hoge&amp;lt;/title&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;/head&amp;gt;&amp;quot;);
  out.println(&amp;quot;  &amp;lt;body&amp;gt;&amp;quot;);
  out.println(new java.util.Date());
  out.println(&amp;quot;  &amp;lt;/body&amp;gt;&amp;quot;);
  out.println(&amp;quot;&amp;lt;/html&amp;gt;&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使われた技術は、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Common_Gateway_Interface&#34;&gt;CGI&lt;/a&gt; (Perl)とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java_Servlet&#34;&gt;Java Servlet&lt;/a&gt;とか。
&lt;a href=&#34;http://jakarta.apache.org/ecs/index.html&#34;&gt;Jakarta ECS&lt;/a&gt;なんてのもあった。&lt;/p&gt;

&lt;h1 id=&#34;動的html生成-htmlにプログラムを埋め込む&#34;&gt;動的HTML生成 (HTMLにプログラムを埋め込む)&lt;/h1&gt;

&lt;p&gt;プログラムでHTMLを書き出すことにより、かなり動的な感じにはなったが、書き出す処理を書くのがめんどくさすぎるし、読みにくい。
そのため、&lt;strong&gt;1990年代後半から2000年代初頭&lt;/strong&gt; にかけ、HTMLを主体にして、そのなかの動的な部分だけにプログラムを埋め込む技術がいくつも生まれた。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%@ page contentType=&amp;quot;text/html %&amp;gt;

&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Hoge&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;%
    out.println(new java.util.Date());
    %&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTMLドキュメントのひな型を作っておいて、その中にプログラムの処理結果を埋め込んでクライアントに返すため、テンプレートエンジンとか、テンプレートシステムとか呼ばれる。&lt;/p&gt;

&lt;p&gt;該当する技術は、&lt;a href=&#34;http://www.php.net/&#34;&gt;PHP&lt;/a&gt;とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/JavaServer_Pages&#34;&gt;JSP&lt;/a&gt;とか、&lt;a href=&#34;http://velocity.apache.org/&#34;&gt;Velocity&lt;/a&gt;とか、&lt;a href=&#34;https://ja.wikipedia.org/wiki/ERuby&#34;&gt;eRuby&lt;/a&gt;とか。&lt;/p&gt;

&lt;h1 id=&#34;dhtml&#34;&gt;DHTML&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1990年代後半&lt;/strong&gt;、クライアントサイドのJavaScriptでHTMLドキュメントをいじって、多少の動的感・インタラクティブ感をだす技術は既に一応あって、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%80%E3%82%A4%E3%83%8A%E3%83%9F%E3%83%83%E3%82%AFHTML&#34;&gt;DHTML&lt;/a&gt;と呼ばれていた。&lt;/p&gt;

&lt;p&gt;DHTMLの肝はJavaScriptの&lt;a href=&#34;https://ja.wikipedia.org/wiki/Document_Object_Model&#34;&gt;DOM&lt;/a&gt; APIだ。
このAPIでは、HTML文書が各要素(タグなど)をノードとするツリー構造(DOMツリー)で表され、任意の要素を検索して取得したり、属性などを書き換えたり、要素の追加・削除ができる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;hogehoge&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
      // idがhogehogeの要素の子要素として「&amp;lt;p&amp;gt;HOGEEEEEEE&amp;lt;/p&amp;gt;」を追加。
      document.getElementById(&amp;quot;hogehoge&amp;quot;).innerHTML = &amp;quot;&amp;lt;p&amp;gt;HOGEEEEEEE&amp;lt;/p&amp;gt;&amp;quot;
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、このころのJavaScriptは、仕様・機能が貧弱だった上、ブラウザ間で挙動に差があったり、標準メソッドがブラウザ固有のメソッドで代替されていたりして開発体験が最悪だったためか、今日のようにWeb UIの中心的役割を果たすことはなく、補助的・装飾的機能の実装に使われることが多かったように思う。&lt;/p&gt;

&lt;p&gt;アクセスした日付を表示したり、背景に雪を降らせたり、マウスカーソルを目玉に追いかけさせたり。&lt;/p&gt;

&lt;h1 id=&#34;mvcアーキテクチャ&#34;&gt;MVCアーキテクチャ&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2000年初頭&lt;/strong&gt;、&lt;a href=&#34;http://struts.apache.org/&#34;&gt;Struts&lt;/a&gt; (Struts1)というJavaのWebアプリケーションフレームワークが流行り、Controller (Java Servlet)がクライアントからリクエストを受け取り、Model (JavaBeans)がそれを処理して、View (JSP)がHTMLをレンダリングしてクライアントに返す、という、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_Controller&#34;&gt;MVCアーキテクチャ&lt;/a&gt;が流行った。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/500px-MVC-Process.svg.png&#34; alt=&#34;MVC&#34; title=&#34;MVC&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;Strutsに続いて&lt;a href=&#34;https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html&#34;&gt;Spring MVC&lt;/a&gt;、&lt;a href=&#34;https://rubyonrails.org/&#34;&gt;Ruby on Rails&lt;/a&gt;、&lt;a href=&#34;https://cakephp.org/jp&#34;&gt;CakePHP&lt;/a&gt;といったフレームワークが出てきて、MVCアーキテクチャによる開発効率や開発体験は洗練されていった。&lt;/p&gt;

&lt;h1 id=&#34;ajax&#34;&gt;Ajax&lt;/h1&gt;

&lt;p&gt;Strutsが全盛期の&lt;strong&gt;2005年&lt;/strong&gt;ころ、JavaScriptで非同期にサーバからデータを取得し、それをもとにクライアントサイドでHTMLを動的に編集するような技術に、&lt;a href=&#34;https://ja.wikipedia.org/wiki/Ajax&#34;&gt;Ajax&lt;/a&gt;という名前が付いた。&lt;/p&gt;

&lt;p&gt;Ajaxは「Asynchronous JavaScript + XML」の略で、&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/XMLHttpRequest&#34;&gt;XMLHttpRequest&lt;/a&gt; (略してXHR)というJavaScriptのAPIで
、サーバにHTTPリクエストを送り、そのレスポンスを非同期に処理する技術。
レスポンスは、当時XMLが流行っていたので、その形式で送ることが想定されていたが、実際にはどんな形式でもいい。はず。
最近はJSONで送られることがほとんど。&lt;/p&gt;

&lt;p&gt;JavaScriptはシングルスレッドで動くわけだけど、XMLHttpRequestはレスポンスを非同期に処理するため、リクエスト送信からレスポンス受信までの間、クライアントがスタックせずに済む。
また、通常のHTTPリクエストは、完全なHTMLドキュメントを受信して画面全体をレンダリングしなおす(i.e. 画面遷移する)のに対して、Ajaxは受信したデータをもとに画面の一部だけを更新するので、ネイティブアプリケーションに近めなユーザエクスペリエンスを実現できる。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var xhr = new XMLHttpRequest();
xhr.open(&#39;GET&#39;, &#39;https://httpbin.org/get&#39;, true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 &amp;amp;&amp;amp; xhr.status === 200) {
    console.log(xhr.responseText);
    // DOMをいじる処理
    // …
  }
};
xhr.send(null);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ajaxは、GoogleがGoogle Mapsで活用して一気に注目を集めた。
地図データをサーバから非同期に先読みするなどして、マウスのドラッグによって地図を滑らかにスクロールして見せるそのUIは当時画期的で、それまでの、画面遷移中心のUIからの飛躍を感じさせた。&lt;/p&gt;

&lt;h1 id=&#34;prototypeとjquery&#34;&gt;PrototypeとjQuery&lt;/h1&gt;

&lt;p&gt;Ajaxの普及を後押ししたのが、&lt;a href=&#34;http://prototypejs.org/&#34;&gt;Prototype&lt;/a&gt;と&lt;a href=&#34;https://jquery.com/&#34;&gt;jQuery&lt;/a&gt;というJavaScriptライブラリの登場だった。&lt;/p&gt;

&lt;p&gt;PrototypeはRubyにインスパイアされて開発され、Ruby on Railsに採用されたことで&lt;strong&gt;2005年&lt;/strong&gt;ころから普及したライブラリで、JavaScriptの標準グローバルオブジェクトであるArrayとかElementに便利メソッドを生やしたり、独自のグローバルユーティリティオブジェクトを追加したりして、Ajax処理をしやすくしたり、JavaScriptの機能を拡張してくれたりする。&lt;/p&gt;

&lt;p&gt;特に、当時のプロトタイプベースで使いにくかったJavaScriptのオブジェクト指向を扱いやすくしてくれる&lt;a href=&#34;http://prototypejs.org/learn/class-inheritance&#34;&gt;Class&lt;/a&gt;や、配列の処理に便利なeachとかmapとかincludeとかのメソッドを追加する&lt;a href=&#34;http://api.prototypejs.org/language/Enumerable/&#34;&gt;Enumerable&lt;/a&gt;なんかが熱かったように思う。&lt;/p&gt;

&lt;p&gt;一方jQueryは、ファーストバージョンが&lt;strong&gt;2006年8月&lt;/strong&gt;にリリースされ、ブラウザ間の非互換性をほとんど気にすることなく、簡潔なコードでDOM操作やAjax通信ができるAPIを提供した。
Prototypeと比べて、標準オブジェクトやグローバル名前空間を汚さない点がよかったのか、&lt;strong&gt;2007年&lt;/strong&gt; ころにはPrototypeを抜いて猛烈に普及した。&lt;/p&gt;

&lt;p&gt;この頃からWebアプリケーションは、UIはクライアントサイドのJavaScriptでインタラクティブな感じに書いて、サーバサイドはXMLHttpRequestに対してJSONデータを返すAPIサーバとして働く、という感じのものが増えていったように思う。
またこの頃から、クライアントサイドの開発が量質ともに上がったために独立した仕事になり、サーバサイドと対比して、前者をフロントエンド、後者をバックエンドと呼ぶようになってきた。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;因みに、PrototypeやjQueryと同様というかもう少し高機能な&lt;a href=&#34;https://dojotoolkit.org/&#34;&gt;Dojo Toolkit&lt;/a&gt;というライブラリが&lt;strong&gt;2004年&lt;/strong&gt;ころからあったんだけど、あまり流行らなかった。
カスタムビルドという、モジュールを結合してminifyする&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;みたいな機能を、&lt;a href=&#34;https://nodejs.org/ja/&#34;&gt;Node.js&lt;/a&gt;もない時代に実現していた先進的なライブラリだったんだけど、時代がついてこれなかったのかもしれない。&lt;/p&gt;

&lt;h1 id=&#34;ria-flashとか&#34;&gt;RIA (Flashとか)&lt;/h1&gt;

&lt;p&gt;WebアプリケーションにはAjaxと別の世界線もあった。&lt;/p&gt;

&lt;p&gt;そこでは&lt;strong&gt;1997年&lt;/strong&gt;ころに&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%AA%E3%83%83%E3%83%81%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%8D%E3%83%83%E3%83%88%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;RIA (Rich Internet Application)&lt;/a&gt;という言葉が生まれた。
これは、クライアントサイドの技術を駆使した、表現力やユーザビリティが高いWebアプリケーションのこと。&lt;/p&gt;

&lt;p&gt;(実際にはAjaxなアプリもこのくくりに入るが、ここでは非Web標準なクライアントサイド技術を使ったものの話を書く。)&lt;/p&gt;

&lt;p&gt;RIA技術の代表格である&lt;a href=&#34;https://ja.wikipedia.org/wiki/Adobe_Flash&#34;&gt;Flash&lt;/a&gt;は&lt;strong&gt;1996年&lt;/strong&gt;に生まれた。
このころはShockwave FlashとかMacromedia Flashとか呼ばれたが、開発元が&lt;strong&gt;2005年&lt;/strong&gt;にAdobeに買収されてAdobe Flashになり、そのあたりから&lt;strong&gt;2010年代前半&lt;/strong&gt;辺りまで最先端のWeb UI技術として甚だしく流行った。&lt;/p&gt;

&lt;p&gt;Flashは、&lt;a href=&#34;https://www.adobe.com/jp/products/flex.html&#34;&gt;Flex&lt;/a&gt;というフレームワーク(ツール?)のもと、&lt;a href=&#34;https://ja.wikipedia.org/wiki/ActionScript&#34;&gt;ActionScript&lt;/a&gt;というJavaScriptっぽいプログラミング言語と、&lt;a href=&#34;https://ja.wikipedia.org/wiki/MXML&#34;&gt;MXML&lt;/a&gt;というXMLなUI記述言語を駆使してWeb UIを開発できる技術。
WebブラウザにAdobe Flash PlayerとかAdobe AIRのプラグインを入れると表示できる。&lt;/p&gt;

&lt;p&gt;Flashの人気に触発されたのか、Microsoftが&lt;strong&gt;2007年&lt;/strong&gt;に&lt;a href=&#34;https://www.microsoft.com/silverlight/&#34;&gt;Silverlight&lt;/a&gt;というのをリリースした。
これは、&lt;a href=&#34;https://ja.wikipedia.org/wiki/.NET_Framework&#34;&gt;.NET Framework&lt;/a&gt;な言語(&lt;a href=&#34;https://docs.microsoft.com/ja-jp/dotnet/csharp/&#34;&gt;C#&lt;/a&gt;とか&lt;a href=&#34;https://msdn.microsoft.com/ja-jp/library/cc427807.aspx&#34;&gt;JScript&lt;/a&gt;とか)と、&lt;a href=&#34;https://docs.microsoft.com/ja-jp/dotnet/framework/wpf/advanced/xaml-overview-wpf&#34;&gt;XAML&lt;/a&gt;というHTMLっぽいUI記述言語を駆使してWeb UIを開発できる技術。
WebブラウザにMicrosoft Silverlightプラグインを入れると表示できる。&lt;/p&gt;

&lt;p&gt;また、Flashの誕生とほぼ同時期に、JavaでWebアプリケーションのUIを書く&lt;a href=&#34;https://ja.wikipedia.org/wiki/Java%E3%82%A2%E3%83%97%E3%83%AC%E3%83%83%E3%83%88&#34;&gt;Java Applet&lt;/a&gt;というのも生まれていた。が、初期のバージョンでロードに時間がかかったり動作が重かったりする問題があり、嫌厭されてFlashほど流行らなかった。
WebブラウザにJavaプラグインを入れると表示できる。
なぜか最近になって、&lt;strong&gt;2017年&lt;/strong&gt; 公開のマイナンバーのポータルサイトで採用されて話題になった。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;こうした非Web標準技術を使ったRIAは、Ajaxに比べてリッチな表現ができたり、ブラウザ間の非互換性に悩まされないところに優位性があったが、以下のような問題があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;プロプライエタリな技術をベースにしていて、実装がブラックボックスだったり、仕様の方向性がベンダの都合に左右されたり、ベンダロックインされやすかったりする。&lt;/li&gt;
&lt;li&gt;ユーザがブラウザにプラグインをいれてないと表示されない。&lt;/li&gt;
&lt;li&gt;セキュリティ問題が見つかった場合、オープンな技術のものに比べて対策が遅い傾向があるし、ベンダによる実装しかないので替えが利かない。&lt;/li&gt;
&lt;li&gt;他ベンダの技術や標準技術との親和性が無かったり、連携が弱かったりする。&lt;/li&gt;
&lt;li&gt;ブラウザ内で文字列検索ができなかったり、検索エンジンにまともにクローリングしてもらえない。&lt;/li&gt;
&lt;li&gt;動作が重い。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;このような問題のためか、Web標準周辺技術の発展に伴い、一時期は隆盛を誇ったFlashなども次第に廃れていった。&lt;/p&gt;

&lt;p&gt;Flashは&lt;strong&gt;2020年&lt;/strong&gt;に、Silverlightは&lt;strong&gt;2021年&lt;/strong&gt;にサポート終了になり、Java Appletは&lt;strong&gt;2018年9月&lt;/strong&gt;に出るJava 11で廃止されることが決まっている。&lt;/p&gt;

&lt;h1 id=&#34;html-5とcss-3とecmascript-5&#34;&gt;HTML 5とCSS 3とECMAScript 5&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2000年代中盤&lt;/strong&gt; から非Web標準なRIAが流行ったのは、そもそもWeb標準技術であるHTML、CSS、JavaScript(というかその標準仕様を定める&lt;a href=&#34;https://ja.wikipedia.org/wiki/ECMAScript&#34;&gt;ECMAScript&lt;/a&gt;)が、アプリケーションのUIを作るという目的で設計されているわけではなく、それらを使ってWeb UIを作ることに限界があったのが一因だったと思う。&lt;/p&gt;

&lt;p&gt;RIAの流行を受け、Web標準業界に危機感が募ったのか、&lt;strong&gt;2000年代後半&lt;/strong&gt; くらいからWeb標準技術にWeb UIを意識したバージョンアップの動きが始まった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/html/html5_intro.asp&#34;&gt;HTML 5&lt;/a&gt;の勧告 (&lt;strong&gt;2014年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるHTML 4.01の勧告が&lt;strong&gt;1999年&lt;/strong&gt;だったので、&lt;strong&gt;15年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;文書構造を表すタグの追加: &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;とか&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;図を表現するためのタグの追加: &lt;code&gt;&amp;lt;svg&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;canvas&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;inputタイプの追加: &lt;code&gt;date&lt;/code&gt;、&lt;code&gt;range&lt;/code&gt;、&lt;code&gt;email&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;inputタグの属性の追加: &lt;code&gt;autocomplete&lt;/code&gt;、&lt;code&gt;pattern&lt;/code&gt;、&lt;code&gt;placeholder&lt;/code&gt;、&lt;code&gt;required&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;マルチメディアのためのタグの追加:&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;と&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Webアプリケーション向けAPI追加: Drag and Drop、Local Storage、Web Workerとか。&lt;/li&gt;
&lt;li&gt;冗長だったり見た目に関するタグ・属性の削除: &lt;code&gt;&amp;lt;center&amp;gt;&lt;/code&gt;とか&lt;code&gt;&amp;lt;font&amp;gt;&lt;/code&gt;とか&lt;code&gt;border&lt;/code&gt;とか&lt;code&gt;color&lt;/code&gt;とか。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data-*&lt;/code&gt;属性のサポート。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/CSS/CSS3&#34;&gt;CSS 3&lt;/a&gt;の勧告 (&lt;strong&gt;2011年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるCSS 2の勧告が&lt;strong&gt;1998年&lt;/strong&gt;だったので、&lt;strong&gt;13年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;角丸、シャドウ、グラデーションのサポート。&lt;/li&gt;
&lt;li&gt;セレクタの機能追加: 属性値の部分マッチ、nth-childなど。&lt;/li&gt;
&lt;li&gt;メディアクエリ。&lt;/li&gt;
&lt;li&gt;Flexboxレイアウト、Gridレイアウト。&lt;/li&gt;
&lt;li&gt;Webフォント。&lt;/li&gt;
&lt;li&gt;トランジション、トランスフォーム、アニメーション。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/js/js_es5.asp&#34;&gt;ECMAScript 5&lt;/a&gt;の発行 (&lt;strong&gt;2009年&lt;/strong&gt;)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;それまでの標準であるECMAScript 3の勧告が&lt;strong&gt;1999年&lt;/strong&gt;だったので、&lt;strong&gt;10年&lt;/strong&gt; ぶり。&lt;/li&gt;
&lt;li&gt;strictモード。&lt;/li&gt;
&lt;li&gt;Arrayのメソッド追加: forEach、map、filterなど。&lt;/li&gt;
&lt;li&gt;Objectのメソッド追加: keys、freezeなど。&lt;/li&gt;
&lt;li&gt;グローバルオブジェクトにJSONが追加。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第1世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第1世代)&lt;/h1&gt;

&lt;p&gt;Web標準技術が進化して表現力が上がり、ECMAScript 5やjQueryによってロジックを書きやすくなり、人々がWeb UIをバリバリ書けるようになり、RIAの影響もあってUIの複雑化が進んだ。&lt;/p&gt;

&lt;p&gt;UIが複雑化すると、ユーザ入力の処理、Ajaxによるサーバとのデータ通信、UIの状態の取得、DOMの操作なんかを、何の秩序も構造化もレイヤー分けもなくナイーブにコーディングするのが辛くなってきた。&lt;/p&gt;

&lt;p&gt;この辛みに対処すべく誕生してきたのが数多のJavaScriptフロントエンドフレームワーク。
&lt;strong&gt;2018年現在&lt;/strong&gt; まで続くフロントエンドフレームワーク戦国時代の幕開けである。&lt;/p&gt;

&lt;p&gt;フロントエンドフレームワークは大抵以下のような機能を提供してくれる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UI(View)の記述を楽にする何か。テンプレートエンジンとか。&lt;/li&gt;
&lt;li&gt;Viewに表示しているデータとJavaScriptプログラムで保持しているデータを紐づける仕組み。(i.e. &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%90%E3%82%A4%E3%83%B3%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0&#34;&gt;データバインディング&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Ajaxユーティリティ。&lt;/li&gt;
&lt;li&gt;URLをViewやロジックと紐づける仕組み。(i.e. URLルーティング)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;フロントエンドフレームワーク戦国時代初期に生まれた主要なフロントエンドフレームワークを列挙する。&lt;/p&gt;

&lt;p&gt;(この記事では便宜上第1世代と呼ぶ。)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://knockoutjs.com/&#34;&gt;Knockout&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://ja.wikipedia.org/wiki/Model_View_ViewModel&#34;&gt;MVVMアーキテクチャ&lt;/a&gt;。

&lt;ul&gt;
&lt;li&gt;ModelがUIと独立してデータ(Ajaxでサーバから取ったものなど)を保持する。&lt;/li&gt;
&lt;li&gt;ViewModelがUIに紐づくデータとその操作を表現する。&lt;/li&gt;
&lt;li&gt;ViewはDOMツリー。ViewModelへの変更は自動でViewに反映されるし、その逆もしかり。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://backbonejs.org/&#34;&gt;Backbone.js&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;主にModelとViewからなるMVC的アーキテクチャ。

&lt;ul&gt;
&lt;li&gt;Modelはデータとビジネスロジックを表現する。

&lt;ul&gt;
&lt;li&gt;サーバから取ってきたデータを保持。&lt;/li&gt;
&lt;li&gt;ビジネスロジックによってデータが変わると、イベントを生成。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ViewがModelをDOMに反映する。

&lt;ul&gt;
&lt;li&gt;ModelからのイベントをlistenしてDOMに反映。&lt;/li&gt;
&lt;li&gt;ユーザからの入力を取得して、Modelに渡す。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.emberjs.com/&#34;&gt;Ember.js&lt;/a&gt; v1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2011年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;URLルーティングをコアとするコンセプトが特徴的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angularjs.org/&#34;&gt;AngularJS&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2012年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Google製。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;DIやテストなどのサポートまであるフルスタックフレームワーク。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第1世代は、フロントエンドの世界にMVCアーキテクチャ(とその派生)をもたらした。&lt;/p&gt;

&lt;p&gt;このMVCは、Struts時代のMVCとは違い、完全にクライアントサイドに閉じたアーキテクチャだ。
サーバ側はエントリーポイントとしてHTML(とCSSとJavaScript)をサーブするほかは、JSONを返すAPIサーバとしての役割に徹する。
このようなWebアプリケーションは、ページ遷移が発生せず、単一ページだけでUIが構成されるので、&lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%B7%E3%83%B3%E3%82%B0%E3%83%AB%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3&#34;&gt;Single Page Application (SPA)&lt;/a&gt;と呼ばれる。&lt;/p&gt;

&lt;p&gt;ModelとViewとの間でのデータの同期の仕方には以下のように2方向がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;M⇒V: Modelを更新すると対応するViewが自動で更新される。&lt;/li&gt;
&lt;li&gt;V⇒M: Viewがユーザ入力などによって変更されるとModelが自動で更新される。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前者だけをするのが1-wayバインディングで、両方するのが2-wayバインディング。
上に挙げた中では、Backbone.js以外が2-wayバインディング推しで、このころは2-wayバインディングが正義だったっぽい。&lt;/p&gt;

&lt;h1 id=&#34;commonjs-node-js-パッケージマネージャ-モジュールバンドラ-altjs-altcss-トランスパイラ-タスクランナー&#34;&gt;CommonJS、Node.js、パッケージマネージャ、モジュールバンドラ、AltJS、AltCSS、トランスパイラ、タスクランナー&lt;/h1&gt;

&lt;p&gt;第1世代のフロントエンドフレームワークが出始めたころ、JavaScriptの言語周りの環境にも大きな変化があった。
正直書くの辛くなってきたので、一気に片付ける。&lt;/p&gt;

&lt;h3 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h3&gt;

&lt;p&gt;クライアントサイドでJavaScriptが盛り上がっているのを見て、もっとJavaScriptいろんなところで活用できるんじゃね?
となって、ブラウザの外でも普通のプログラミング言語としてJavaScriptを使うためには、どんな機能を追加すべきか、みたいな議論をするプロジェクトが&lt;strong&gt;2009年&lt;/strong&gt;に立ち上がった。
&lt;a href=&#34;http://www.commonjs.org/&#34;&gt;CommonJS&lt;/a&gt;である。&lt;/p&gt;

&lt;p&gt;CommonJSの最大の功績は多分、モジュールシステムを言語仕様でちゃんとサポートしよう、と言ったこと。
モジュールシステムは、Cでいうincludeとか、JavaやPythonのimportとか、そういう機能。
JavaScriptにはもともとそういうのが無くて、単にファイルを分割して個別にロードしていただけだったので、名前空間がコンフリクトしたりしなかったりしてた。&lt;/p&gt;

&lt;p&gt;因みに、JavaScriptのモジュールシステムには、CommonJSのやつ以外にも&lt;a href=&#34;https://en.wikipedia.org/wiki/Asynchronous_module_definition&#34;&gt;AMD&lt;/a&gt;というのがあったけど、そっちは盛り上がらなかった。&lt;/p&gt;

&lt;h3 id=&#34;node-js&#34;&gt;Node.js&lt;/h3&gt;

&lt;p&gt;CommonJSの流れを汲んで、サーバサイドのJavaScriptランタイムとして&lt;a href=&#34;https://nodejs.org/en/&#34;&gt;Node.js&lt;/a&gt;が&lt;strong&gt;2009年&lt;/strong&gt;にリリースされた。
これにより、ブラウザ外でJavaScriptを実行できるようになり、以降のJavaScript開発体験の劇的な改善につながった。&lt;/p&gt;

&lt;h3 id=&#34;パッケージマネージャ&#34;&gt;パッケージマネージャ&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;2010年&lt;/strong&gt; には、Node.jsにパッケージマネージャとして&lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;が同梱されるようになった。
これにより、モジュールを公開してシェアして再利用する文化が定着し、JavaScriptプログラムの開発効率や品質がかなり向上したはず。&lt;/p&gt;

&lt;p&gt;パッケージマネージャとしてはもうひとつ、&lt;a href=&#34;https://bower.io/&#34;&gt;Bower&lt;/a&gt;というのが&lt;strong&gt;2012年&lt;/strong&gt;に出た。
npmはサーバサイドのパッケージ、Bowerはクライアントサイドのパッケージ、みたいな住みわけが当初はあったが、最近は全部npmになってBower使ってるプロジェクトは見なくなった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2016年10月&lt;/strong&gt; には、Facebookが&lt;a href=&#34;https://yarnpkg.com/lang/ja/&#34;&gt;Yarn&lt;/a&gt;というnpmを代替するツールを&lt;a href=&#34;https://code.fb.com/web/yarn-a-new-package-manager-for-javascript/&#34;&gt;発表&lt;/a&gt;。
パッケージバージョンのロック、&lt;a href=&#34;https://twitter.com/madbyk/status/988795520805203969?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E988795520805203969&amp;amp;ref_url=https%3A%2F%2Fblog.risingstack.com%2Fyarn-vs-npm-node-js-package-managers%2F&#34;&gt;CDN (CloudFlare)&lt;/a&gt;・キャッシュ・並列処理によるパッケージダウンロードの高速化、パッケージ間のバージョンの不整合解消(フラットモード)、といった機能により、発表直後から急速にシェアを伸ばした。&lt;/p&gt;

&lt;h3 id=&#34;モジュールバンドラ&#34;&gt;モジュールバンドラ&lt;/h3&gt;

&lt;p&gt;サーバサイドでモジュールシステムができたのはよかったけど、その仕様がブラウザでサポートされることは終ぞなかった。
ので、モジュールバンドラというものが生まれた。
これは、ソース中のモジュールインポート(requireとかimport)をたどって、モジュール分割されたソースをブラウザが読めるように一つに結合してくれるツール。&lt;/p&gt;

&lt;p&gt;モジュールバンドラのパイオニアが、&lt;strong&gt;2011年&lt;/strong&gt; にリリースされた&lt;a href=&#34;http://browserify.org/&#34;&gt;Browserify&lt;/a&gt;。
Browserifyは、モジュールの結合だけでなく、Node.js特有のAPIをある程度ブラウザでも動くようにしてくれるなど、魔法のようなツールだった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2012年&lt;/strong&gt; には&lt;a href=&#34;https://webpack.js.org/&#34;&gt;webpack&lt;/a&gt;というモジュールバンドラが出て、後述のトランスパイラと上手く連携したり、JavaScriptだけでなくCSSもHTMLもフォントも画像ファイルもなんでもバンドルできる高機能により、Browserifyを食った。&lt;/p&gt;

&lt;p&gt;モジュールバンドルすると、ファイルサイズが大きくなって、ブラウザでロードするのに時間がかかって、初期画面の表示が遅くなる問題があった。
&lt;strong&gt;2015年&lt;/strong&gt;、その問題を軽減すべく、&lt;a href=&#34;https://rollupjs.org/guide/en&#34;&gt;Rollup&lt;/a&gt;というのが出てきた。
Rollupは、&lt;a href=&#34;https://rollupjs.org/guide/en#tree-shaking&#34;&gt;Tree-shaking&lt;/a&gt;という機能で、バンドル時に不要なコードを削除することでファイルサイズを小さくできることを売りにした。
が、webpackがバージョン2でTree-shakingをサポートしたため、使う理由がなくなった。&lt;/p&gt;

&lt;p&gt;webpackは機能的には最高にクールだったが、設定が複雑で設定ファイルが肥大化するという問題があった。
この問題を解消すべく、&lt;strong&gt;2017年末&lt;/strong&gt; に&lt;a href=&#34;https://parceljs.org/&#34;&gt;Parcel&lt;/a&gt;というモジュールバンドラがリリースされ、ゼロ設定で使えるということで人気を集めてきている。
今の時点でプロダクションレディなレベルなのかは疑問。&lt;/p&gt;

&lt;h3 id=&#34;altjs&#34;&gt;AltJS&lt;/h3&gt;

&lt;p&gt;上に書いた通り、&lt;strong&gt;2009年&lt;/strong&gt; にECMAScript 5が発行されて、JavaScriptは若干改善されたわけだけど、はっきり言ってまだまだ貧弱な言語だった。
そこに&lt;a href=&#34;https://coffeescript.org/&#34;&gt;CoffeeScript&lt;/a&gt;が登場。
&lt;strong&gt;2009年末&lt;/strong&gt; のことだった。&lt;/p&gt;

&lt;p&gt;CoffeeScriptは、RubyやPythonみたいな簡潔で機能的な構文を備えた生産性の高い言語で、JavaScriptにコンパイルできる。
クラス構文とか、アロー関数とか、配列内包表記とか、インデントによるブロック構造とかを実現してて書き心地がかなりよかったのと、Ruby on Railsに採用されたというのもあって、&lt;strong&gt;2010年代中盤&lt;/strong&gt; くらいまで結構流行った。&lt;/p&gt;

&lt;p&gt;CoffeeScriptのように、JavaScriptの代替として使い、JavaScriptに変換して実行するのを主なユースケースとする言語を、AltJS (Alternative JavaScript)と呼ぶ。
(なので、&lt;a href=&#34;https://kotlinlang.org/&#34;&gt;Kotlin&lt;/a&gt;とか&lt;a href=&#34;https://clojurescript.org/&#34;&gt;Clojure(Script)&lt;/a&gt;とか&lt;a href=&#34;https://haxe.org/&#34;&gt;Haxe&lt;/a&gt;なんかはJavaScriptにもコンパイルできるけど、ここではAltJSとして扱わない。)
CoffeeScriptの最大の功績は、このAltJSという分野を切り開き、JavaScriptフロントエンドにコンパイルという概念を持ち込んだことだったと思う。&lt;/p&gt;

&lt;p&gt;CoffeeScript自体はその後、&lt;strong&gt;2015年&lt;/strong&gt; に発行されたECMAScript 2015がその仕様を取り込んだことで役目を終えた。
&lt;strong&gt;2017年9月&lt;/strong&gt; に&lt;a href=&#34;https://coffeescript.org/announcing-coffeescript-2/&#34;&gt;バージョン2をアナウンス&lt;/a&gt;して再起を図ったが、そのころすでに他に有力なAltJSが出てたし、ECMAScriptも結構成熟してきてたし、あまり注目されなかった。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;AltJSには他に以下のようなものがあるが、ほぼTypeScriptしか使われてなさそう。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.typescriptlang.org/&#34;&gt;TypeScript&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2012年10月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Microsoft製。&lt;/li&gt;
&lt;li&gt;静的型付けが最大の特徴で、他にもクラスやアロー関数やレキシカル変数などをサポート。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.purescript.org/&#34;&gt;PureScript&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年4月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;強い静的型付けの関数型言語。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dartlang.org/&#34;&gt;Dart&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2011年10月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Google製。&lt;/li&gt;
&lt;li&gt;全く流行らなかったし、Google自身も社内標準プログラミング言語にTypeScriptを採用したので、あまりだれも使ってなくてよくわからない。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fuchsia.googlesource.com/&#34;&gt;Fuchsia&lt;/a&gt;のUIに使われているらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2018年8月&lt;/strong&gt; にバージョン2がリリースされ、&lt;a href=&#34;https://flutter.io/&#34;&gt;Flutter&lt;/a&gt;(&lt;strong&gt;2017年5月&lt;/strong&gt; 初版リリース)の人気の高まりもあって、モバイルアプリ開発者を中心にユーザを増やしてきているらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jsx.github.io/&#34;&gt;JSX&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;DeNA製。&lt;/li&gt;
&lt;li&gt;名前がReactの&lt;a href=&#34;https://reactjs.org/docs/introducing-jsx.html&#34;&gt;JSX&lt;/a&gt;と紛らわしい。&lt;/li&gt;
&lt;li&gt;誰も使ってないし、&lt;strong&gt;2014年&lt;/strong&gt; くらいから開発止まってる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://flow.org/&#34;&gt;Flow&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年11月&lt;/strong&gt; 初版リリース。&lt;/li&gt;
&lt;li&gt;Facebook製。&lt;/li&gt;
&lt;li&gt;AltJSというべきものかは微妙。JavaScriptに静的な型情報を付加するためのもの。&lt;/li&gt;
&lt;li&gt;ReactなどのFacebookのプロジェクトや&lt;a href=&#34;https://jp.vuejs.org/index.html&#34;&gt;Vue.js&lt;/a&gt;で使われていてそれなりに存在感があるが、TypeScriptに押され気味。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;altcss&#34;&gt;AltCSS&lt;/h3&gt;

&lt;p&gt;CSSにもalternativesがある。
というかAltJSよりも歴史が古い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://sass-lang.com/&#34;&gt;Sass&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2006年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;SASS記法とSCSS記法がある。&lt;/li&gt;
&lt;li&gt;AltCSSでは1番人気っぽい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lesscss.org/&#34;&gt;Less&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2009年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Sassに感銘を受けたけど、そのSASS記法がCSSと違いすぎてちょっと、と思った人がCSSに寄せて作った。けどSassもCSSに寄せたSCSS記法をサポートしたため食われた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://stylus-lang.com/&#34;&gt;Stylus&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2010年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://postcss.org/&#34;&gt;PostCSS&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;正確にはAltCSSではなく、CSSを処理するツールをJavaScriptで開発できるフレームワーク。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://preset-env.cssdb.org/&#34;&gt;PostCSS Preset Env&lt;/a&gt;というプラグインとともに使うと、CSSのエッジな機能を使えるようになる。つまりどちらかといえば後述のトランスパイラに近い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;トランスパイラ&#34;&gt;トランスパイラ&lt;/h3&gt;

&lt;p&gt;CoffeeScriptの流行などを受けて、ECMAScriptに再び改善の圧力がかかったのか、&lt;strong&gt;2011年後半&lt;/strong&gt; ころから次期ECMAScriptの議論が活発化した。
&lt;strong&gt;2015年&lt;/strong&gt; に満を持してECMAScript 6改めECMAScript 2015が発行された。&lt;/p&gt;

&lt;p&gt;ECMAScript 2015は、クラス構文、アロー関数、レキシカル変数、定数、関数のデフォルト引数、ジェネレータ、テンプレート文字列、モジュールシステムなどをサポートし、一気にまともなプログラミング言語になった。&lt;/p&gt;

&lt;p&gt;しかし、それらの新しい機能をアプリケーションに使うには、各社のブラウザのJavaScriptエンジンが実装して、さらにその実装したバージョンのブラウザがユーザに十分に行きわたるのを待たないといけない。
ECMAScriptの新機能は、正式に発行される前から仕様が公開され、ブラウザが先行して実装してはいくものの、&lt;a href=&#34;http://threevirtues.com/&#34;&gt;プログラマは短気&lt;/a&gt;なのでそんなの待ってられない。&lt;/p&gt;

&lt;p&gt;といった状況のなか、&lt;strong&gt;2014年10月&lt;/strong&gt; に&lt;a href=&#34;https://www.npmjs.com/package/6to5&#34;&gt;6to5&lt;/a&gt;というツールがnpmで公開された。
ECMAScript 6で書かれたコードをECMAScript 5なコードに変換してくれる、トランスパイラというツールだった。&lt;/p&gt;

&lt;p&gt;(実はトランスパイラとしては&lt;strong&gt;2013年3月&lt;/strong&gt;に公開されたGoogle製の&lt;a href=&#34;https://github.com/google/traceur-compiler&#34;&gt;Traceur&lt;/a&gt;とか、&lt;strong&gt;2014年4月&lt;/strong&gt; に公開されたEmber.jsチーム製の&lt;a href=&#34;https://esnext.github.io/esnext/&#34;&gt;esnext&lt;/a&gt;のほうが先駆けだったんだけど、6to5の開発スピードがとんでもなく早く、&lt;strong&gt;2015年1Q&lt;/strong&gt; には機能面で両者を抜いてしまったらしい。)&lt;/p&gt;

&lt;p&gt;6to5は&lt;strong&gt;2015年2月&lt;/strong&gt;に名前を&lt;a href=&#34;https://babeljs.io/&#34;&gt;Babel&lt;/a&gt;に&lt;a href=&#34;https://babeljs.io/blog/2015/02/15/not-born-to-die&#34;&gt;変えて&lt;/a&gt;、単に6to5という名前が示す機能だけでなく、JavaScript周りの様々なツールを開発・統合するためのプラットフォームとなった。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2018年現在&lt;/strong&gt;、Babel無しでフロントエンド開発をすることはほぼ無さそうな感じになってる。&lt;/p&gt;

&lt;h3 id=&#34;タスクランナー&#34;&gt;タスクランナー&lt;/h3&gt;

&lt;p&gt;モジュールバンドラやら、AltJSやら、AltCSSやらで、フロントエンドにコンパイルとかビルドとかいう作業が必要になって来たため、この業界にも必然的にタスクランナーが登場してきた。&lt;/p&gt;

&lt;p&gt;タスクランナーというのは、他業界ではビルドツールなどとも呼ばれているもので、Cとかで使われる&lt;a href=&#34;https://ja.wikipedia.org/wiki/Make&#34;&gt;Make&lt;/a&gt;とか、Javaの&lt;a href=&#34;https://ant.apache.org/&#34;&gt;Ant&lt;/a&gt;とか&lt;a href=&#34;https://maven.apache.org/&#34;&gt;Maven&lt;/a&gt;とか&lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt;とか、Googleの&lt;a href=&#34;https://bazel.build/&#34;&gt;Bazel&lt;/a&gt;とかと同様のもの。&lt;/p&gt;

&lt;p&gt;まず、&lt;strong&gt;2012年1月&lt;/strong&gt; に&lt;a href=&#34;https://gruntjs.com/&#34;&gt;Grunt&lt;/a&gt;がリリースされて人気を博した。
が、当時のGruntの設定ファイルがJSONで&lt;a href=&#34;http://monmon.hatenablog.com/entry/2013/12/20/151321&#34;&gt;書きにくい&lt;/a&gt;とか、処理がシーケンシャルで遅いとかいう不満が潜在的に溜まっていった。&lt;/p&gt;

&lt;p&gt;で、それらの問題を払拭する&lt;a href=&#34;https://gulpjs.com/&#34;&gt;gulp&lt;/a&gt;が&lt;strong&gt;2013年7月&lt;/strong&gt;に出て、Gruntを食った。&lt;/p&gt;

&lt;p&gt;けど結局、Gruntもgulpも、タスクの処理をどこかの馬の骨が作ったプラグインに頼っていて不安定で、またビルドツールというレイヤが増えたせいでビルドエラーのデバッグがし辛くなるという&lt;a href=&#34;https://qiita.com/chuck0523/items/dafdbd19c12efd40e2de&#34;&gt;根本的な問題が顕在化&lt;/a&gt;し、&lt;a href=&#34;https://docs.npmjs.com/misc/scripts&#34;&gt;npm-scripts&lt;/a&gt;でいいじゃん、ってなった。&lt;/p&gt;

&lt;p&gt;シンプルイズベスト。&lt;/p&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第2世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第2世代)&lt;/h1&gt;

&lt;p&gt;前章で書いたフロントエンド界の変容の後あたりに、当時の先端技術を取り入れて誕生したフロントエンドフレームワークを、この記事では第2世代と呼ぶ。&lt;/p&gt;

&lt;p&gt;第2世代は第1世代から正統な進化を遂げた感じで、あいかわらずMVW (i.e. MV*)だった。
主要なのは以下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://polymer-library.polymer-project.org/&#34;&gt;Polymer&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年11月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Googleのエンジニア達が作った。&lt;/li&gt;
&lt;li&gt;最初は単なる&lt;a href=&#34;https://en.wikipedia.org/wiki/Polyfill_%28programming%29&#34;&gt;Polyfill&lt;/a&gt;ライブラリとして世に出て、徐々に機能を増やし、&lt;a href=&#34;https://material.io/design/&#34;&gt;マテリアルデザイン&lt;/a&gt;の標準実装となり、さらに膨らんできている。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/Web_Components&#34;&gt;Web Component&lt;/a&gt;とか&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/API/ServiceWorker_API&#34;&gt;Service Worker&lt;/a&gt;といったエッジなWeb標準技術を取り入れた軽くて強力なフレームワーク。&lt;/li&gt;
&lt;li&gt;2-wayバインディングもできる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://vuejs.org/&#34;&gt;Vue.js&lt;/a&gt; v1&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2013年12月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;Googleのエンジニア(個人)製。&lt;/li&gt;
&lt;li&gt;MVVMアーキテクチャ。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mizchi.hatenablog.com/entry/2014/02/13/153742&#34;&gt;軽量AngularJS&lt;/a&gt;な感じらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://riot.js.org/&#34;&gt;Riot&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2014年6月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSもReactも複雑すぎ。フロントエンド開発に必要十分なコンパクトな機能を提供するぜ、というフレームワーク。&lt;/li&gt;
&lt;li&gt;Aureliaよりかは使われていそう。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://aurelia.io/&#34;&gt;Aurelia&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年11月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSっぽいフルスタックフレームワークで、EcmaScript 2015+とかWeb Componentsとかの先端技術を取り入れていることが売り。&lt;/li&gt;
&lt;li&gt;2-wayバインディング推しで、あまり流行らなかった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://angular.io/&#34;&gt;Angular&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年9月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;AngularJSの後継。AngularJSとの互換性をばっさり切り捨てる代わりに、アーキテクチャを刷新し、性能面と機能面の&lt;a href=&#34;https://medium.com/@mnemon1ck/why-you-should-not-use-angularjs-1df5ddf6fc99&#34;&gt;色々な問題&lt;/a&gt;を克服したらしい。&lt;/li&gt;
&lt;li&gt;が、Reactが画期的過ぎてAngularJSの栄光は取り戻せなかった。&lt;/li&gt;
&lt;li&gt;最初2-wayバインディングまで切り捨てたが、あとで復活させた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;react-virtual-dom&#34;&gt;React (Virtual DOM)&lt;/h1&gt;

&lt;p&gt;第1世代から流行っていた2-wayバインディングがちょっと&lt;a href=&#34;https://stackoverflow.com/questions/35379515/why-is-two-way-databinding-in-angularjs-an-antipattern&#34;&gt;辛みを帯びてきた&lt;/a&gt;。
というか、2-wayバインディングしかできないAngularJSが辛くなってきたということだったのかもしれない。&lt;/p&gt;

&lt;p&gt;2-wayバインディングには以下のような問題があった。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;変更をwatchするオブジェクトが増えて、性能が悪くなる。&lt;/li&gt;
&lt;li&gt;ModelとViewとの間の依存やデータの流れが複雑になって、コーディングやデバッグが難しくなる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これに異を唱えて登場してきたのがFacebookによる&lt;a href=&#34;https://reactjs.org/&#34;&gt;React&lt;/a&gt;。
&lt;strong&gt;2013年3月&lt;/strong&gt; のことであった。&lt;/p&gt;

&lt;p&gt;2-wayバインディングもMVCもテンプレートも要らんとして、代わりにReactが突きつけてきた&lt;a href=&#34;https://reactjs.org/docs/faq-internals.html&#34;&gt;Virtual DOM&lt;/a&gt;という解は、世界中の人々の&lt;a href=&#34;https://qiita.com/mizchi/items/4d25bc26def1719d52e6&#34;&gt;魂を震えさせた&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Virtual DOMは、その名の通りDOMの仮想化であり、JavaScriptからReactのAPIを通してDOMのようなものを更新すると、Reactがいい感じに実DOMを更新してくれるというもの。
開発者は深く考えずに、イベントが発生するごとに、ページ全体を表すDOMツリーがどうなっているべきかをReactに教えるだけでいい。
あとはReactが、現在の実DOMとの差分を計算し、差分だけを性能よく更新してくれる。
これによって開発者は、DOMの状態やイベントの種類をみてアドホックに実DOMやModelの更新処理を書くという苦行から解放され、宣言的に&lt;a href=&#34;http://blog.neleid.com/2016/04/05/%E5%AF%8C%E8%B1%AA%E7%9A%84%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E3%81%AF%E6%AD%BB%E8%AA%9E%E3%81%8B/&#34;&gt;富豪的に&lt;/a&gt;フロントエンドプログラミングができるようになった。&lt;/p&gt;

&lt;p&gt;さらに&lt;strong&gt;2014年5月&lt;/strong&gt;、Reactにベストマッチするアプリケーションアーキテクチャとして&lt;a href=&#34;https://facebook.github.io/flux/&#34;&gt;Flux&lt;/a&gt;が発表された。
これは単方向のデータフローが特徴のアーキテクチャで、斬新でかっこよくて未来だった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/facebook/flux/raw/master/docs/img/flux-diagram-white-background.png&#34; alt=&#34;Flux&#34; title=&#34;Flux&#34; /&gt;
&lt;/p&gt;

&lt;h1 id=&#34;javascriptフロントエンドフレームワーク-第3世代&#34;&gt;JavaScriptフロントエンドフレームワーク (第3世代)&lt;/h1&gt;

&lt;p&gt;React後、Virtual DOMの実装がいくつも出てきた。
&lt;a href=&#34;https://github.com/Matt-Esch/virtual-dom&#34;&gt;virtual-dom&lt;/a&gt;とか&lt;a href=&#34;https://maquettejs.org/&#34;&gt;Maquette&lt;/a&gt;とか&lt;a href=&#34;https://preactjs.com/&#34;&gt;Preact&lt;/a&gt;とか&lt;a href=&#34;https://infernojs.org/&#34;&gt;Inferno&lt;/a&gt;とか。&lt;/p&gt;

&lt;p&gt;Fluxの実装も、Facebook自身による&lt;a href=&#34;https://github.com/facebook/flux&#34;&gt;Flux&lt;/a&gt;のほか、&lt;a href=&#34;http://fluxxor.com/&#34;&gt;Fluxxor&lt;/a&gt;とか&lt;a href=&#34;https://redux.js.org/&#34;&gt;Redux&lt;/a&gt;とか&lt;a href=&#34;https://mobx.js.org/&#34;&gt;MobX&lt;/a&gt;とか沢山出た。&lt;/p&gt;

&lt;p&gt;で、React+Reduxがいい感じってなって、&lt;a href=&#34;https://medium.com/@TechMagic/reactjs-vs-angular5-vs-vue-js-what-to-choose-in-2018-b91e028fa91d&#34;&gt;世界の8割近くの人がReactで書くようになって&lt;/a&gt;、猫も杓子もVirtual DOMってなった辺りのフロントエンドフレームワークを第3世代と呼ぶことにする。&lt;/p&gt;

&lt;p&gt;第3世代としては以下が挙げられる。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://grommet.io/&#34;&gt;Grommet&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年6月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;HPE製。&lt;/li&gt;
&lt;li&gt;Reactと&lt;a href=&#34;https://github.com/inuitcss/inuitcss&#34;&gt;inuitcss&lt;/a&gt;によるフレームワーク。&lt;/li&gt;
&lt;li&gt;全然流行ってないけど&lt;a href=&#34;http://grommet.io/docs/components&#34;&gt;コンポーネント&lt;/a&gt;の取り揃えがよくて結構いいような気がする。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://emberjs.com/blog/2015/08/13/ember-2-0-released.html&#34;&gt;Ember.js v2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2015年8月&lt;/strong&gt; リリース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://glimmerjs.com/&#34;&gt;Glimmer&lt;/a&gt;というレンダリングエンジンを搭載。

&lt;ul&gt;
&lt;li&gt;Glimmerは、テンプレートをGlimmer VM上で動くバイトコードにコンパイルして、実DOMを速くレンダリングしてくれるもの。&lt;/li&gt;
&lt;li&gt;Virtual DOMとは違う感じだけど、実DOMの更新を開発者の代わりにやってくれるあたり、目指しているものは同じ。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://jp.vuejs.org/2016/10/01/here-2.0/&#34;&gt;Vue.js v2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年10月&lt;/strong&gt; リリース。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/snabbdom/snabbdom&#34;&gt;snabbdom&lt;/a&gt;ベースのVirtual DOM実装を搭載。&lt;/li&gt;
&lt;li&gt;2017年頭位からかなりの勢いで流行ってきている。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://svelte.technology/&#34;&gt;Svelte&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2016年11月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/rich_harris&#34;&gt;Rich Harris&lt;/a&gt;という個人が開発。&lt;/li&gt;
&lt;li&gt;フレームワークレスとか消えるフレームワークなどと呼ばれる一風変わったフレームワーク。&lt;/li&gt;
&lt;li&gt;Virtual DOMではない。&lt;/li&gt;
&lt;li&gt;コンパイルするとピュアなHTMLとCSSとJavaScriptが生成される。Webフロントエンド言語と呼んだほうがいいのかも。&lt;/li&gt;
&lt;li&gt;海外ではぼちぼち使われている模様。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://hyperapp.js.org/&#34;&gt;Hyperapp&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2017年1月&lt;/strong&gt; に誕生。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/&#34;&gt;Qiita&lt;/a&gt;で働いてるエンジニアが趣味で作ったフレームワークで、Qiitaに採用された。&lt;/li&gt;
&lt;li&gt;超軽量(1KB!)で、シンプルが売り。&lt;/li&gt;
&lt;li&gt;独自のVirtual DOM実装であるPicodom(現&lt;a href=&#34;https://github.com/jorgebucaran/superfine&#34;&gt;superfine&lt;/a&gt;)を搭載。&lt;/li&gt;
&lt;li&gt;JSXにも対応。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://dojo.io/&#34;&gt;Dojo&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2018年5月&lt;/strong&gt; 正式版リリース。&lt;/li&gt;
&lt;li&gt;Dojo Toolkitの後継。&lt;/li&gt;
&lt;li&gt;Virtual DomでTypeScriptでリアクティブでフルスタック。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;終わりに&#34;&gt;終わりに&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2018年8月現在&lt;/strong&gt; では、React vs Vue.js vs Angularといった感じで、激動の時代が過ぎてやや落ち着いて来ている感があるが、油断はできない。
実際、最近&lt;a href=&#34;http://elm-lang.org/&#34;&gt;Elm&lt;/a&gt;という関数型AltJS兼Frontendフレームワークがじわじわ盛り上がってきている感じがあり、一波乱あるかもしれない。&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;いろいろ書いたけど、&lt;a href=&#34;https://electronjs.org/&#34;&gt;Electron&lt;/a&gt;とか&lt;a href=&#34;https://facebook.github.io/react-native/&#34;&gt;React Native&lt;/a&gt;とか&lt;a href=&#34;https://nextjs.org&#34;&gt;Next.js&lt;/a&gt;とかの&lt;a href=&#34;https://jp.vuejs.org/v2/guide/ssr.html&#34;&gt;SSR&lt;/a&gt;とか&lt;a href=&#34;https://www.gatsbyjs.org/&#34;&gt;Gatsby.js&lt;/a&gt;とか&lt;a href=&#34;https://graphql.org/learn/&#34;&gt;GraphQL&lt;/a&gt;とか&lt;a href=&#34;https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/?hl=ja&#34;&gt;PWA&lt;/a&gt;とか&lt;a href=&#34;https://webassembly.org/&#34;&gt;WebAssembly&lt;/a&gt;とか&lt;a href=&#34;https://aws.amazon.com/jp/getting-started/serverless-web-app/&#34;&gt;サーバーレス&lt;/a&gt;とか&lt;a href=&#34;https://kuroeveryday.blogspot.com/2017/03/css-structure-and-rules.html&#34;&gt;CSS設計手法&lt;/a&gt;とかCSSフレームワークとかいろいろ書き漏れた。&lt;/p&gt;

&lt;p&gt;フロントエンドのユニットテストとかE2Eテストとかもいろいろあって面白い。
(E2Eテストは&lt;a href=&#34;https://www.kaitoy.xyz/2017/08/04/browser-test-framework/&#34;&gt;前に書いた&lt;/a&gt;。)&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;p&gt;年表も気が向いたら追加したい。&lt;/p&gt;

&lt;p&gt;しかし&lt;a href=&#34;https://www.kaitoy.xyz/2018/08/19/creating-react-redux-app-from-scratch-01/&#34;&gt;React+Reduxに再入門したよ、っていう記事&lt;/a&gt;の前座として書くつもりだったのに、ずいぶん長編になってしまった…&lt;/p&gt;
</description>
        </item>
      
    

  </channel>
</rss>
